<?xml version="1.0" encoding="UTF-8"?>

<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="messagecollection.xsd">

    <Plugin>
        <ShortDescription>fb-contrib plugin</ShortDescription>
        <Details>
            <![CDATA[
            <p>This plugin contains FindBugs detectors from the fb-contrib project</p>
            ]]>
        </Details>
        <BugsUrl>http://fb-contrib.sourceforge.net/bugdescriptions.html</BugsUrl>
        <AllBugsUrl>http://fb-contrib.sourceforge.net/bugdescriptions.html</AllBugsUrl>
    </Plugin>

    <!-- Detectors -->

    <Detector class="com.mebigfatguy.fbcontrib.collect.CollectStatistics">
        <Details>
            <![CDATA[
            <p>Collects statistics for other detectors</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.collect.CollectMethodsReturningImmutableCollections">
        <Details>
            <![CDATA[
            <p>Collects method calls that may return immutable collections</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.collect.CollectNullableMethodStatus">
        <Details>
            <![CDATA[
            <p>Collects method calls that can return null</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.InefficientStringBuffering">
        <Details>
            <![CDATA[
            <p>Looks for appending strings inside of calls to StringBuffer or StringBuilder append.</p>
            <pre>
                StringBuilder sb = new StringBuilder();
                sb.append(a + b);
                return sb.toString();
            </pre>
            You should use the .append method to append values
            <pre>
                sb.append(a).append(b);
            </pre>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SyncCollectionIterators">
        <Details>
            <![CDATA[
            <p>Looks for use of iterators on synchronized collections built from the java.util.Collections class.</p>
            <p>As the collection in question was built through Collections.synchronizedXXX, an assumption
            is made that this collection must be multithreading safe. However, iterator access is used,
            which is explicitly unsafe. When iterators are to be used, synchronization should be done manually.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CyclomaticComplexity">
        <Details>
            <![CDATA[
            <p>Calculates the McCabe Cyclomatic Complexity measure and reports methods that have an
            excessive value. This report value can be set with system property 'fb-contrib.cc.limit'.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.OverlyConcreteParameter">
        <Details>
            <![CDATA[
            <p>Looks for parameters that are defined by classes, but where the method only uses methods defined by an
            implemented interface or superclass of that class. Relying on concrete classes in public signatures causes cohesion,
            and makes low impact changes more difficult.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ListIndexedIterating">
        <Details>
            <![CDATA[
            <p>Looks for for loops that iterate over a java.util.List using an integer index, and get,
            rather than using an Iterator. An iterator may perform better depending on List implementation,
            but more importantly will allow the code to be converted to other collection types.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnrelatedCollectionContents">
        <Details>
            <![CDATA[
            <p>Looks for collections or arrays that hold objects that are unrelated through class or
            interface inheritance other than java.lang.Object. Doing so makes for brittle code,
            relying either on positional correspondence for type, or a reliance on instanceof to
            determine type. A better design usually can be had by creating a separate class,
            which defines the different types required, and adding an instance of that class to the
            collection, or array.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.RuntimeExceptionDeclared">
        <Details>
            <![CDATA[
            <p>Looks for methods that declare RuntimeExceptions in their throws clause. While doing
            so is not illegal, it may represent a misunderstanding as to the exception in question.
            If a RuntimeException is declared, it implies that this exception type is expected to happen,
            which if true should be handled in code, and not propagated. </p>
            <p>It is a fast detector.</p>
            <p>As an example, every method could be declared like this:
            <code>
            public void foo() throws NullPointerException {
            }
            </code>
            But what does that tell you? Is this method very very likely to throw NullPointerExceptions?
            If it is, why isn't this method handling them so that exceptions aren't thrown? So don't do this.
            If an NPE is very likely, then check for it, and handle the situation.
            </p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ClassEnvy">
        <Details>
            <![CDATA[
            <p>Looks for methods that use a high percentage of methods from another class over their class' own
            methods. When this is the case, it is often better to implement this method in that other class,
            by refactoring the class to accept parameters it needs from the source class.
            The reporting percentage can be set with system property 'fb-contrib.ce.percent'.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.LiteralStringComparison">
        <Details>
            <![CDATA[
            <p>Looks for methods that compare strings against literal strings, where the literal string
            is passed as the parameter. If the .equals or .compareTo is called on the literal itself, passing
            the variable as the parameter, you avoid the possibility of a NullPointerException.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PartiallyConstructedObjectAccess">
        <Details>
            <![CDATA[
            <p>Looks for constructors of non-final classes that make method calls to non-final methods.
            As these methods could be overridden, the overridden method will be accessing an object that
            is only partially constructed, perhaps causing problems. Making these called methods final is
            an easy fix, where possible.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DubiousListCollection">
        <Details>
            <![CDATA[
            <p>Looks for fields that are implementations of java.util.List, but that are used in a set-like fashion.
            Since lookup type operations are performed using a linear search for Lists, the performance for large
            Lists will be poor. Consideration should be made as to whether these fields should be sets. In the
            case that order is important, consider using LinkedHashSet.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ParallelLists">
        <Details>
            <![CDATA[
            <p>Looks for classes that maintain two or more lists or arrays associated one-for-one through the same index
            to hold two or more pieces of related information. It would be better to create a new class that holds
            all of these pieces of information, and place instances of this class in one list. Or if the two lists are
            related in key/value fashion, then use a map instead.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.FinalParameters">
        <Details>
            <![CDATA[
            <p>Looks for methods that correctly do not write to a parameter. To help document this, you should consider
            defining these parameters as final.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.AbstractClassEmptyMethods">
        <Details>
            <![CDATA[
            <p>Looks for abstract classes that define empty methods or methods that simply throw an
            exception. Since this is an abstract class, it may be cleaner to simply define this method
            as abstract, so that correct subclass behavior is enforced.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ManualArrayCopy">
        <Details>
            <![CDATA[
            <p>Looks for methods that copy data from one array to another using a loop. It is
            better performing to use System.arraycopy to do such copying as this is a native method.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.FloatingPointLoops">
        <Details>
            <![CDATA[
            <p>Looks for methods that use floating point indexes for loops. Since floating point
            math is imprecise, rounding errors will occur each time through the loop causing
            hard-to-find problems. It is usually better to use integer indexing, and calculate
            the correct floating point value from the index.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonCollectionMethodUse">
        <Details>
            <![CDATA[
            <p>Looks for method calls to collection classes where the method is not defined by the Collections
            interface, and an equivalent method exists in the interface. Examples include:<br/>
            <table border="1">
                <tr><th>Old Method</th><th>New Method</th></tr>
                <tr><td>Hashtable.contains</td><td>Map.containsValue</td></tr>
                <tr><td>Hashtable.elements</td><td>Map.elements</td></tr>
                <tr><td>Hashtable.keys</td><td>Map.keySet</td></tr>
                <tr><td>Vector.addElement</td><td>List.add</td></tr>
                <tr><td>Vector.elementAt</td><td>List.get</td></tr>
                <tr><td>Vector.insertElementAt</td><td>List.add</td></tr>
                <tr><td>Vector.removeAllElements</td><td>List.clear</td></tr>
                <tr><td>Vector.removeElement</td><td>List.remove</td></tr>
                <tr><td>Vector.removeElementAt</td><td>List.remove</td></tr>
                <tr><td>Vector.setElementAt</td><td>List.set</td></tr>
            </table>
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingAutoboxedOverloading">
        <Details>
            <![CDATA[
            <p>Looks for methods that have the same signature, except where one uses a
            Character parameter, and the other uses an int, long, float, double parameter.
            Since autoboxing is available in 1.5 one might assume that
<pre><code>
test('a')
</code></pre>
            would map to
<pre><code>
public void test(Character c)
</code></pre>
            but it instead maps to one that takes an int, long, float or double, such as
<pre><code>
public void test(int i)
</code></pre>
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.AbnormalFinallyBlockReturn">
        <Details>
            <![CDATA[
            <p>Looks for methods that have finally blocks that return values
            or throw exceptions. This code will swallow normal program flow and
            hide real program logic.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.StaticMethodInstanceInvocation">
        <Details>
            <![CDATA[
            <p>Looks for methods that make static method calls using an instance reference.
            For documentation purposes, it is better to call the method using the class name.
            This may represent a change in definition that should be noticed.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SpuriousThreadStates">
        <Details>
            <![CDATA[
            <p>Looks for methods that call wait, notify or notifyAll on an instance of a
            java.lang.Thread. Since the internal workings of the threads is to synchronize on the
            thread itself, introducing client calls will confuse the thread state of the object
            in question, and will cause spurious thread state changes, either waking threads up
            when not intended, or removing the thread from the runnable state.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessAutoboxing">
        <Details>
            <![CDATA[
            <p>Looks for methods that pass a primitive wrapper class object to the
            same class' Constructor. Patterns found are:
            <ul>
                <li>new Boolean(Boolean)</li>
                <li>new Byte(Byte)</li>
                <li>new Character(Character)</li>
                <li>new Short(Short)</li>
                <li>new Integer(Integer)</li>
                <li>new Long(Long)</li>
                <li>new Float(Float)</li>
                <li>new Double(Double)</li>
            </ul>
            Since primitive wrapper classes are immutable this is needless garbage being created. Just
            use the original reference.
            </p>
            <p>It also looks for calls to BoxedClass.valueOf(x) where X is already a BoxedClass</p>
            <p>It also looks for calls to BoxedClass.valueOf(myString).boxedValue(), when instead it is
            simpler to use BoxedClass.parseBoxed(myString)</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryStoreBeforeReturn">
        <Details>
            <![CDATA[
            <p>Looks for methods that store the return result in a local variable and
            then immediately return that local variable. It is simpler to just return
            the method (or assignment) result directly.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CopiedOverriddenMethod">
        <Details>
            <![CDATA[
            <p>Looks for methods that are direct copies of the implementation in the superclass.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ArrayBasedCollections">
        <Details>
            <![CDATA[
            <p>Looks for methods that use arrays for items in the keySet of a map, or as
            an element of a set, or in a list when using the contains method. Since arrays
            do not, and cannot define an equals method, reference equality is used for these
            collections, which is probably not desired. If it is, consider using the IdentityHashMap
            class when using Maps in this case, to better document your intentions.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.OrphanedDOMNode">
        <Details>
            <![CDATA[
            <p>Looks for methods that create DOM nodes but do not add them to any DOM Document.
            Either the node needed to be added to the tree, or the node likely was created in error.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.AbstractOverriddenMethod">
        <Details>
            <![CDATA[
            <p>Looks for methods that are declared as abstract that override concrete methods in a
            superclass. Doing this casts away the implementation of the superclass, and breaks
            the contract as set forth by the parent class.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CustomBuiltXML">
        <Details>
            <![CDATA[
            <p>Looks for methods that build XML based strings by concatenating strings
            and custom values together. Doing so makes brittle code, that is difficult to
            modify, validate and understand. It is cleaner to create external XML files that are
            transformed at runtime, using parameters set through Transformer.setParameter.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.BloatedSynchronizedBlock">
        <Details>
            <![CDATA[
            <p>Looks for methods that are implemented using synchronized blocks, but are overly
            synchronized because the beginning of the block only accesses local variables,
            and not member variables, or this.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConstantListIndex">
        <Details>
            <![CDATA[
            <p>Looks for methods that access arrays or classes that implement java.util.List
            using a constant integer for the index. This is often a typo intended to be a loop
            variable, but if specific indices mean certain things, perhaps a first class object
            would be a better choice for a container, or even a map with informative key names
            would be better.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SloppyClassReflection">
        <Details>
            <![CDATA[
            <p>Looks for methods that use Class.forName("XXX") to load a class object
            for a class that is already referenced by this class. It is simpler to just use
            XXX.class, and doing so protects the integrity of this code from such transformations
            as obfuscation. Use of Class.forName should only be used when the class in question
            isn't already statically bound to this context.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ArrayWrappedCallByReference">
        <Details>
            <![CDATA[
            <p>Looks for methods that use an array of length one to pass a variable to achieve call
            by pointer ala C++. It is better to define a proper return class type that holds all
            the relevant information retrieved from the called method.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SluggishGui">
        <Details>
            <![CDATA[
            <p>Looks for methods that implement AWT or Swing listeners and perform time
            consuming operations. Doing these operations in the GUI thread will cause the
            interface to appear sluggish and non-responsive to the user. It is better to
            use a separate thread to do the time consuming work so that the user
            has a better experience.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessInstanceRetrieval">
        <Details>
            <![CDATA[
            <p>Looks for methods that call a method to retrieve a reference to an object,
            to use to load a constant. It is simpler and more performant to access the
            static variable directly from the class itself.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DateComparison">
        <Details>
            <![CDATA[
            <p>Looks for inefficient comparison of Date objects using two comparisons when one would do.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousWaitOnConcurrentObject">
        <Details>
            <![CDATA[
            <p>Looks for calls to the wait method on mutexes defined in the java.util.concurrent
            package where it is likely that await was intended.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.JDBCVendorReliance">
        <Details>
            <![CDATA[
            <p>Looks for uses of JDBC vendor specific classes and methods making the database
            access code non-portable.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PossibleMemoryBloat">
        <Details>
            <![CDATA[
            <p>Looks for classes that have usage patterns that may cause memory bloat to occur.
            This can occur with classes maintain collections or StringBuffer/StringBuilders in
            static member variables, and that do not appear to provide a way to clear or remove
            items from these members. 
            Other cases are use of JAXBContexts stored recreated over and over again, instead of 
            using a cached instance.
            Such class fields are likely causes of memory bloat.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.LocalSynchronizedCollection">
        <Details>
            <![CDATA[
            <p>Looks for allocations of synchronized collections that are stored in local
            variables, and never stored in fields or returned from methods. As local variables
            are by definition thread safe, using synchronized collections in this context
            makes no sense.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.FieldCouldBeLocal">
        <Details>
            <![CDATA[
            <p>Looks for classes that define fields that are used in a local-only fashion,
            specifically private fields that are accessed first in each method with a
            store vs. a load.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonOwnedSynchronization">
        <Details>
            <![CDATA[
            <p>Looks for methods that synchronize on variables that are not owned by the
            current class. Doing this causes confusion when two classes use the same variable
            for their own synchronization purposes. For cleanest separation of interests, only
            synchronize on private fields of the class. Note that 'this' is not owned by
            the current class and synchronization on 'this' should be avoided as well.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonRecycleableTaglibs">
        <Details>
            <![CDATA[
            <p>Looks for tag libraries that are not recycleable because backing members
            of taglib attributes are set in areas besides the setter method for the attribute.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.Section508Compliance">
        <Details>
            <![CDATA[
            <p>Looks for violation of Section 508, Accessibility for People with Disabilities Act.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseEnumCollections">
        <Details>
            <![CDATA[
            <p>Looks for use of sets and maps using enums. It is more efficient to use EnumSet or EnumMap.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SQLInLoop">
        <Details>
            <![CDATA[
            <p>Looks for the execution of SQL queries inside a loop. This pattern tends to be inefficient,
            and often can be improved upon, by collecting all the keys needed for the query and issuing just
            one query using an in clause with all the keys for all the queries previously needed in the loop.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessMemberCollectionSynchronization">
        <Details>
            <![CDATA[
            <p>Looks for classes that define private synchronized collections as static or instance
            members, that are only altered in a static initializer or constructor. Since the multithreaded
            use of this collection is read-only, the use of synchronization is unnecessary.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.InheritanceTypeChecking">
        <Details>
            <![CDATA[
            <p>Looks for if/else blocks where a series of them use instanceof on the same
            variable to determine what to do. If these classes are related by inheritance,
            this often is better handled through calling a single overridden method.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.StaticArrayCreatedInMethod">
        <Details>
            <![CDATA[
            <p>Looks for creation of arrays in methods using constant values. These arrays
            will need to be recreated each time the method is called. These arrays should probably
            be defined as static fields, instead.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PossiblyRedundantMethodCalls">
        <Details>
            <![CDATA[
            <p>Looks for calls of the same method on the same object when that object hasn't changed.
            This often is redundant, and the second call can be removed, or combined.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseToArray">
        <Details>
            <![CDATA[
            <p>Looks for code that builds an array of values from a collection, by manually looping
            over the elements of the collection, and adding them to the array. It is simpler and
            cleaner to use mycollection.toArray(new type[mycollection.size()]).</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.LostExceptionStackTrace">
        <Details>
            <![CDATA[
            <p>Looks for methods that catch exceptions, and then throw a different exception
            without embedding the original exception in the thrown one. Doing so, hides the real
            source of the exception, making debugging and fixing these problems difficult.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseCharacterParameterizedMethod">
        <Details>
            <![CDATA[
            <p>Looks for methods that pass single character string constants as parameters to
            methods that alternatively have an overridden method that accepts a character instead.
            It is easier for the method to handle a single character than a String.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.TailRecursion">
        <Details>
            <![CDATA[
            <p>Looks for methods that make recursive calls to themselves as the last statement in the
            method. This tail recursion could be converted into a simple loop which would improve
            the performance and stack requirements.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnrelatedReturnValues">
        <Details>
            <![CDATA[
            <p>Looks for methods that are defined to return Object, and return different types of
            objects based on different code paths. If this method is not based on an interface or
            superclass, it is suggested to change the return type to a type that would accommodate
            all kinds of return types.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PossibleIncompleteSerialization">
        <Details>
            <![CDATA[
            <p>Looks for classes that don't handle serialization of parent class member fields
            when the class in question is serializable but is derived from a non serializable
            class.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousComparatorReturnValues">
        <Details>
            <![CDATA[
            <p>Looks for classes that implement Comparator or Comparable, and whose compare or compareTo
            methods return constant values only, but that don't represent the three possible choices
            (a negative number, 0, and a positive number).</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SillynessPotPourri">
        <Details>
            <![CDATA[
            <p>Looks for a potpourri of small problems that do not fit into a common pattern.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.BloatedAssignmentScope">
        <Details>
            <![CDATA[
            <p><em>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</em></p>
            <p>Looks for assignments to variables in a scope larger than their use. As long as the evaluation of the assignment
            does not have side effects, the assignment can be moved into the inner scope where it is used.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SpoiledChildInterfaceImplementor">
        <Details>
            <![CDATA[
            <p>Looks for classes that implement interfaces by relying on methods being
            implemented in superclasses, even though the superclass knows nothing about
            the interface being implemented by the child.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DeletingWhileIterating">
        <Details>
            <![CDATA[
            <p>Looks for deletion of items from a collection using the remove method
            of the collection at the same time that the collection is being iterated on. If
            this occurs the iterator will become invalid and throw a ConcurrentModificationException.
            Instead, the remove should be called on the iterator itself.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseSplit">
        <Details>
            <![CDATA[
            <p>Looks for code that builds an array by using a StringTokenizer to break up
            a string and place individual elements into an array. It is simpler to use
            String.split instead.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousJDKVersionUse">
        <Details>
            <![CDATA[
            <p>Looks for calls to classes and methods that do not exist in the JDK for which this class is
            compiled. This can happen if you specify the <code>-source</code> and <code>-target</code> options of the javac compiler, and
            specify a target that is less than the JDK version of the javac compiler.</p>
            <p>It relies on the system property <code>-Dfb-contrib.sjvu.jdkhome=/path/to/older/jdk/to/check"</code> to specify
            what JDK to compare against. On linux, you may need to give file permissions to findbugs to read these directories.
            If this property is not set, this detector does nothing.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseAddAll">
        <Details>
            <![CDATA[
            <p>Looks for loops that transfer the contents of one collection to another. These collection sources might
            be local variables or member fields, including sets, maps key/values, lists, or arrays. It is simpler to
            just use the addAll method of the collection class. In the case where the source is an array, you can use
            Arrays.asList(array), and use that as the source to addAll.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.MethodReturnsConstant">
        <Details>
            <![CDATA[
            <p>Looks for private or static methods that only return one constant value. Since there is no
            chance for derived classes overriding this behavior, the return of a constant value
            seems dubious.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessCustomSerialization">
        <Details>
            <![CDATA[
            <p>Looks for classes that implement the Serializable interface and implement the
            standard readObject and writeObject methods by simply deferring to the Stream
            parameter's defaultReadObject or defaultWriteObject and nothing else. As this is the
            built in behavior, these methods are not needed.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.MisleadingOverloadModel">
        <Details>
            <![CDATA[
            <p>Looks for classes that define both static and instance methods with the same name.
            As each type represents a different use model, it doesn't make sense that this name
            would be overloaded, and will confuse users of the class.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ExceptionSoftening">
        <Details>
            <![CDATA[
            <p>Looks for methods that catch checked exceptions, and throw unchecked
            exceptions in their place. There are several levels of concern. Least
            concerning are methods constrained by interface or superclass contracts
            not to throw checked exceptions but appear owned by the same author. Next
            are methods constrained by interface or superclass contracts and throw other
            types of checked exceptions. Most egregious are methods not constrained by any interface
            or superclass contract.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingFunctionSemantics">
        <Details>
            <![CDATA[
            <p>Looks for methods that return a parameter after modifying that parameter.
            Doing this will confuse the user of this method, as it will be assumed that the
            passed in argument is different than the output, or at least won't be changed.
            If the purpose of this method is just to modify the parameter, this method should
            probably be changed to have a void return type. If you must return a variable, perhaps
            a clone of the parameter should be returned.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnitTestAssertionOddities">
        <Details>
            <![CDATA[
            <p>Looks for JUnit or TestNG test case methods that use assertions with odd parameters.
            Included in this is:
            <ul>
                <li>Passing a constant as the second (actual) parameter in a JUnit test</li>
                <li>Not using the three parameter version of asserts for doubles</li>
                <li>Passing true or false as the first parameter instead of using assertTrue, or assertFalse</li>
                <li>Using the assert keyword</li>
            </ul>
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousCloneAlgorithm">
        <Details>
            <![CDATA[
            <p>Looks for implementations of clone where an assignment is made to a field of the
            source object. It is likely that that store should have occurred on the cloned object, as
            the clone operation is almost always considered read only.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.WeakExceptionMessaging">
        <Details>
            <![CDATA[
            <p>Looks for exceptions that are thrown with static strings as messages. Using static strings
            doesn't differentiate one use of this method versus another, and so it may be difficult
            to determine how this exception occurred without showing context.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousClusteredSessionSupport">
        <Details>
            <![CDATA[
            <p>Looks for code that fetches a complex object from an HttpSession attribute, modifies the
            object, but does not call setAttribute again on this object. This will not inform the application server
            that this object has changed, and thus will not correctly replicate these changes across the cluster.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.LoggerOddities">
        <Details>
            <![CDATA[
            <p>Looks for odd patterns of use of Logger classes from either Log4j, Log4j2, SLF4J or Commons Logging.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.IncorrectInternalClassUse">
        <Details>
            <![CDATA[
            <p>Looks for classes that rely on internal classes in the various APIs or libraries. As these
            classes are not officially released from the API vendor, they are subject to change or removal, and thus,
            should not be counted on.</p>
            Packages that shouldn't be used are:
            <ul>
                <li>sun.xxx</li>
                <li>org.apache.xerces.xxx</li>
                <li>org.apache.xalan.xxx</li>
            </ul>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DubiousSetOfCollections">
        <Details>
            <![CDATA[
            <p>Looks for sets or keySets of maps that contain other collections. As typically collections calculate
            their hashCode, equals and compareTo methods by iterating the collection and evaluating the same function
            on each item in the collection, this can be costly from a performance point of view.</p>
            <p>In addition, using a set, or keySet of a map, infers that you will be looking for items based on
            the value of a collection, which seems dubious at best.</p>
            <p>Finally, as collections are often modified, this may cause problems if the collection is modified,
            thus changing hashCodes, etc, while the collection is in the set.</p>
            <p>If you wish to keep a collection of collections, the outer collection should probably be a list
            to avoid these problems.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.BogusExceptionDeclaration">
        <Details>
            <![CDATA[
            <p>Looks for constructors, static methods and private methods that declare that they throw
            checked exceptions that the actual code never throws. Since these methods can't be overridden,
            there is no reason to add these exceptions to the method declaration.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryNewNullCheck">
        <Details>
            <![CDATA[
            <p>Looks for allocations of objects, and then immediately checking to see if the
            object is null, or non null. As the new operator is guaranteed to either succeed, or throw
            an exception, this null check is useless, and denotes a misunderstanding as to how
            the JVM works. You can remove this guard.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DeprecatedTypesafeEnumPattern">
        <Details>
            <![CDATA[
            <p>Looks for classes that appear to implement the old style type safe enum pattern
            that was used before Java added Enum support to the language. Since this class is
            compiled with Java 1.5 or later, it would be simpler to just use Java enums.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.TristateBooleanPattern">
        <Details>
            <![CDATA[
            <p>Looks for methods that are declared to return a Boolean, but return a null
            value. As this now allows the method to return three values, the use of Boolean is
            dubious. It would be better to just define a new enumeration with three values,
            and return that.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousUninitializedArray">
        <Details>
            <![CDATA[
            <p>Looks for methods that return arrays that are allocated but not initialized
            in this method. While it's possible that the calling method will do the work of
            initializing the array, it is not a usual pattern, and it is suspected that this array
            was just forgotten to be initialized.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.InappropriateToStringUse">
        <Details>
            <![CDATA[
            <p>Looks for methods that perform algorithmic operations on Strings that are returned
            from a toString() method. As toString should only be used for debug/trace purposes, it
            shouldn't be used for algorithm use.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.InconsistentKeyNameCasing">
        <Details>
            <![CDATA[
            <p>Looks for methods that use the same name with different casing to access objects in HttpRequest parameters
            and attributes. As these parameter names are case-sensitive this will lead to confusion.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.OverzealousCasting">
        <Details>
            <![CDATA[
            <p>Looks for manual casts of objects that are more specific than needed as the value is assigned
            to a class or interface higher up in the inheritance chain. You only need to cast to that class
            or interface.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PoorlyDefinedParameter">
        <Details>
            <![CDATA[
            <p>Looks for non derivable methods that declare parameters and then cast those
            parameters to more specific types in the method. This is misleading and dangerous
            as you are not documenting through parameter types what is necessary for these
            parameters to function correctly.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonSymmetricEquals">
        <Details>
            <![CDATA[
            <p>Looks for classes that break the fundamental rule of equivalence, which is
            symmetry. If a equals b, then b equals a. While it is usually wrong to allow
            equals to compare different types, at the very least you should make sure that
            each class knows about each other and is able to compare themselves with each other.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ContraVariantArrayAssignment">
        <Details>
            <![CDATA[
            <p>Finds contravariant array assignments. Since arrays are mutable data structures, their use
            must be restricted to covariant or invariant usage.</p>

<pre><code>
class A {}
class B extends A {}

B[] b = new B[2];
A[] a = b;
a[0] = new A(); // results in ArrayStoreException (Runtime)
</code></pre>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonFunctionalField">
        <Details>
            <![CDATA[
            <p>Looks for fields in serializable classes that are defined as both final and
            transient. As a transient field is not initialized when streamed, and is not
            initialized in a constructor, it will remain null because it is defined final.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousNullGuard">
        <Details>
            <![CDATA[
            <p>Looks for code that checks to see if a field or local variable is not null,
            before entering a code block - either an if, or while statement - and then reassigns that
            field or local variable. It is likely that guard should have been to see if that
            field or local variable is null, not, not null.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.MoreDumbMethods">
        <Details>
            <![CDATA[
            <p>This detector looks for calls to more pointless or deprecated methods.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ReflectionOnObjectMethods">
        <Details>
            <![CDATA[
            <p>This detector looks for reflective calls on methods that are found in the class java.lang.Object.
            As these methods are always available, there is no reason to use reflection to call them.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ImproperPropertiesUse">
        <Details>
            <![CDATA[
            <p>This detector looks for java.util.Properties use where values other than String
            are placed in the properties object. As the Properties object was intended to be a
            String to String only collection, putting other types in the Properties object is
            incorrect, and takes advantage of a poor design decision by the original Properties class
            designers to derive from Hashtable, rather than using aggregation.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PossibleConstantAllocationInLoop">
        <Details>
            <![CDATA[
            <p>This detector looks for allocations of objects using the default constructor in a loop, where
            the object allocated is never assigned to any object that is used outside the loop.
            It is possible that this allocation can be done outside the loop to avoid excessive garbage.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.WriteOnlyCollection">
        <Details>
            <![CDATA[
            <p>This detector looks for allocations and initializations of Java collections, but that are never
            read from or accessed to gain information. This represents a collection of no use, and most probably
            can be removed. It is similar to a dead local store.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseVarArgs">
        <Details>
            <![CDATA[
            <p>This detector looks for definitions of methods that have an array as the last parameter.
            Since this class is compiled with Java 1.5 or better, it would be more flexible for clients of this
            method to define this parameter as a vararg parameter.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PossibleUnsuspectedSerialization">
        <Details>
            <![CDATA[
            <p>This detector looks for code that serializes objects that are non-static inner
            classes of other classes. Since there is a reference to the containing class, this class will be serialized as well.
            It is often the case that this is not what is wanted, and will cause much more data to be serialized
            than is necessary.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SideEffectConstructor">
        <Details>
            <![CDATA[
            <p>This detector looks for object creation where the object isn't assigned to any variable or
            field. This implies that the class operates through side effects in the constructor, which makes
            for difficult-to-maintain code.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousGetterSetterUse">
        <Details>
            <![CDATA[
            <p>This detector looks for Java bean getter-setter use where the value of a property is set
            with the value retrieved from the same bean's corollary getter, like this:</p>
<pre><code>
    person.setAge(person.getAge());
</code></pre>
            <p>Typically this is a copy paste typo.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.LingeringGraphicsObjects">
        <Details>
            <![CDATA[
            <p>This detector looks for creation of java.awt.Graphics objects that do not have the
            <code>.dispose()</code> method called on them when finished. These objects will be cleaned up by
            the Garbage collector, bug given the likelihood that large numbers of these objects can
            be created in a short period of time, it is better to dispose them as soon as possible.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.StackedTryBlocks">
        <Details>
            <![CDATA[
            <p>This detector looks for two or more try-catch blocks that are consecutive
            and catch the same kind of exception, and each catch block mandatorily throws
            the same exception. These two catch blocks can and should be made into one
            catch block to simply the code.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CommonsEqualsBuilderToEquals">
        <Details>
            <![CDATA[
            <p>This detector looks for uses for commons-lang EqualsBuilder where the
            result of equals() is returned instead of calling the method isEquals().</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CommonsHashcodeBuilderToHashcode">
        <Details>
            <![CDATA[
            <p>This detector looks for uses for commons-lang <code>HashCodeBuilder</code> where the
            result of <code>hashCode()</code> is returned instead of calling the method <code>toHashCode()</code>.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CommonsStringBuilderToString">
        <Details>
            <![CDATA[
            <p>This detector looks for uses for commons-lang <code>ToStringBuilder</code> where the
            result of <code>toString()</code> is returned without an intermediate invocation of append().</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CompareClassNameEquals">
        <Details>
            <![CDATA[
            <p>In a JVM, two classes are the same class (and consequently the same type) if
            they are loaded by the same class loader, and they have the same fully
            qualified name [JVMSpec 1999].

            Comparing class name ignores the class loader.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.BackportReusePublicIdentifiers">
        <Details>
            <![CDATA[
            <p>Detects use of Backport Utils concurrent classes from Emory, or Time classes from ThreeTen. Updated/efficient versions of
            classes from emory are available in versions of the JDK 5.0 and higher, and in JDK 8.0 and higher for ThreeTen, and these
            classes should only be used if you are targeting a JDK lower than this.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CloneUsability">
        <Details>
            <![CDATA[
            <p>Looks for classes that implement clone() that do not specialize the return value, and do
            not swallow CloneNotSupportedException. Not doing so makes the clone method not as simple to use,
            and should be harmless to do so.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingArrayAsList">
        <Details>
            <![CDATA[
            <p>Looks for calls to Arrays.asList where the parameter is a primitive array.
            This does not produce a list that holds the primitive boxed values, but a list of
            one item, the array itself.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PresizeCollections">
        <Details>
            <![CDATA[
            <p>Looks for methods that create collections using the default constructor,
            even though the number of elements that will be placed in the collection is known
            a priori, and thus could be pre-allocated. Not doing so just causes more intermediate
            reallocations which is unnecessary.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnboundMethodTemplateParameter">
        <Details>
            <![CDATA[
            <p>Looks for methods that declare method level template parameter(s) that are not bound to any of the
            method's parameters, and thus is not adding any validation/type safety to the method, and is
            just confusing.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonProductiveMethodCall">
        <Details>
            <![CDATA[
            <p>Looks for common methods that are non mutating where the return value is ignored. As these methods
            do not change the object they are called on, calling these methods is pointless. They can be removed.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ArrayIndexOutOfBounds">
        <Details>
            <![CDATA[
            <p>Looks for questionable load/stores to array elements.
            <ul>
            <li>
            Looks for accesses to array elements using literal values that are known to be outside the bounds of the array.
            This mistake will cause an ArrayIndexOutOfBoundsException to occur at runtime.</li>
            <li>
            Looks for stores to array elements where the array itself appears to have not been allocated.
            </li>
            </ul>
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.InvalidConstantArgument">
        <Details>
            <![CDATA[
            <p>Looks for method calls that take a parameter value that does not match one of the expected
            values for that parameter. It is likely this parameter value should really be an enum, but predates
            the addition of enums to Java. Passing an invalid value will likely cause problems in the execution of
            the method.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CollectionNamingConfusion">
        <Details>
            <![CDATA[
            <p>Looks for fields or local variables that are collections but the names have a different type
            of collection in the name. This is confusing, and is probably a left over from a type change, such as
            </p>
            <p>List&lt;String&gt; mySet;</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PoorMansEnum">
        <Details>
            <![CDATA[
            <p>Looks for fields defined with simple types, (int, String, etc) that are used like enums. Specifically fields that are
            only assigned a set of constant values. This variable probably should be redefined as an enum.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnusedParameter">
        <Details>
            <![CDATA[
            <p>Looks for private or static methods that have parameters that aren't used. These parameters
            can be removed, assuming the method isn't used through reflection.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.FindClassCircularDependencies">
        <Details>
            <![CDATA[
            <p>This detector looks for circular dependencies among classes. </p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ModifyingUnmodifiableCollection">
        <Details>
            <![CDATA[
            <p>This detector looks for code that attempts to modify a collection that is or may be
            defined as immutable. Doing so will cause exceptions at runtime.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.HangingExecutors">
        <Details>
            <![CDATA[
            <p>Three detectors for hanging ExecutorServices, that is, ExecutorServices that never get a call to shutdown, which
            can potentially cause the JVM to not exit.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.HttpClientProblems">
        <Details>
            <![CDATA[
            <p>The HttpRequests from the Apache HttpComponents have some little-known quirks about them.
            This is a set of detectors that helps guard against resource starvation.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.Unjitable">
        <Details>
            <![CDATA[
            <p>This detector looks for methods that are longer than 8000 bytes. Methods this
            long are automatically disqualified by the JIT for compilation and will always be
            emulated. Consider breaking this method up to avoid this, if performance is important.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConflictingTimeUnits">
        <Details>
            <![CDATA[
            <p>Looks for methods that perform arithmetic operations on values representing time
            where the time unit is incompatible, e.g. adding a millisecond value to a nanosecond value.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CharsetIssues">
        <Details>
            <![CDATA[
            <p>Looks for manual specification of String encoding using String constants where either
            a StandardCharset could be used (JDK7) or where the encoding is not recognized with the
            current JDK.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ContainsBasedConditional">
        <Details>
            <![CDATA[
            <p>Looks for complex <code>if</code> expressions made up of multiple conditions joined by OR, where the same
            local variable is compared to a static value. When the number of conditions grows it is much cleaner
            to build a static set of the possible values, and use the <code>contains</code> method on that set. This will
            shorten the code, and make it more self documenting.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.OverlyPermissiveMethod">
        <Details>
            <![CDATA[
            <p>Looks for methods that are declared more permissively than the code is using. For instance, declaring
            a method public, when it could just be declared private. Giving methods more permissive access than they
            need to have limits your ability to make observations about these methods, like parameter usage,
            refactorability, and derivability. This detector will not report on methods that are never called, in
            case this method is an API-like method intended to be called by client code. If this method is
            also called through reflection, this detector may erroneously report it.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.StringifiedTypes">
        <Details>
            <![CDATA[
            <p>Looks for classes that store fields that are Strings that impersonate instances of classes, or collections that are
            fields that hold Strings that impersonate a class. Examples of String impersonation are storing:
            <ul>
                <li>The result of a toString call</li>
                <li>Strings built from parsing or building strings from other objects, such as "1,2,3,4" or "Project:3"</li>
            </ul>
            By using Strings you are throwing away type-safety, and making it difficult to reason about what the values of variables
            in use are. If a String has multiple parts to it, it probably belongs as a first-class Class.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousLoopSearch">
        <Details>
            <![CDATA[
            <p>Looks for methods that assign a value to a variable in an "if equals" conditional in a loop, but do not break after doing so.
            Since equality would seem to be a one time event, continuing with the loop seems pointless, and a break statement in the if statement
            seems like it should be added.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConflatingResourcesAndFiles">
        <Details>
            <![CDATA[
            <p>Looks for methods that use the File API on resources retrieved from URLs where the URL in question isn't from a file protocol.
            In the case of classpath resources, this will work if the code is executed from directories, but fail using JARs.
            If using resources, then use URL.openStream() method instead of File APIs.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ImmatureClass">
        <Details>
            <![CDATA[
            <p>Looks for classes that are not fully complete from a usability point of view, making them more difficult to use
            than they should be. Things such as
            <ul>
            <li>Using the default package</li>
            <li>Missing hashCode/equals</li>
            <li>Missing toString() method</li>
            <li>Using autogenerated parameter names</li>
            </ul>
            </p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.JAXRSIssues">
        <Details>
            <![CDATA[
            <p>Looks for problems with the use of the JAX-RS specification.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.JPAIssues">
        <Details>
            <![CDATA[
            <p>Looks for problems with the use of the JPA specification, including Spring's
            support of JPA</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuboptimalExpressionOrder">
        <Details>
            <![CDATA[
            <p>Looks for conditional expressions that are a combination of simple local variable (in)equalities
            and tests on the results of method calls, where the method calls are done first. By placing the simple
            conditions first you may eliminate costly calls in certain cases. This assumes that the method calls
            do not have side effects that should happen always.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.IOIssues">
        <Details>
            <![CDATA[
            <p>Looks for various issues around doing I/O with streams and reader/writers, and compression of byte buffers.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DubiousMapCollection">
        <Details>
            <![CDATA[
            <p>Looks for use of maps that are private fields in a List-only way, that is, maps that are created in constructors
            or static initializers, and are only iterated over. Often this is done because the Map allows for two values, as opposed
            to a List. The fix is to just create a List of some object that holds all the values.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.BuryingLogic">
        <Details>
            <![CDATA[
            <p>Looks for methods that needlessly push a large chunk of code to the right through indenting with braces.
            The code is basically an if/else-then-return structure. The "if true" test does the bulk of the logic, and the else
            just returns. It is more readable if the bulk of the logic is moved as far to the left in the method as is possible.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.WiringIssues">
        <Details>
            <![CDATA[
            <p>Looks for various issues around @Autowired/@Inject fields in DI classes</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConcurrentCollectionIssues">
        <Details>
            <![CDATA[
            <p>Looks for problems with using concurrent collections.
            <ul>
                <li>Adding a collection as a value of a Concurrent map, without the use of putIfAbsent</li>
            </ul>
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseTryWithResources">
        <Details>
            <![CDATA[
            <p>Looks for use of auto-closeable resources in JDK 7 or later that are not using
            the try-with-resources paradigm. To avoid problems, and ease the reader, use of try-with-resources
            is recommended</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousShadedClassUse">
        <Details>
            <![CDATA[
            <p>Looks for use of shaded methods from 3rd-party jars, created by tools such as the Maven shade plugin.
            These methods are from classes that have been included in a jar, for internal use, and are copies of real 3rd-party jars.
            It is likely you meant to use the real class from the real jar, but your IDE picked the wrong import to use.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnsynchronizedSingletonFieldWrites">
        <Details>
            <![CDATA[
            <p>Looks for writes to fields of classes that are believed to be classes used only as Singletons. These
            classes include Enums, as well as spring beans that are Singleton scoped.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.OptionalIssues">
        <Details>
            <![CDATA[
            <p>Looks for various issues with the use of the java.util.Optional class.</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryApiConversion">
        <Details>
            <![CDATA[
            <p>Looks for code that appears to be using two forms of similar apis: an older one, and a new one.
            It finds code that creates newer api objects by first instantiating older api objects, and converting
            them into the new form. It is simpler just to create the new object directly.</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ReflectionIssues">
        <Details>
            <![CDATA[
            <p>Looks for issues around the use of java reflection.</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.AnnotationIssues">
        <Details>
            <![CDATA[
            <p>Looks for issues around use of standard annotations</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.MapUsageIssues">
        <Details>
            <![CDATA[
            <p>Looks for dubious usage patterns around the Map interface</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ListUsageIssues">
        <Details>
            <![CDATA[
            <p>Looks for dubious usage patterns around the List interface</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
    <Detector class="com.mebigfatguy.fbcontrib.detect.FunctionalInterfaceIssues">
        <Details>
            <![CDATA[
            <p>Looks for various issues around the use of @FunctionalInterfaces.</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
    <Detector class="com.mebigfatguy.fbcontrib.detect.SetUsageIssues">
        <Details>
            <![CDATA[
            <p>Looks for various issues around the use of the Set interface</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousArgumentTypes">
        <Details>
            <![CDATA[
            <p>Looks for method calls where the arguments passed seem oddly typed for the use they are intended for.
            </p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
    <Detector class="com.mebigfatguy.fbcontrib.debug.OCSDebugger">
        <Details></Details>
    </Detector>

    <!-- BugPattern -->

    <BugPattern type="ISB_INEFFICIENT_STRING_BUFFERING">
        <ShortDescription>方法在 StringBuffer 或 StringBuilder 的 append() 中使用加号拼接</ShortDescription>
        <LongDescription>方法 {1} 在 StringBuffer 或 StringBuilder 的 append() 中使用加号拼接</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法使用 <code>StringBuffer</code> 或 <code>StringBuilder</code> 的 append() 拼接字符串。然而，它将加号简易拼接的结果作为入参来调用 append()，
            因此无法享受使用 <code>StringBuffer</code> 或 <code>StringBuilder</code> 带来的性能提升。</p>

            <p>
            Java 会隐式使用 StringBuilders，这令此很难被侦测修复。比如，<br/>
<pre><code>
StringBuilder sb = new StringBuilder();
for (Map.Entry<Integer, String> e : map.entrySet()) {
    sb.append(e.getKey() + e.getValue());        //在这里 bug 被侦测到
}
</code></pre><br/>

            会被自动转换为：<br/>
<pre><code>
StringBuilder sb = new StringBuilder();
for (Map.Entry<Integer, String> e : map.entrySet()) {
    StringBuilder tempBuilder = new StringBuilder();
    tempBuilder.append(e.getKey());
    tempBuilder.append(e.getValue());
    <b>sb.append(tempBuilder.toString());</b>        //低效
}
</code></pre><br/>

            这里多用了一个临时的 <code>StringBuilder</code>，完全是没必要的。为防止这种情况发生，只需要：<br/>

<pre><code>
StringBuilder sb = new StringBuilder();
for (Map.Entry<Integer, String> e : map.entrySet()) {
    sb.append(e.getKey());
    sb.append(e.getValue());
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ISB_EMPTY_STRING_APPENDING">
        <ShortDescription>方法通过拼接空字符串激活类型转换</ShortDescription>
        <LongDescription>方法 {1} 通过拼接空字符串激活类型转换</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法拼接了一个空字符串，目的是将输入值转换为字符串。这更有效的方法是用 String.valueOf() 来实现，避免隐式创建并调用 StringBuffer/Builder 带来的成本。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ISB_TOSTRING_APPENDING">
        <ShortDescription>方法拼接字符串时主动调用对象的 toString()</ShortDescription>
        <LongDescription>方法 {1} 拼接字符串时主动调用对象的 toString()</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将 <code>toString()</code> 的结果放入一个 <code>StringBuffer</code> 或 <code>StringBuilder</code>.
            更简单的做法是仅仅将你需要的对象作为 append() 的参数，
            这种形式不会导致潜在的 <code>NullPointerException</code>，而且更易于阅读。</p>

            <p>
            顺带一提，Java 处理简易字符串拼接也会用到 <code>StringBuilder</code>，
            所以就算你没有显式用到 <code>StringBuilder</code>，你也有可能看到这个 Bug。
            </p>

            <p>
            为替换这类代码：<br/>
<pre><code>
StringBuilder builder = ...;
builder.append(someObj.toString());
...
System.out.println("Problem with the object :" + someObj.toString());
</code></pre>

只需要：<br/>

<pre><code>
StringBuilder builder = ...
builder.append(someObj);
...
System.out.println("Problem with the object :" + someObj);
</code></pre>
            来避免当一个对象确实 是空(<code>null</code>) 时报出 <code>NullPointerException</code> 的可能性<code>null</code>.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCI_SYNCHRONIZED_COLLECTION_ITERATORS">
        <ShortDescription>方法在同步集合上创建迭代器</ShortDescription>
        <LongDescription>方法 {1} 在同步集合上创建迭代器</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法用 Collections.synchronizedXXXX 创建了一个同步集合，但使用迭代器来读取它。 因为迭代器在定义上是线程不安全的，所以这里有观念上的冲突。当使用迭代器时，你需要自己做同步控制。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CC_CYCLOMATIC_COMPLEXITY">
        <ShortDescription>方法过于复杂</ShortDescription>
        <LongDescription>方法 {1} 过于复杂，圈复杂度： {3}</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法的圈复杂度相当高，表现在分支的数量上。它很有可能难于测试，也不容易修改。 考虑将这个方法重构为几个来降低风险。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OCP_OVERLY_CONCRETE_PARAMETER">
        <ShortDescription>方法不需要用具体类作为入参</ShortDescription>
        <LongDescription>{1}: {3}</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在只实现接口或父类的方法的情况下，用具体的类作为入参。 考虑增加接口的抽象性来降低未来变更带来的冲击。</p>

            <p>以下面为例：<br/>
<pre><code>
private void appendToList(ArrayList&lt;String&gt; list) {
    if (list.size() &lt; 100) {
        list.add("Foo");
    }
}
</code></pre>

                参数 list 被定义为<code>ArrayList</code>，一个<code>List</code>接口的具体实现。
                这里没必要特别指定 <code>ArrayList</code>，因为我们没有用到任何<code>ArrayList</code>特定的方法(像<code>ensureCapacity()</code> 或 <code>trimToSize()</code>)。
                相比于使用具体类型，像这样做更好：<br/>
<pre><code>
private void appendToList(List&lt;String&gt; list) {
    ...
</code></pre>
                就算设计变了，比如用<code>LinkedList</code>代替，代码也不需要变动。

            </p>

            <p>IDE倾向于提供工具来帮助生成参数。  比如，在 Eclipse里有重构工具：<a href="http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fref-menu-refactor.htm">Generalize Declared Type</a>帮助找到一个合适级别的</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LII_LIST_INDEXED_ITERATING">
        <ShortDescription>方法基于数值下标遍历 List</ShortDescription>
        <LongDescription>方法 {1} 基于数值下标遍历 List</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法通过 <code>for</code> 循环调用 <code>List.get(i)</code> 遍历 <code>java.util.List</code>。这个下标除了作为循环下标没有其他作用。考虑到不同的 List 实现，更好的做法是使用迭代器代替，它的性能更好，而且这样做也允许后面不经修改切换到不同的实现。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UCC_UNRELATED_COLLECTION_CONTENTS">
        <ShortDescription>方法将一个不相关的类型放入集合或数组</ShortDescription>
        <LongDescription>方法 {1} 将一个不相关的类型放入集合或数组</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将一个不相关的类型放入集合或数组，这要求更小心地读取集合里的数据，也导致了程序更脆弱，容易出问题。如果有必要，创建一个单独的类，放入必要的信息，将该类的实例放入集合或数组里。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DRE_DECLARED_RUNTIME_EXCEPTION">
        <ShortDescription>方法声明抛出 RuntimeException</ShortDescription>
        <LongDescription>方法 {1} 声明抛出 RuntimeException</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法声明抛出 RuntimeException 或其派生异常。
            这会引起误会，因为非捕获异常无法被处理。
            如果发现一个 RuntimeException 经常抛出，以致需要声明，那更好的办法是在代码里避免出现。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CE_CLASS_ENVY">
        <ShortDescription>方法大量使用另一个类的方法</ShortDescription>
        <LongDescription>方法 {1} 大量使用另一个类的方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法大量使用另一个类中的方法，而不是其自身类的方法。一般而言，这意味着通过这个方法完成的功能最有可能属于那个如此广泛使用的类。 考虑将该方法重构到那个类，将需要的数据通过参数传入。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LSC_LITERAL_STRING_COMPARISON">
        <ShortDescription>方法比较字符串时以固定字符串为参数</ShortDescription>
        <LongDescription>方法 {1} 比较字符串时以固定字符串为参数</LongDescription>
        <Details>
            <![CDATA[
            <p>下面这种形式<br/>
<pre><code>String str = ...
str.equals("someOtherString");
//或
str.compareTo("someOtherString");</code></pre>
            </p>
            <p>如果 <code>str</code> 是 <code>null</code>，就会抛出 <code>NullPointerException</code>  . 如果将代码重构为<br/>
<pre><code>String str = ...
"someOtherString".equals(str);
//或
"someOtherString".compareTo(str);</code></pre><br/>
            那么，在固定字符串上调用 <code>equals()</code> 或 <code>compareTo()</code>，将变量作为参数，不会有异常发生。因为两个方法 <code>equals()</code> 和
            <code>compareTo()</code> 都会检查 <code>null</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PCOA_PARTIALLY_CONSTRUCTED_OBJECT_ACCESS">
        <ShortDescription>构造方法调用了可被覆盖(非final)的方法</ShortDescription>
        <LongDescription>构造方法 {1} 调用了可被覆盖(非final)的方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个构造方法调用了可被覆盖(非final)的方法。因为这个方法会被覆盖，一个子类的实现会被调用，而当时子类实际还没有初始化。
            应将所有被构造方法调用的方法都标记为不可覆盖(final)来避免这个问题。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DLC_DUBIOUS_LIST_COLLECTION">
        <ShortDescription>类定义了List字段但当作Set用</ShortDescription>
        <LongDescription>类 {0} 定义了List字段但当作Set用</LongDescription>
        <Details>
            <![CDATA[
            <p>这个类定义了一个<code>java.util.List</code>字段，但使用行为类似Set。因为查找操作在List中一般采用线性遍历，在有大量数据的List上性能很差。如果一个列表已知只有一点点数据(3,4个)，这个问题不大。 如果不是，考虑将这个字段的数据类型换到Set。如果维持有序非常重要，可以考虑使用 LinkedHashSet。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PL_PARALLEL_LISTS">
        <ShortDescription>类定义了两个或多个有关联的列表或数组</ShortDescription>
        <LongDescription>类 {0} 定义了两个或多个有关联的列表或数组</LongDescription>
        <Details>
            <![CDATA[
            <p>这个类有两个或多个列表或数组，它们的内容有关联。也就是说，像这样：<br/>
<pre><code>
List&lt;String&gt; words = new ArrayList&lt;String&gt;();
List&lt;Integer&gt; wordCounts = new ArrayList&lt;String&gt;();
</code></pre>
            在下标0的数据有关联，在下标1的数据也有关联，等等。 </p>
            <p>
            考虑创建一个单独的类持有所有关联信息，将此类的实例放入一个列表或数组中使用。如果只有将各值，使用 Map 来绑定两者，就像：<br/>
<pre><code>
private class WordAndCount{public String word;  public int count}

List&lt;WordAndCount&gt; wordsAndCounts = new ArrayList&lt;WordAndCount&gt;();
//或者，只有两个要素
Map<String,Integer> wordCounts = new HashMap<String,Integer>();
</code></pre>

            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="FP_FINAL_PARAMETERS">
        <ShortDescription>方法可以将一个参数定义为不可变(final)</ShortDescription>
        <LongDescription>方法 {1} 可以将一个参数定义为不可变(final)</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法没有往参数写入。出于文档编写的目的，也出于帮助 JVM 优化该方法调用的目的，应该考虑将参数定义为不可变(final)。</p>

            <p>性能提升是存在疑问的："final 关键字不会出现在类文件用于局部变量和参数，因此不会影响运行时性能。 唯一的用途是阐述程序员的意图，这个变量是不可变的(许多人对此用法存在疑问)，还有就是处理匿名内部类。" - http://stackoverflow.com/a/266981/1447621 </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ACEM_ABSTRACT_CLASS_EMPTY_METHODS">
        <ShortDescription>空方法可以被声明为抽象方法</ShortDescription>
        <LongDescription>空方法 {1} 可以被声明为抽象方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法是空的，或者仅仅是抛出一个异常。由于类被定义为抽象的，更正确的行为是将此方法定义为抽象方法，这样可以强制子类定义的行为。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MAC_MANUAL_ARRAY_COPY">
        <ShortDescription>方法手工拷贝数组</ShortDescription>
        <LongDescription>方法 {1} 手工拷贝数组</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法通过循环手工从一个数组往另一个拷贝数据。
            使用<code>System.arraycopy</code>性能更好，因为该方法直接调用底层系统实现。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="FPL_FLOATING_POINT_LOOPS">
        <ShortDescription>方法使用浮点型作为循环索引</ShortDescription>
        <LongDescription>方法 {1} 使用浮点型作为循环索引</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法使用浮点型变量作为循环索引。由于浮点运算不精确，因此每次执行循环时，舍入误差都会随着时间累积。一般更好的是使用整型来索引，然后在循环体最前面计算一个浮点型的新值。</p>
            <p>举例：
<pre><code>
for (float f = 1.0f; f &lt;= 10.0f; f += 0.1f) {
    System.out.println(f);
}
</code></pre>
            最后一个值不一定是10.0，更有可能的是9.900001或其他。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NCMU_NON_COLLECTION_METHOD_USE">
        <ShortDescription>方法使用了旧的非集合接口方法</ShortDescription>
        <LongDescription>方法 {1} 使用了旧的非集合接口方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法调用了集合类中的非 Collection 接口定义的方法，但在 Collection 接口中存在等价方法。 要使用新方法，可以将这个对象定义为 Collection，更好地去耦合。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CAO_CONFUSING_AUTOBOXED_OVERLOADING">
        <ShortDescription>类定义了可能导致字符串和数值混淆的方法</ShortDescription>
        <LongDescription>类 {0} 定义可能导致字符串和数值混淆的方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个类定义了两个方法，仅仅参数不同：字符(Character)或数值(int/long/float/double)。 因为自动装箱的存在，可能假定参数 'a' 将映射到“字符”版本，但并非如此。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AFBR_ABNORMAL_FINALLY_BLOCK_RETURN">
        <ShortDescription>方法存在从 finally 段不正常退出的情况</ShortDescription>
        <LongDescription>方法 {1} 存在从 finally 段不正常退出的情况</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法从 finally 段返回或抛出异常。这会屏蔽 try 段内的代码逻辑，令正常方法返回被短路。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SMII_STATIC_METHOD_INSTANCE_INVOCATION">
        <ShortDescription>方法通过对象调用静态方法</ShortDescription>
        <LongDescription>方法 {1} 通过对象调用静态方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法通过对象实例调用静态方法。为了便于阅读代码，更好的做法是通过类名来调用而不是通过对象来调用。自编写此代码以来，此方法的静态性质可能已更改，应重新复查。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="STS_SPURIOUS_THREAD_STATES">
        <ShortDescription>方法在线程实例上调用wait, notify 或 notifyAll</ShortDescription>
        <LongDescription>方法 {1} 在线程实例上调用wait, notify 或 notifyAll</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在线程实例上调用 <code>wait</code>, <code>notify</code> 或 <code>notifyAll</code>。
            这么做会混淆内部线程状态行为，导致虚假的唤醒/休眠，因为内部机制也是使用线程实例发出这类通知。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_AUTOBOXING_CTOR">
        <ShortDescription>方法将原生数据包装类传递给相同的原生包装类构造方法</ShortDescription>
        <LongDescription>方法 {1} 将原生数据包装类传递给相同的原生包装类构造方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将原生数据包装类对象作为参数传给同一个类的构造方法。
            因为包装类是不可变的，可以直接使用原始对象，比创建一个好多了。这个代码能运行是因为对自动拆装箱的滥用。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOXING_STRING_CTOR">
        <ShortDescription>方法将需解析的字符串传给原生包装类构造方法</ShortDescription>
        <LongDescription>方法 {1} 将需解析的字符串传给原生包装类构造方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将从 <code>BoxedPrimitive.parseBoxedPrimitive("1")</code> 得到的值作为参数传给同一个类的构造方法。
            这个可以简化为直接传字符串给原生包装类构造方法，或者，更好地，使用静态的 <code>valueOf</code>。</p>
            <p>为替换这种代码：<br/>
<pre><code>
Boolean bo = new Boolean(Boolean.parseBoolean("true"));
Float f = new Float(Float.parseFloat("1.234"));
</code></pre>
            只需要：<br/>
<pre><code>
Boolean bo = new Boolean("true");
Float f = new Float("1.234");
</code></pre>
            或者，内存效率更高的办法：<br/>
<pre><code>
Boolean bo = Boolean.valueOf("true");
Float f = Float.valueOf("1.234");
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_AUTOBOXING_VALUEOF">
        <ShortDescription>方法将原生包装类对象传递给同一个类的 valueOf 方法</ShortDescription>
        <LongDescription>方法 {1} 将原生包装类对象传递给同一个类的 valueOf 方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将原生数据包装类对象作为参数传给同一个类的 <code>valueOf</code> 方法。
            因为包装类是不可变的，可以直接使用原始对象，比创建一个好多了。这个代码能运行是因为对自动拆装箱的滥用。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOXING_PARSE">
        <ShortDescription>方法通过多次拆装箱将字符串转化为原生数据</ShortDescription>
        <LongDescription>方法 {1} 通过多次拆装箱将字符串转化为原生数据</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将字符串传给原生包装类对象的 valueOf 方法，再调 boxedValue() 方法来转化为原生数据。
            如果想要的是原生数据，可以简单地使用 <code>BoxedPrimitive.parseBoxedPrimitive(String)</code> 方法。</p>

            <p>为替换这种代码：<br/>
<pre><code>
public int someMethod(String data) {
long l = Long.valueOf(data).longValue();
float f = Float.valueOf(data).floatValue();
return Integer.valueOf(data); // 这里有一个隐含的 .intValue() 调用
}
</code></pre>
            只需要：<br/>
<pre><code>
public int someMethod(String data) {
    long l = Long.parseLong(data);
    float f = Float.parseFloat(data);
    return Integer.parseInt(data);
}
</code></pre>
            </p>

            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOXING_VALUEOF">
        <ShortDescription>方法通过多次拆装箱将字符串转化为原生包装类</ShortDescription>
        <LongDescription>方法 {1} 通过多次拆装箱将字符串转化为原生包装类</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将字符串传给原生包装类对象的 valueOf 方法，再调 boxedValue() 方法来转化为原生数据。
            如果想要的是原生包装类对象，可以简单地使用 <code>BoxedPrimitive.valueOf(String)</code> 方法。</p>

            <p>为替换这种代码：<br/>
<pre><code>
Boolean bo = Boolean.valueOf(Boolean.parseBoolean("true"));
Float f = Float.valueOf(Float.parseFloat("1.234"));
</code></pre>
            只需要：<br/>
<pre><code>
Boolean bo = Boolean.valueOf("true");
Float f = Float.valueOf("1.234");
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOX_TO_UNBOX">
        <ShortDescription>方法从原生数据创建原生包装类对象只为获得原生数据</ShortDescription>
        <LongDescription>方法 {1} 从原生数据创建原生包装类对象只为获得原生数据</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法从原生数据创建了一个原生包装类对象，只为了调用 <code>primitiveValue()</code> 方法来得到原生数据。
            直接用原生数据代替就行了。</p>
            <p>为替换这种代码：<br/>
<pre><code>
boolean bo = new Boolean(true).booleanValue();
float f = new Float(1.234f).floatValue();
</code></pre>
            只需要：<br/>
<pre><code>
boolean bo = true;
float f = 1.234f;
</code></pre>
            </p>

            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOX_TO_CAST">
        <ShortDescription>方法从原生数据创建原生包装类对象只为强转到另一种原生数据</ShortDescription>
        <LongDescription>方法 {1} 从原生数据创建原生包装类对象只为强转到另一种原生数据</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法从原生数据创建了一个原生包装类对象，只为了调用 <code>primitiveValue()</code> 方法来强转到另一种原生数据。
            更简单的写法是直接强转。</p>
            <p>为替换这种代码：<br/>
<pre><code>
double someDouble = ...
float f = new Double(someDouble).floatValue();

int someInt = ...
byte b = new Integer(someInt).byteValue();
</code></pre>
            只需要：<br/>
<pre><code>
double someDouble = ...
float f = (float) someDouble;

int someInt = ...
byte b = (byte)someInt;
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOOLEAN_CONSTANT_CONVERSION">
        <ShortDescription>方法对布尔量做了多余的装箱</ShortDescription>
        <LongDescription>方法 {1} 对布尔量做了多余的装箱</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将布尔包装类常量赋值给布尔型变量，或者将布尔型常量赋值给布尔包装类变量。
            应使用正确的常量为变量赋值。使用br/>
<pre><code>
boolean b = true;
boolean b = false;
</code></pre>
            或<br/>
<pre><code>
Boolean b = Boolean.TRUE;
Boolean b = Boolean.FALSE;
</code></pre>
            </p>

            <p>请注意，这会在你不期望的时候自动发生。 比如，<br/>
<pre><code>
Map<String, Boolean> statusMap = ...

public Boolean someMethod() {
    statusMap.put("foo", true);  //值 "true" 会被自动装箱
    return false;  //值 "false" 会被自动装箱
}
</code></pre>
            有两中无意义的自动装箱。只需要简单替换为常量就可以提高效率: <br/>

<pre><code>
Map<String, Boolean> statusMap = ...

public Boolean someMethod() {
    statusMap.put("foo", Boolean.TRUE);
    return Boolean.FALSE;
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="USBR_UNNECESSARY_STORE_BEFORE_RETURN">
        <ShortDescription>方法用局部变量存储即将返回的值</ShortDescription>
        <LongDescription>方法 {1} 用局部变量存储即将返回的值</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将返回值存于一个局部变量，然后立即返回这个局部变量。
            这可以简化为直接返回赋给这个局部变量的值。</p>
            <p>
                为替代下面的代码：<br/>

<pre><code>
public float average(int[] arr) {
    float sum = 0;
    for (int i = 0; i &lt; arr.length; i++) {
        sum += arr[i];
    }
    float ave = sum / arr.length;
    return ave;
}
</code></pre>

                只需要简单修改方法返回除法的结果：<br/>

<pre><code>
public float average(int[] arr) {
    float sum = 0;
    for (int i = 0; i &lt; arr.length; i++) {
        sum += arr[i];
    }
    <b>return sum / arr.length;</b> //Change
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="COM_COPIED_OVERRIDDEN_METHOD">
        <ShortDescription>方法通过拷贝父类方法来实现</ShortDescription>
        <LongDescription>方法 {1} 通过拷贝父类方法来实现</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法通过拷贝父类方法来实现，一般来说这说明这个方法可以删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="COM_PARENT_DELEGATED_CALL">
        <ShortDescription>方法委托给父类方法</ShortDescription>
        <LongDescription>方法 {1} 委托给父类方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法通过调用父类相同签名的方法来实现。这个方法可以直接删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ABC_ARRAY_BASED_COLLECTIONS">
        <ShortDescription>方法使用数组作为集合的基础</ShortDescription>
        <LongDescription>方法 {1} 使用数组作为集合的基础</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 将数组作为键传递给Map, 作为集合中的元素, 或作为列表中的项目且会用到 contains 方法. 
            由于数组没有<code>equals</code>方法中，包含里存的实际是引用的地址，这可能是不希望的。
            如果这是TreeMap或TreeSet，请考虑将Comparator传递到构造方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ODN_ORPHANED_DOM_NODE">
        <ShortDescription>方法创建了DOM节点但未将其附加到文档</ShortDescription>
        <LongDescription>方法 {1} 创建了DOM节点但未将其附加到文档</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法创建了DOM节点但未将其附加到文档。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AOM_ABSTRACT_OVERRIDDEN_METHOD">
        <ShortDescription>抽象方法覆盖了具体的实现</ShortDescription>
        <LongDescription>抽象方法 {1} 覆盖了具体的实现</LongDescription>
        <Details>
            <![CDATA[
            <p>这个抽象方法是从具体的方法实现中派生的。高度怀疑父类方法的实现将被丢弃。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CBX_CUSTOM_BUILT_XML">
        <ShortDescription>方法通过临时连接构建XML字符串</ShortDescription>
        <LongDescription>方法 {1} 通过临时连接构建XML字符串</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法通过拼接XML片段、变量为字符串来生成XML。
            这样做会使代码难以阅读、修改并验证。 
            在外部文件中构建XML结构要干净得多：通过Transformer.setParameter进行修改，读入并转换为最终产品。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BSB_BLOATED_SYNCHRONIZED_BLOCK">
        <ShortDescription>方法同步代码块过大</ShortDescription>
        <LongDescription>方法 {1} 同步代码块过大</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法使用同步，但是在同步块开头只读取局部变量，而不读取成员变量或<code>this</code>。
            为了获得更好的性能，请将仅读取局部变量的代码移到同步块外，仅将同步块留给读取成员变量或读取<code>this</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CLI_CONSTANT_LIST_INDEX">
        <ShortDescription>方法使用常量索引读取列表或数组</ShortDescription>
        <LongDescription>方法 {1} 使用常量索引读取列表或数组</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法使用常量索引读取数组或列表。一般，这是使用循环变量的笔误。
            但是，如果特定列表索引表示不同的意义，则可以将列表替换为有意义的类将使代码不那么脆弱。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCR_SLOPPY_CLASS_REFLECTION">
        <ShortDescription>方法使用Class.forName访问静态绑定的类</ShortDescription>
        <LongDescription>方法 {1} accesses statically bound class with Class.forName</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法使用Class.forName读取已经静态绑定入上下文的类的对象。
            使用Class.forName会使代码转换(例如混淆)的反射更加脆弱，并且在此不需要，因为相关的类已经链接到该类。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AWCBR_ARRAY_WRAPPED_CALL_BY_REFERENCE">
        <ShortDescription>方法使用单元素数组模拟按引用调用</ShortDescription>
        <LongDescription>方法 {1} 使用单元素数组模拟按引用调用</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法使用单元素数组来包装要作为参数传递给方法的对象，模拟C++的按引用调用。
            最好定义一个适当的返回类类型来容纳所有从被调用方法中检索到的相关信息。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SG_SLUGGISH_GUI">
        <ShortDescription>方法在GUI线程中执行耗时的操作</ShortDescription>
        <LongDescription>方法 {1} 在GUI线程中执行耗时的操作</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法实现了AWT或Swing侦听器，并执行高耗时操作。 
            在GUI线程中执行这些操作将导致界面显得缓慢且对用户无响应。
            考虑使用单独的线程来完成耗时的工作，以便用户获得更好的体验。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NIR_NEEDLESS_INSTANCE_RETRIEVAL">
        <ShortDescription>方法通过实例加载静态成员</ShortDescription>
        <LongDescription>方法 {1} 通过实例加载静态成员</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法调用方法以加载对象，然后仅使用它来加载该实例的静态成员。
            从类本身加载静态字段会更简单，更高效。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DDC_DOUBLE_DATE_COMPARISON">
        <ShortDescription>方法使用两次日期比较来完成一次即可的工作</ShortDescription>
        <LongDescription>方法 {1} 使用两次日期比较来完成一次即可的工作</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法通过两次比较来比较日期，而不是使用反向比较。
            所以这个模式</p>

<pre><code>
if ((date1.equals( date2 )) || (date1.after( date2 )))
</code></pre>

            可成为：<br/>

<pre><code>
if (date1.compareTo( date2 ) >= 0)
</code></pre><br/>

            又比如<br/>

<pre><code>
if ((date1.equals( date2 )) || (date1.before( date2 )))
</code></pre>

            可成为：<br/>

<pre><code>
if (date1.compareTo( date2 ) <= 0)
</code></pre><br/>

            又比如<br/>

<pre><code>
if ((date1.before( date2 )) || (date1.after( date2 )))
</code></pre>

            可成为：<br/>

<pre><code>
if (!date1.equals( date2 ))
</code></pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SWCO_SUSPICIOUS_WAIT_ON_CONCURRENT_OBJECT">
        <ShortDescription>方法应使用await而不是wait</ShortDescription>
        <LongDescription>方法 {1} 应使用await而不是wait</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在java.util.concurrent包中定义的互斥体上调用wait().
            这些类定义了<code>await</code>，代替<code>wait</code>，并且很可能想调用的就是<code>await</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JVR_JDBC_VENDOR_RELIANCE">
        <ShortDescription>方法使用特定JDBC供应商的类和方法</ShortDescription>
        <LongDescription>方法 {1} 使用特定JDBC供应商的类和方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法使用JDBC供应商特定的类和方法来执行数据库工作。
            这使得该代码特定于该供应商，并且无法在其他数据库上运行。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PMB_POSSIBLE_MEMORY_BLOAT">
        <ShortDescription>静态字段中的潜在内存膨胀</ShortDescription>
        <LongDescription>类 {0} 定义的字段 "{1}" 存在内存膨胀</LongDescription>
        <Details>
            <![CDATA[
            <p>此类定义了<code>Collection</code>，<code>StringBuffer</code>或<code>StringBuilder</code>的静态字段。
            似乎没有任何办法清除或减小其大小。 
            也就是说，定义了一个集合，并具有类似的方法调用{<code>add()</code>，<code>append()</code>，<code>offer()</code>，<code>put()</code>，...} <br/>
            没有方法调用类似<br/>的删除方法{<code>clear()</code>，<code>delete()</code>，<code>pop()</code>，<code>remove()</code>，...} <br/>
            这意味着相关集合的大小只能增加，即可能导致内存膨胀。</p>

            <p>
            如果此集合是List, set 或 其他静态的东西 (例如一个List&lt;String&gt; 存储月份名称), 考虑将所有元素添加到静态初始化器中，该初始化器只能调用一次：<br/>
<pre><code>
private static List&lt;String&gt; monthNames = new ArrayList&lt;String&gt;();
static {
    monthNames.add("January");
    monthNames.add("February");
    monthNames.add("March");
    ...
}
</code></pre>
            </p>

            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="PMB_INSTANCE_BASED_THREAD_LOCAL">
        <ShortDescription>字段是实例内的ThreadLocal变量</ShortDescription>
        <LongDescription>字段 {1} 是实例内的ThreadLocal变量</LongDescription>
        <Details>
            <![CDATA[
            <p>该ThreadLocal字段被定义为基于实例(不是静态的)。
            就垃圾回收器而言，由于所有ThreadLocal变量都描述了永久的可达性根，因此这些变量将永远不会被回收(只要Thread存活)。
            由于此ThreadLocal是实例化的，因此即使在拥有实例被回收后，您也可能会创建许多不可回收的变量。
            几乎可以肯定，应该使用基于静态的ThreadLocal变量。</p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="PMB_LOCAL_BASED_JAXB_CONTEXT">
        <ShortDescription>按需创建本地JAXBContext</ShortDescription>
        <LongDescription>方法 {1} 按需创建本地JAXBContext</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法创建一个JAXBContext并将其存储在本地变量中。
            这个表示此JAXBContext每次按需创建，这将导致内存膨胀问题。
            最好将此实例创建为静态字段，或使用ConcurrentHashMap等将其保留。 
            参考： https://javaee.github.io/jaxb-v2/doc/user-guide/ch03.html#other-miscellaneous-topics-performance-and-thread-safety </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LSYC_LOCAL_SYNCHRONIZED_COLLECTION">
        <ShortDescription>方法创建用于局部变量的同步集合</ShortDescription>
        <LongDescription>方法 {1} 创建用于局部变量的同步集合</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法创建一个同步集合并存储在局部变量中。 
            由于局部变量按照定义是线程安全的，因此使用同步集合是可疑的。</p>
            <p>
            <table>
                <tr><th>如果您正在使用</th><th>考虑使用</th></tr>
                <tr><td>java.util.Vector</td><td>java.util.ArrayList</td></tr>
                <tr><td>java.util.Hashtable</td><td>java.util.HashMap</td></tr>
                <tr><td>java.lang.StringBuffer</td><td>java.lang.StringBuilder</td></tr>
            </table>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="FCBL_FIELD_COULD_BE_LOCAL">
        <ShortDescription>类定义仅当作局部变量用的字段</ShortDescription>
        <LongDescription>类 {0} 定义仅当作局部变量用的字段</LongDescription>
        <Details>
            <![CDATA[
            此类定义了仅当作局部变量用的字段，特别是不可继承类中的私有字段或受保护字段，这些字段在每种方法中首先通过存储与加载进行访问。
            该字段可以用一个或多个局部变量代替。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NOS_NON_OWNED_SYNCHRONIZATION">
        <ShortDescription>类使用不是自己拥有的变量进行同步</ShortDescription>
        <LongDescription>类 {0} 使用不是自己拥有的变量进行同步</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法使用一个同步块，在该块上要同步的对象不属于当前实例。 
            这意味着其他实例可能出于自己的目的使用同一对象进行同步，从而导致同步混乱。
            仅在此类的私有字段上进行同步总是更干净，更安全。
            请注意，"this"不属于当前实例，属于将其该对象分配给类内字段的任何人。
            在"this"上同步也不是一个好主意。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NRTL_NON_RECYCLEABLE_TAG_LIB">
        <ShortDescription>标签库不可回收</ShortDescription>
        <LongDescription>标签库 {0} 不可回收</LongDescription>
        <Details>
            <![CDATA[
            <p>这个标签库实现了一个属性，其关联的存储用字段又在标签库另一个地方被修改。
            为了使标记库可回收，仅允许容器通过使用taglib的setXXX方法来更改此属性。
            以编程方式修改值，容器在重用标签库时将无法正确初始化属性。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_NULL_LAYOUT">
        <ShortDescription>GUI使用绝对布局</ShortDescription>
        <LongDescription>GUI {0} 使用绝对布局</LongDescription>
        <Details>
            <![CDATA[
            <p>此类将null传递给<code>setLayout</code>，代表指定要使用绝对坐标对组件进行布局。
            这使得难以更改字体大小等，因为控件将不会重新定位。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_NO_SETLABELFOR">
        <ShortDescription>JLabel 没有指定其标签</ShortDescription>
        <LongDescription>方法 {1} 中的 JLabel 没有指定其标签</LongDescription>
        <Details>
            <![CDATA[
            <p>此类使用不指定要标记哪些字段的JLabel。
            这阻碍了屏幕阅读器向用户提供适当的反馈。
            使用 JLabel.setLabelFor 方法可以完成此操作。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_NO_SETSIZE">
        <ShortDescription>窗口手动设置大小，不使用pack</ShortDescription>
        <LongDescription>窗口 {0} 手动设置大小，不使用pack</LongDescription>
        <Details>
            <![CDATA[
            <p>此类创建一个窗口，并使用setSize调整窗口大小。
            为了处理字体大小更改，最好使用pack方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_NON_ACCESSIBLE_JCOMPONENT">
        <ShortDescription>类 扩展JComponent但未实现Accessible接口</ShortDescription>
        <LongDescription>类 {0} 扩展JComponent但未实现Accessible接口</LongDescription>
        <Details>
            <![CDATA[
            <p>此类扩展了JComponent GUI控件，但未实现Accessibility接口。
            对于有阅读/视觉困难的人来说，这使得屏幕阅读器等无法处理此控件。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_SET_COMP_COLOR">
        <ShortDescription>方法显式设置组件的颜色</ShortDescription>
        <LongDescription>方法 {1} 显式设置组件的颜色</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法设置组件的显式前景色或背景色，可能会给使用此应用程序的视力障碍人士带来困难。
            应该允许从操作系统设置颜色。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_NON_TRANSLATABLE_STRING">
        <ShortDescription>方法将常量字符串传递给组件的标题/标签</ShortDescription>
        <LongDescription>方法 {1} 将常量字符串传递给组件的标题/标签</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法创建一个组件并将字符串传递给该组件的标题或标签。
            由于此字符串将显示给用户，因此应该通过使用资源包将其国际化。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_APPENDED_STRING">
        <ShortDescription>方法将拼接字符串传递给组件的标题/标签</ShortDescription>
        <LongDescription>方法 {1} 将拼接字符串传递给组件的标题/标签</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法创建一个组件，并通过将多个字符串拼接在一起作为字符串传递给组件的标题/标签。
            由于外语对短语的顺序可能有所不同，因此翻译会很困难。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UEC_USE_ENUM_COLLECTIONS">
        <ShortDescription>类使用枚举类作为普通Set或Map的键</ShortDescription>
        <LongDescription>类 {0} 使用枚举类作为普通Set或Map的键</LongDescription>
        <Details>
            <![CDATA[
            <p>此类使用普通的set或map集合，并使用enum类作为键类型。
            使用JDK 1.5 EnumSet或EnumMap类的性能更高。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SIL_SQL_IN_LOOP">
        <ShortDescription>方法在循环内执行SQL查询</ShortDescription>
        <LongDescription>方法 {1} 在循环内执行SQL查询</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在循环内执行SQL查询。
            这种模式通常效率低下，因为在循环中查询数量可能迅速增加。
            这样可能更有效：遍历输入并收集所有查询所需的关键数据， 
            然后使用in子句或类似的结构发出一个查询，
            然后遍历此结果集，
            并一次获取所有数据。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NMCS_NEEDLESS_MEMBER_COLLECTION_SYNCHRONIZATION">
        <ShortDescription>类在成员集合上定义不需要的同步</ShortDescription>
        <LongDescription>类 {0} 在成员集合上定义不需要的同步</LongDescription>
        <Details>
            <![CDATA[
            <p>此类将私有集合成员定义为需要同步。
            但是，似乎仅在静态初始化程序或构造函数中修改了此集合。
            这两个区域保证线程安全，因此不需要将此集合定义为需要同步，这是潜在的性能瓶颈。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ITC_INHERITANCE_TYPE_CHECKING">
        <ShortDescription>方法在多种类型上使用instanceof来路由逻辑</ShortDescription>
        <LongDescription>方法 {1} 在多种类型上使用instanceof来路由逻辑</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在一系列if/else语句中使用instanceof运算符根据类型调用不同代码块。
            如果这些类型通过继承相关联，则只需要基类中定义一个方法，然后在分支中使用这些类覆盖的方法就更干净了。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SACM_STATIC_ARRAY_CREATED_IN_METHOD">
        <ShortDescription>方法创建数组作为常量使用</ShortDescription>
        <LongDescription>方法 {1} 创建数组作为常量使用</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 初始化创建了一个数组，作为常量使用。
            每次调用此方法，该数组将被重新创建。 
            最好将数组定义为类的静态字段。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS">
        <ShortDescription>方法似乎在同一对象上冗余地调用了相同的方法</ShortDescription>
        <LongDescription>方法 {1} 似乎在同一对象上冗余地调用了相同的方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在相同实例上使用相同的参数连续两次调用相同的方法，而没有对实例对象进行任何修改。
            如果此方法未对对象进行更改(看起来没有更改)，则进行两次调用将很浪费。
            通过将结果分配给一个临时变量，然后第二次使用该变量，可以减少这些方法调用。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTA_USE_TO_ARRAY">
        <ShortDescription>方法从集合手动创建数组</ShortDescription>
        <LongDescription>方法 {1} 从集合手动创建数组</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法手动遍历集合，将每个元素取出并存储在数组中以从集合构建数组。
            使用内置的Collection方法toArray更加轻松明了。
            给定类型T的集合“mycollection”，请使用<code>mycollection.toArray(new T[mycollection.size()]); </code></p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LEST_LOST_EXCEPTION_STACK_TRACE">
        <ShortDescription>方法从catch块抛出替代异常却没有带上历史信息</ShortDescription>
        <LongDescription>方法 {1} 从catch块抛出替代异常却没有带上历史信息</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法捕获异常，并引发其他异常，而没有合并原始异常。
            这样做隐藏了异常的原始来源，使调试和解决这些问题变得困难。
            最好使用这个带有原始异常的新异常的构造函数，以便将此详细信息传递给用户。
            如果此异常没有使用初始cause参数的构造函数，请使用initCause方法对其进行初始化。</p>
            <p>
<pre><code>
catch (IOException e) {
    throw new MySpecialException("Failed to open configuration", e);
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UCPM_USE_CHARACTER_PARAMETERIZED_METHOD">
        <ShortDescription>方法将长度为1的常量字符串传递给字符重写方法</ShortDescription>
        <LongDescription>方法 {1} 将长度为1的常量字符串传递给字符重写方法</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法存在以<char>char</code>为参数的类似方法，将长度为1的常量<code>String</code>作为参数传递给方法。
            处理一个字符而不是<code>String</code>更简单，更方便。</p>

            <p>
            不像这样调用：<br/>
<pre><code>
String myString = ...
if (myString.indexOf("e") != -1) {
    int i = myString.lastIndexOf("e");
    System.out.println(myString + ":" + i);  // Java编译器将在此处隐式使用StringBuilder [builder.append(":")]
    ...
    return myString.replace("m","z");
}
</code></pre>
            用等效的<code>char</code>替换单个字母<code>String</code>，如下所示：<br/>

<pre><code>
String myString = ...
if (myString.indexOf('e') != -1) {
    int i = myString.lastIndexOf('e');
    System.out.println(myString + ':' + i);  // Java编译器将在此处隐式使用StringBuilder [builder.append(':')]
    ...
    return myString.replace('m','z');
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="TR_TAIL_RECURSION">
        <ShortDescription>方法使用尾递归</ShortDescription>
        <LongDescription>方法 {1} 使用尾递归</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法递归地将自身作为本方法的最后一条语句(尾递归)。
            此方法可以轻松地重构为一个简单的循环，从而使其性能更高，并减少堆栈大小要求。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="URV_UNRELATED_RETURN_VALUES">
        <ShortDescription>方法返回不同类型的不相关对象</ShortDescription>
        <LongDescription>方法 {1} 返回不同类型的不相关对象</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法返回两种或两种以上不相关的对象类型(仅通过java.lang.Object相关)。
            这将对必须调用它的代码造成混乱。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="URV_CHANGE_RETURN_TYPE">
        <ShortDescription>方法返回比声明更具体的对象类型</ShortDescription>
        <LongDescription>方法 {1} 返回比声明更具体的对象类型</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法定义为返回java.lang.Object。
            但是，从此方法返回的返回类型可以由更特定的类或接口定义。
            由于此方法不是从超类或接口派生的，因此更改此方法的返回类型会更加清楚。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="URV_INHERITED_METHOD_WITH_RELATED_TYPES">
        <ShortDescription>继承的方法返回比声明更具体的对象类型</ShortDescription>
        <LongDescription>继承的方法 {1} 返回比声明更具体的对象类型</LongDescription>
        <Details>
            <![CDATA[
            <p>定义此继承方法以返回java.lang.Object。
            但是，从此方法返回的返回类型可以由更特定的类或接口定义。
            如果可能的话，请考虑在此方法的继承层次结构中更改返回类型，否则此方法的调用者将很难处理返回类型。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PIS_POSSIBLE_INCOMPLETE_SERIALIZATION">
        <ShortDescription>类未序列化超类字段</ShortDescription>
        <LongDescription>类 {0} 未序列化超类字段</LongDescription>
        <Details>
            <![CDATA[
            <p>这个类实现Serializable，但从没有实现的类派生。
            超类具有未序列化的字段，因为此类不能承担使用Serializable的writeObject方法或Externalizable的writeExternal方法将这些字段写出的责任。
            因此，从流中读取此类时，超类字段将仅初始化为其默认构造函数中指定的值。
            如果可能，请更改超类以实现Serializable，或在子类中实现Serializable或Externalizable方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCRV_SUSPICIOUS_COMPARATOR_RETURN_VALUES">
        <ShortDescription>比较方法似乎没有返回有序值</ShortDescription>
        <LongDescription>比较方法 {1} 似乎没有返回有序值</LongDescription>
        <Details>
            <![CDATA[
            <p>此compareTo或compare方法返回表示小于，等于和大于的常量值。
            但是，它不会返回每种类型，或者会无条件地返回非零值。
            考虑到比较器是可传递的，这似乎是不正确的。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_NEGATIVE_BITSET_ITEM">
        <ShortDescription>方法将一个负数作为参数传递给不支持的BitSet</ShortDescription>
        <LongDescription>方法 {1} 将一个负数作为参数传递给不支持的BitSet</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将恒定的负值作为参数传递给java.util.BitSet。 
            BitSet类不支持负值，因此此方法调用将无法按预期进行。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_INTERN_ON_CONSTANT">
        <ShortDescription>方法在字符串常量上调用intern</ShortDescription>
        <LongDescription>方法 {1} 在字符串常量上调用intern</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在常量字符串上调用<code>intern</code>。
            由于常量字符串已经被插入，因此此调用是多余的。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_NO_CHAR_SB_CTOR">
        <ShortDescription>方法似乎将字符传递给StringBuffer(int)或StringBuilder(int)</ShortDescription>
        <LongDescription>方法 {1} 似乎将字符传递给StringBuffer(int)或StringBuilder(int)</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法使用构造函数构造一个StringBuffer或StringBuilder，该构造函数接受一个整数参数，但似乎传入了一个字符。
            作者可能会假定该字符会附加到StringBuffer / Builder上，但是该字符的整数值将用作缓冲区的初始大小。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_MATH_CONSTANT">
        <ShortDescription>方法使用非标准数学常数</ShortDescription>
        <LongDescription>方法 {1} 使用非标准数学常数</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法定义自己的<em>PI</em>或<em>e</em>版本，其值没有在常量Math.PI或Math.E中定义的精确。 
            请改用这些常量。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_STUTTERED_ASSIGNMENT">
        <ShortDescription>方法连续两次向本地分配值</ShortDescription>
        <LongDescription>方法 {1} 连续两次向本地分配值</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法以连续赋值方式连续两次分配一个值，例如<code>a = a = 5;</code> 
            这很可能是剪切和粘贴错误，可以删除重复的作业。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_ISNAN">
        <ShortDescription>方法错误地将浮点数与NaN进行比较</ShortDescription>
        <LongDescription>方法 {1} 将一个 {3} 与 {4}.NaN 比较</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将double或float与常数<code>Double.NaN</code>或<code>Float.NaN</code>进行比较。
            如果变量是基本类型，则应使用<code>Double.isNaN(d)</code>或<code>Float.isNaN(f)</code>。
            如果使用包装类型，请使用<code>d.isNaN()</code>或<code>f.isNaN()</code>。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_BIGDECIMAL_STRING_CTOR">
        <ShortDescription>方法将双精度值传递给BigDecimal构造函数</ShortDescription>
        <LongDescription>方法 {1} 将双精度值传递给BigDecimal构造函数</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法调用接受双精度数的BigDecimal构造函数，并传递一个固定双精度常数值。
            由于使用BigDecimal是为了获得比double更好的精度，但通过传递double值，您只会得到double级别的精度。
            要利用BigDecimal空间，请将数字作为字符串传递。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_STRINGBUFFER_WITH_EMPTY_STRING">
        <ShortDescription>方法将空字符串传递给StringBuilder构造函数</ShortDescription>
        <LongDescription>方法 {1} 将空字符串传递给StringBuilder构造函数</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法调用StringBuffer或StringBuilder构造函数，并传入一个恒定的空字符串(“”)。
            这与调用默认构造函数相同，但是使代码更难工作。
            考虑改用默认大小。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_EQUALS_ON_ENUM">
        <ShortDescription>方法在枚举实例上调用equals</ShortDescription>
        <LongDescription>方法 {1}在枚举实例上调用equals</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在枚举实例上调用equals(Object)方法。
            由于枚举值是单例，因此可以使用==安全比较两个枚举值。
            实际上，Enum.equals的实现就是这样做。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_INVALID_BOOLEAN_NULL_CHECK">
        <ShortDescription>方法对布尔使用无效的C++样式null检查</ShortDescription>
        <LongDescription>方法 {1} 对布尔使用无效的C++样式null检查</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法尝试仅通过引用变量名来检查是否为空，就像在C++中那样。
            通常，这将被视为编译错误，除了所涉及的变量是布尔值之外，它会自动拆箱为布尔值。
<pre><code>
if (b && b.booleanValue())
</code></pre>
            应该<br/>
<pre><code>
if (Boolean.TRUE.equals(b))
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_CHARAT">
        <ShortDescription>方法提取字符数组只是为了执行与charAt方法等效的操作</ShortDescription>
        <LongDescription>方法 {1} 提取字符数组只是为了执行与charAt方法等效的操作</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在String上调用toCharArray方法以获取字符数组，仅按索引检索这些字符之一。
            仅使用charAt方法的性能更高。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USELESS_TERNARY">
        <ShortDescription>方法使用三元运算符将布尔值转换为true或false</ShortDescription>
        <LongDescription>方法 {1} 使用三元运算符将布尔值转换为true或false</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法测试布尔值，并使用三元运算符返回true或false。
            三元运算符完全没有必要，只需使用原始的布尔值即可。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_SUSPECT_STRING_TEST">
        <ShortDescription>方法可能在分支逻辑中混合了普通字符串和空字符串</ShortDescription>
        <LongDescription>方法 {1} 将null和正常字符串视为相同，应将null和空字符串视为相同</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法测试一个字符串，并将空值与实际字符串分组，而将空字符串保留为另一种情况。
			也就是说，FindBugs已检测到如下结构：<br/>
<pre><code>
String a = null, b = "", c = "someString";

String testStr = ...;  //a，b或c之一
if ({{FLAWED_TEST_LOGIC}}) {
    // 字符串a和c属于该分支...这不是典型的。
} else {
    // 字符串b落入该分支。
}
</code></pre>

            这可能是完全正确的，但是通常，逻辑上应以相同的方式处理空值和空字符串，因此此测试可能有缺陷。</p>
            <p>找到的模式是以下之一：
            <ul>
                <li><code>if ((s == null) || (s.length() &gt; 0))</code> --- 你的意图是
                <code>((s == null) || (s.length() == 0))</code>?</li>
                <li><code>if ((s == null) || (s.length() != 0))</code> -- 你的意图是
                <code>((s == null) || (s.length() == 0))</code>?</li>
                <li><code>if ((s != null) && (s.length() == 0))</code> -- 你的意图是
                <code>((s != null) && (s.length() &gt; 0))</code> 或
                <code>((s == null) || (s.length() == 0))</code>?</li>
            </ul>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_STRINGBUILDER_LENGTH">
        <ShortDescription>方法将StringBuffer或Builder转换为String只是为了获取其长度</ShortDescription>
        <LongDescription>方法 {1} 将StringBuffer或Builder转换为String只是为了获取其长度</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在StringBuffer或StringBuilder上调用toString方法，仅在结果字符串上调用length()。 
			仅在StringBuffer或StringBuilder本身上直接调用length方法会更快，更省内存。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_INVALID_CALENDAR_COMPARE">
        <ShortDescription>方法将非日历对象传递给Calendar.before或Calendar.after</ShortDescription>
        <LongDescription>方法 {1} 将非日历对象传递给Calendar.before或Calendar.after</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将非日历对象传递给java.util.Calendar.after或java.util.Calendar.before方法。
            即使这些方法将Object作为参数类型，也仅支持Calendar类型的对象，否则返回false。</p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="SPP_USE_ZERO_WITH_COMPARATOR">
        <ShortDescription>方法将compareTo方法的结果与非零值进行比较</ShortDescription>
        <LongDescription>方法 {1} 将compareTo方法的结果与非零值进行比较</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在对象上调用compareTo方法，然后将结果值与非零值进行比较。
			实际上，只能将compareTo方法指定为返回0，正数或负数，因此您应该比较== 0，> 0或<0，而不要与== 1这样的特定值进行比较。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUI_USE_CONTAINSKEY">
        <ShortDescription>方法 仅通过keySet()来调用contains，请改用containsKey</ShortDescription>
        <LongDescription>方法 {1} 仅通过keySet()来调用contains，请改用containsKey</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法调用mySet.keySet().contains("foo")，而mySet.containsKey("foo")更简单。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_ISEMPTY">
        <ShortDescription>方法通过检查集合的大小是否为零判断是否为空，而没有使用isEmpty()</ShortDescription>
        <LongDescription>方法 {1} 通过检查集合的大小是否为零判断是否为空，而没有使用isEmpty()</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在集合上调用size()方法，并将结果与​​零进行比较，以查看集合是否为空。
			为了使代码更清晰，最好只使用col.isEmpty()或！col.isEmpty()。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_GETPROPERTY">
        <ShortDescription>方法调用getProperties只是为了获得一个属性，应改用getProperty</ShortDescription>
        <LongDescription>方法 {1} 调用getProperties只是为了获得一个属性，应改用getProperty</LongDescription>
        <Details>
            <![CDATA[
            <p>
                该方法使用
                <code>String prop = System.getProperties().getProperty("foo");</code>
                而不是简单地使用
                <code>String prop = System.getProperty("foo");</code>
			</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_SERIALVER_SHOULD_BE_PRIVATE">
        <ShortDescription>类将serialVersionUID定义为非私有</ShortDescription>
        <LongDescription>类 {0} 将serialVersionUID定义为非私有</LongDescription>
        <Details>
            <![CDATA[
            <p>此类定义一个静态字段'serialVersionUID'来定义此类的序列化版本。
			该字段被标记为非私有。由于serialVersionUID仅控制当前类，并且不影响任何派生类，因此将其定义为非私有会造成混淆。
			建议您将此变量更改为私有。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USELESS_CASING">
        <ShortDescription>方法强制执行大小写后比较没有大小写的字符串</ShortDescription>
        <LongDescription>方法 {1} 强制执行大小写后比较没有大小写的字符串</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在字符串上调用toUpperCase或toLowerCase之后用compareToIgnoreCase或equalsIgnoreCase比较两个字符串.
			当您进行比较而不必担心大小写时，toUpperCase或toLowerCase调用是没有意义的，可以删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_NON_ARRAY_PARM">
        <ShortDescription>方法将非数组对象传递给需要数组的参数</ShortDescription>
        <LongDescription>方法 {1} 将非数组对象传递给需要数组的参数</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法期望将数组作为其参数之一传递，但不幸的是将参数定义为Object。
			此方法的调用放如果不传递数组，在运行时将引发异常。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_EMPTY_CASING">
        <ShortDescription>方法将空字符串传递给equalsIgnoreCase或compareToIgnoreCase</ShortDescription>
        <LongDescription>方法 {1} 将空字符串传递给equalsIgnoreCase或compareToIgnoreCase</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将空字符串“”传递给equalsIgnoreCase或compareToIgnoreCase。
			由于空字符串不区分大小写，因此使用equals更简单。
			进行length()== 0测试甚至更简单。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_TEMPORARY_TRIM">
        <ShortDescription>方法临时修剪字符串</ShortDescription>
        <LongDescription>方法 {1} 临时修剪字符串</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在String上调用trim()，而不将新字符串分配给另一个变量。
			然后，它在此修剪后的字符串上调用length()或equals()。
			如果修整字符串对于确定其长度或相等性很重要，则在实际使用时可能应修整它。
            首先修剪字符串，将修剪后的值存储在变量中，然后继续测试并使用修剪后的字符串，这样会更有意义。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_STRINGBUILDER_IS_MUTABLE">
        <ShortDescription>方法因为它是可变的，所以不需要为其本身分配StringBuilder</ShortDescription>
        <LongDescription>方法 {1} 因为它是可变的，所以不需要为其本身分配StringBuilder</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法调用StringBuilder.append并将结果分配给相同的StringBuilder，例如：</p>
            <code>sb = sb.append("foo")</code>
            <p>StringBuilder是可变的，因此这不是必需的。
            StringBuffer也是如此。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_GET0">
        <ShortDescription>方法 在List上使用iterator().next()获取第一项</ShortDescription>
        <LongDescription>方法 {1} 在List上使用iterator().next()获取第一项</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在List上调用myList.iterator().next()以获取第一项。
			仅使用myList.get(0)会更高效。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_DOUBLE_APPENDED_LITERALS">
        <ShortDescription>方法将两个固定字符串拼接到StringBuilder</ShortDescription>
        <LongDescription>方法 {1} 将两个固定字符串拼接到StringBuilder</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法将两个文字字符串背对背附加到<code>StringBuilder</code>。
            现代编译器将优化以下内容：<br/>
<pre><code>
public static final string CONST_VAL = "there";
...
String str = "Hello" + " "+ CONST_VAL + " " +"world!";
</code></pre>
            至: <br/>
<pre><code>
public static final string CONST_VAL = "there";
...
String str = "Hello there world!";
</code></pre>
            这意味着连接是在编译时完成的，而不是在运行时完成的，因此<b>不需要</b>进行操作：<br/>
<pre><code>
public static final string CONST_VAL = "there";
...
StringBuilder sb = new StringBuilder("Hello").append(" ").append(CONST_VAL).append(" ").append("world!");
String str = sb.toString();
</code></pre>
            这更难阅读，并且会导致更复杂的字节码。
            </p>

            <p>
            只需在常量上加上“+”符号，就不要在它们之间加上<code>StringBuilder.append()</code>。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_NULL_BEFORE_INSTANCEOF">
        <ShortDescription>方法在调用instanceof之前检查引用是否为null</ShortDescription>
        <LongDescription>方法 {1} 在调用instanceof之前检查引用是否为null</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在查看引用是否是某个类的实例之前，检查该引用是否为null。
            由于instanceof对于空引用将返回false，因此不需要空检查。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_NON_USEFUL_TOSTRING">
        <ShortDescription>方法在尚未重写toString()的类的实例上调用toString()</ShortDescription>
        <LongDescription>方法 {1} 在尚未重写toString()的类的实例上调用toString()</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在尚未覆盖toString()方法的对象上调用<code> toString</code>，因此依赖于java.lang.Object中的实现。
			该字符串只是该对象的类和位置的原始显示，不提供有关使用信息的信息。
			您应该在此类中实现toString。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_TOSTRING_ON_STRING">
        <ShortDescription>方法在字符串上调用toString()</ShortDescription>
        <LongDescription>方法 {1} 在字符串上调用toString()</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在字符串上调用<code>toString</code>。如果需要字符串，只需使用对象本身。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_CONVERSION_OF_STRING_LITERAL">
        <ShortDescription>方法转换一个固定字符串</ShortDescription>
        <LongDescription>方法 {1} 在固定字符串上调用 {3}</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在<code>String</code>常量上调用诸如<code>toLowerCase</code>或<code>trim</code>的转换方法。
			您应该自己进行转换并使用转换后的文字。</p>

            <p>
            例如，为代替：<br/>
<pre><code>
return "ThisIsAConstantString".toLowerCase().trim();
</code></pre>
            只需要 <br/>
<pre><code>
return "thisisaconstantstring";
</code></pre>
			以便更短，更容易阅读代码。
			而且当需要进行特定于语言环境的转换时(在<code>toUpperCase()</code>和<code>toLowerCase()</code>的情况下，可能会发生异常)。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_EQUALS_ON_STRING_BUILDER">
        <ShortDescription>方法在StringBuilder或StringBuffer上调用equals(Object o)</ShortDescription>
        <LongDescription>方法 {1} 在StringBuilder或StringBuffer上调用equals(Object o)</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法在StringBuilder或StringBuffer上调用equals。
			令人惊讶的是，这些类没有覆盖Object中的equals方法，因此equals仅定义为==(或相同的引用)。
			这很可能不是您想要的。
			如果要检查字符串是否具有相同的字符，则需要在这些对象上调用toString()并将它们与字符串进行比较。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_STATIC_FORMAT_STRING">
        <ShortDescription>方法 calls String.format on a static (non parameterized) format string</ShortDescription>
        <LongDescription>方法 {1} calls String.format on a static (non parameterized) format string</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls String.format, passing a static string that has no replacement markers (starting with %)
            as the format string. Thus no replacement will happen, and the format method is superfluous. If parameters were intended,
            add the appropriate format markers as needed; otherwise, just remove the call to String.format and use the static
            string as is.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_WRONG_COMMONS_TO_STRING_OBJECT">
        <ShortDescription>方法 does not pass an object to commons-lang's ToStringBuilder</ShortDescription>
        <LongDescription>方法 {1} does not pass an object to commons-lang's ToStringBuilder</LongDescription>
        <Details>
            <![CDATA[
            This method uses commons-lang, or commons-lang3's ToStringBuilder to attempt to output a representation of an object.
            However, no object was passed, just the style specifier, and so the output will be of the ToStringStyle object itself.
            Don't forget to include the object you wish to output as the first parameter, such as
            <pre>
            ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);
            </pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUI_NULL_CHECK_ON_MAP_SUBSET_ACCESSOR">
        <ShortDescription>方法 checks whether the keySet(), entrySet() or values() collection of a Map is null</ShortDescription>
        <LongDescription>方法 {1} checks whether the keySet(), entrySet() or values() collection of a Map is null</LongDescription>
        <Details>
            <![CDATA[
            This method checks to see if the return value from a keySet(), entrySet() or values() method call on a Map is null.
            For any valid functioning Map these collections will always be non-null, and so the call is superfluous. Maybe you intended
            to check whether those sets were empty instead.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BAS_BLOATED_ASSIGNMENT_SCOPE">
        <ShortDescription>方法 assigns a variable in a larger scope than is needed</ShortDescription>
        <LongDescription>方法 {1} assigns a variable in a larger scope than is needed</LongDescription>
        <Details>
            <![CDATA[
            <p><em>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</em></p>
            <p>这个方法 assigns a value to a variable in an outer scope compared to where the variable is actually used.
            Assuming this evaluation does not have side effects, the assignment can be moved into the inner scope (if block)
            so that its execution time isn't taken up if the <code>if</code> guard is false. Care should be
            taken, however, that the right hand side of the assignment does not contain side
            effects that are required to happen, and that changes are not made further down that
            will affect the execution of the assignment when done later on.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCII_SPOILED_CHILD_INTERFACE_IMPLEMENTOR">
        <ShortDescription>类 implements interface by relying on unknowing superclass methods</ShortDescription>
        <LongDescription>类 {0} implements interface by relying on unknowing superclass methods</LongDescription>
        <Details>
            <![CDATA[
            <p>This class declares that it implements an interface, but does so by relying on methods supplied
            by superclasses, even though those superclasses know nothing about the interface in question. If you wish
            to have the child not implement all the methods of the interface, it would probably be better to declare
            the superclass as implementing the interface, and if that class does not provide all the methods, then declare
            that superclass abstract.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DWI_DELETING_WHILE_ITERATING">
        <ShortDescription>方法 deletes collection element while iterating</ShortDescription>
        <LongDescription>方法 {1} deletes collection element while iterating</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 removes items from a collection using the remove method of the collection, while
            at the same time iterating across the collection. Doing this will invalidate the iterator, and further
            use of it will cause ConcurrentModificationException to be thrown. To avoid this, the remove
            method of the iterator should be used.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DWI_MODIFYING_WHILE_ITERATING">
        <ShortDescription>方法 modifies collection element while iterating</ShortDescription>
        <LongDescription>方法 {1} modifies collection element while iterating</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 modifies the contents of a collection using the collection API methods, while
            at the same time iterating across the collection. Doing this will invalidate the iterator, and further
            use of it will cause ConcurrentModificationException to be thrown.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="USS_USE_STRING_SPLIT">
        <ShortDescription>方法 builds String array using String Tokenizing</ShortDescription>
        <LongDescription>方法 {1} builds String array using String Tokenizing</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses a StringTokenizer to split up a String and then walks through the
            separated elements and builds an array from these enumerated values. It is simpler
            and easier to use the String.split method.</p>
            <p>PLEASE NOTE: String.split will return an array of 1 element when passed the
            empty string, as opposed to using StringTokenizer which returns false on the first
            hasMoreElements/hasMoreTokens call. So you may need to use:</p>
<pre><code>
if (s.length() &gt; 0) <br/>
    return s.split(";");<br/>
return new String[0];<br/>
</code></pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SJVU_SUSPICIOUS_JDK_VERSION_USE">
        <ShortDescription>方法 uses rt.jar class or method that does not exist</ShortDescription>
        <LongDescription>方法 {1} uses rt.jar class or method that does not exist for the version the class is compiled for</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls a method that does not exist, on a class that does not exist in the JDK that
            this class has been compiled for. This can happen if you compile the class specifying the -source and
            -target options, and use a version that is before the version of the compiler's JDK.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UAA_USE_ADD_ALL">
        <ShortDescription>方法 uses simple loop to copy contents of one collection to another</ShortDescription>
        <LongDescription>方法 {1} uses simple loop to copy contents of one collection to another</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses a simple <code>for</code> loop to copy the contents of a set, list, map key/value, array or other collection
            to another collection. It is simpler and more straightforward to just call the addAll method of the destination collection
            passing in the source collection. In the case that the source is an array, you can use the Arrays.asList method to wrap the array
            into a collection.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MRC_METHOD_RETURNS_CONSTANT">
        <ShortDescription>私有方法或静态方法 only returns one constant value</ShortDescription>
        <LongDescription>私有方法或静态方法 {1} only returns one constant value</LongDescription>
        <Details>
            <![CDATA[
            <p>This private or static method only returns one constant value. As this method is private or static,
            its behavior can't be overridden, and thus the return of a constant value seems dubious.
            Either the method should be changed to return no value, or perhaps another return value
            was expected to be returned in another code path in this method.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NCS_NEEDLESS_CUSTOM_SERIALIZATION">
        <ShortDescription>方法 needlessly implements what is default streaming behavior</ShortDescription>
        <LongDescription>方法 {1} needlessly implements what is default streaming behavior</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 implements the Serializable interface by performing the same operations that
            would be done if this method did not exist. Since this is the case, this method is not needed.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MOM_MISLEADING_OVERLOAD_MODEL">
        <ShortDescription>类 'overloads' a method with both instance and static versions</ShortDescription>
        <LongDescription>类 {0} 'overloads' a method with both instance and static versions</LongDescription>
        <Details>
            <![CDATA[
            <p>This class 'overloads' the same method with both instance and static versions. As the use
            of these two models is different, it will be confusing to the users of these methods.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS">
        <ShortDescription>不受限制的方法 converts checked exception to unchecked</ShortDescription>
        <LongDescription>不受限制的方法 {1} converts checked exception to unchecked</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 is not constrained by an interface or superclass, but converts a caught checked exception
            to an unchecked exception and throws it. It would be more appropriate just to throw the checked exception,
            adding the exception to the throws clause of the method.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="EXS_EXCEPTION_SOFTENING_HAS_CHECKED">
        <ShortDescription>受限制方法 converts checked exception to unchecked instead of another allowable checked exception</ShortDescription>
        <LongDescription>受限制方法 {1} converts checked exception to unchecked instead of another allowable checked exception</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法's exception signature is constrained by an interface of superclass not to throw a
            checked exception that was caught. Therefore this exception was converted to an unchecked exception and
            thrown. It would probably be better to throw the closest checked exception allowed, and to annotate
            the new exception with the original exception using the initial cause field.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="EXS_EXCEPTION_SOFTENING_NO_CHECKED">
        <ShortDescription>受限制方法 converts checked exception to unchecked</ShortDescription>
        <LongDescription>受限制方法 {1} converts checked exception to unchecked</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法's exception signature is constrained by an interface or superclass not to throw
            any checked exceptions. Therefore a caught checked exception was converted to an unchecked exception
            and thrown. However, it appears that the class in question is owned by the same author as the constraining
            interface or superclass. Consider changing the signature of this method to include the checked exception.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="EXS_EXCEPTION_SOFTENING_RETURN_FALSE">
        <ShortDescription>方法 converts an exception into a boolean 'error code' value</ShortDescription>
        <LongDescription>方法 {1} converts an exception into a boolean 'error code' value</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 catches an exception and returns a boolean that represents whether an exception occurred or not.
            This throws away the value of exception handling and lets code ignore the resultant 'error code' return value.
            You should just throw the exception to the caller instead.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CFS_CONFUSING_FUNCTION_SEMANTICS">
        <ShortDescription>方法 returns modified parameter</ShortDescription>
        <LongDescription>方法 {1} returns modified parameter</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 appears to modify a parameter, and then return this parameter as the
            method's return value. This will be confusing to callers of this method, as it won't be
            apparent that the 'original' passed-in parameter will be changed as well. If the purpose
            of this method is to change the parameter, it would be more clear to change the method to
            have a void return value. If a return type is required due to interface or superclass contract,
            perhaps a clone of the parameter should be made.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_ACTUAL_CONSTANT">
        <ShortDescription>JUnit test method passes constant to second (actual) assertion parameter</ShortDescription>
        <LongDescription>JUnit test method {1} passes constant to second (actual) assertion parameter</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls <code>assertXXX</code> passing a constant value as the second of the two values. The assert
            methods assume that the expected value is the first parameter, and so it appears that the order
            of values has been swapped here.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_INEXACT_DOUBLE">
        <ShortDescription>JUnit test method asserts that two doubles are exactly equal</ShortDescription>
        <LongDescription>JUnit test method {1} asserts that two doubles are exactly equal</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls <code>assertXXX</code> with two doubles or Doubles. Due to the imprecision of doubles, you
            should be using the assert method that takes a range parameter that gives a range of error.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_BOOLEAN_ASSERT">
        <ShortDescription>JUnit test method asserts that a value is equal to true or false</ShortDescription>
        <LongDescription>JUnit test method {1} asserts that a value is equal to true or false</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 asserts that a value is equal to true or false. It is simpler to just
            use assertTrue or assertFalse instead.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_IMPOSSIBLE_NULL">
        <ShortDescription>JUnit test method asserts that an autoboxed value is not null</ShortDescription>
        <LongDescription>JUnit test method {1} asserts that an autoboxed value is not null</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 asserts that a primitive value that was autoboxed into a boxed primitive was not
            null. This will never happen, as primitives are never null, and thus the autoboxed value isn't
            either.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_ASSERT_USED">
        <ShortDescription>JUnit test method uses Java asserts rather than a JUnit assertion</ShortDescription>
        <LongDescription>JUnit test method {1} uses Java asserts rather than a JUnit assertion</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses a Java assert to assure that a certain state is in effect. As this is
            a JUnit test it makes more sense to either check this condition with a JUnit assert, or allow
            a following exception to occur.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_USE_ASSERT_NULL">
        <ShortDescription>JUnit test method passes null Assert.assertEquals</ShortDescription>
        <LongDescription>JUnit test method {1} passes null to Assert.assertEquals</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 compares an object's equality to null. It is better to use the Assert.assertNull
            method so that the JUnit failure method is more descriptive of the intended test.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_USE_ASSERT_NOT_NULL">
        <ShortDescription>JUnit test method passes null Assert.assertNotEquals</ShortDescription>
        <LongDescription>JUnit test method {1} passes null to Assert.assertNotEquals</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 compares an object's inequality to null. It is better to use the Assert.assertNotNull
            method so that the JUnit failure method is more descriptive of the intended test.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_USE_ASSERT_EQUALS">
        <ShortDescription>JUnit test method passes boolean expression to Assert.assertFalse / Assert.assertTrue</ShortDescription>
        <LongDescription>JUnit test method {1} passes boolean expression to Assert.assertFalse / Assert.assertTrue</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 evaluates a boolean expression and passes that to Assert.assertFalse / Assert.assertTrue.
            It is better to pass the two values that are being equated to the Assert.assertEquals method so that the
            JUnit failure method is more descriptive of the intended test.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_USE_ASSERT_NOT_EQUALS">
        <ShortDescription>JUnit test method passes boolean expression to Assert.assertFalse / Assert.assertTrue</ShortDescription>
        <LongDescription>JUnit test method {1} passes boolean expression to Assert.assertFalse / Assert.assertTrue</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 evaluates a boolean expression and passes that to Assert.assertFalse / Assert.assertTrue.
            It is better to pass the two values that are being equated to the Assert.assertNotEquals method so that the
            JUnit failure method is more descriptive of the intended test.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_NO_ASSERT">
        <ShortDescription>JUnit test method appears to have no assertions</ShortDescription>
        <LongDescription>JUnit test method {1} appears to have no assertions</LongDescription>
        <Details>
            <![CDATA[
            <p>This JUnit test method has no assertions. While a unit test could still be valid if it relies on whether
            or not an exception is thrown, it is usually a sign of a weak test if there are no assertions. Consider calling
            <code>fail</code> after an exception was expected. It is also possible that assertions occur in a called method
            that is not seen by this detector, but this makes the logic of this test more difficult to reason about.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_USING_DEPRECATED">
        <ShortDescription>JUnit 4 test using deprecated junit.framework.* classes</ShortDescription>
        <LongDescription>JUnit 4 test {1} using deprecated junit.framework.* classes</LongDescription>
        <Details>
            <![CDATA[
            <p>This JUnit 4 test is still using classes from the junit.framework.* package. You should switch them
            over to the corresponding org.junit.* set of classes, instead.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_ACTUAL_CONSTANT">
        <ShortDescription>TestNG test method passes constant to first (actual) assertion parameter</ShortDescription>
        <LongDescription>TestNG test method {1} passes constant to first (actual) assertion parameter</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls <code>assertXXX</code> passing a constant value as the first of the two values. The assert
            method assumes that the expected value is the second parameter, and so it appears that the order
            of values has been swapped here.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_INEXACT_DOUBLE">
        <ShortDescription>TestNG test method asserts that two doubles are exactly equal</ShortDescription>
        <LongDescription>TestNG test method {1} asserts that two doubles are exactly equal</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls <code>assertXXX</code> with two doubles or Doubles. Due to the imprecision of doubles, you
            should be using the assert method that takes a range parameter that gives a range of error.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_BOOLEAN_ASSERT">
        <ShortDescription>TestNG test method asserts that a value is true or false</ShortDescription>
        <LongDescription>TestNG test method {1} asserts that a value is true or false</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 asserts that a value is equal to true or false. It is simpler to just
            use assertTrue, or assertFalse, instead.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_IMPOSSIBLE_NULL">
        <ShortDescription>TestNG test method asserts that an autoboxed value is not null</ShortDescription>
        <LongDescription>TestNG test method {1} asserts that an autoboxed value is not null</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 asserts that a primitive value that was autoboxed into a boxed primitive was not
            null. This will never happen, as primitives are never null, and thus the autoboxed value isn't
            either.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_ASSERT_USED">
            <ShortDescription>TestNG test method uses Java asserts rather than a TestNG assertion</ShortDescription>
            <LongDescription>TestNG test method {1} uses Java asserts rather than a TestNG assertion</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses a Java assert to assure that a certain state is in effect. As this is
            a TestNG test it makes more sense to either check this condition with a TestNG assert, or allow
            a following exception to occur.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_USE_ASSERT_NULL">
        <ShortDescription>TestNG test method passes null Assert.assertEquals</ShortDescription>
        <LongDescription>TestNG test method {1} passes null to Assert.assertEquals</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 compares an object's equality to null. It is better to use the Assert.assertNull
            method so that the TestNG failure method is more descriptive of the intended test.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_USE_ASSERT_NOT_NULL">
        <ShortDescription>TestNG test method passes null Assert.assertNotEquals</ShortDescription>
        <LongDescription>TestNG test method {1} passes null to Assert.assertNotEquals</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 compares an object's inequality to null. It is better to use the Assert.assertNotNull
            method so that the TestNG failure method is more descriptive of the intended test.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_USE_ASSERT_EQUALS">
        <ShortDescription>TestNG test method passes boolean expression to Assert.assertFalse / Assert.assertTrue</ShortDescription>
        <LongDescription>TestNG test method {1} passes boolean expression to Assert.assertFalse / Assert.assertTrue</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 evaluates a boolean expression and passes that to Assert.assertFalse / Assert.assertTrue.
            It is better to pass the two values that are being equated to the Assert.assertEquals method so that the
            TestNG failure method is more meaningful of the intended test.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_USE_ASSERT_NOT_EQUALS">
        <ShortDescription>TestNG test method passes boolean expression to Assert.assertFalse / Assert.assertTrue</ShortDescription>
        <LongDescription>TestNG test method {1} passes boolean expression to Assert.assertFalse / Assert.assertTrue</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 evaluates a boolean expression and passes that to Assert.assertFalse / Assert.assertTrue.
            It is better to pass the two values that are being equated to the Assert.assertNotEquals method so that the
            TestNG failure method is more meaningful of the intended test.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_NO_ASSERT">
        <ShortDescription>TestNG test method appears to have no assertions</ShortDescription>
        <LongDescription>TestNG test method {1} appears to have no assertions</LongDescription>
        <Details>
            <![CDATA[
            <p>This TestNG test method has no assertions. While a unit test could still be valid if it relies on whether
            or not an exception is thrown, it is usually a sign of a weak test if there are no assertions. Consider calling
            <code>fail</code> after an exception was expected. It is also possible that assertions occur in a called method
            that is not seen by this detector, but this makes the logic of this test more difficult to reason about.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCA_SUSPICIOUS_CLONE_ALGORITHM">
        <ShortDescription>克隆方法 stores a new value to member field of source object</ShortDescription>
        <LongDescription>克隆方法 {1} stores a new value to member field of source object</LongDescription>
        <Details>
            <![CDATA[
            <p>The clone method stores a value to a member field of the source object. Normally, all
            changes are made to the cloned object, and given that cloning is almost always considered
            a read-only operation, this seems incorrect.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WEM_WEAK_EXCEPTION_MESSAGING">
        <ShortDescription>方法 throws exception with static message string</ShortDescription>
        <LongDescription>方法 {1} throws exception with static message string</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 creates and throws an exception using a static string as the exceptions message.
            Without any specific context of this particular exception invocation, such as the values of parameters,
            key member variables, or local variables, it may be difficult to infer how this exception occurred. Consider
            adding context to the exception message.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WEM_OBSCURING_EXCEPTION">
        <ShortDescription>方法 throws a java.lang.Exception that wraps a more useful exception</ShortDescription>
        <LongDescription>方法 {1} throws a java.lang.Exception that wraps a more useful exception</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 catches an exception and generates a new exception of type java.lang.Exception,
            passing the original exception as the new Exception's cause.  If the original Exception was actually
            a java.lang.Error, this is dubious as you should not be handling errors. If the original exception
            is a more specific exception, there is no reason to wrap it in a java.lang.Exception;
            this just obfuscates the type of error that is occurring.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCSS_SUSPICIOUS_CLUSTERED_SESSION_SUPPORT">
        <ShortDescription>方法 modifies an http session attribute without calling setAttribute</ShortDescription>
        <LongDescription>方法 {1} modifies an http session attribute without calling setAttribute</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 fetches a complex object from an HttpSession object, modifies this object, but does
            not call setAttribute, to inform the application server that this attribute has been changed. This will
            cause this attribute not to be updated in other servers in a clustered environment, as only changes marked
            by a call to setAttribute are replicated.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_LOGGER_LOST_EXCEPTION_STACK_TRACE">
        <ShortDescription>方法 incorrectly passes exception as first argument to logger method</ShortDescription>
        <LongDescription>方法 {1} incorrectly passes exception as first argument to logger method</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 passes an exception as the first argument to a logger method. The stack
            trace is potentially lost due to the logger emitting the exception using toString(). It
            is better to construct a log message with sufficient context and pass the exception as
            the second argument to capture the stack trace.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_SUSPECT_LOG_CLASS">
        <ShortDescription>方法 specifies an unrelated class when allocating a Logger</ShortDescription>
        <LongDescription>方法 {1} specifies an unrelated class when allocating a Logger.  Saw "{3}", expected "{4}".</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 creates a Logger by passing in a specification for a class that is unrelated
            to the class in which the logger is going to be used. This is likely caused by copy/paste code.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_SUSPECT_LOG_PARAMETER">
        <ShortDescription>构造方法 declares a Logger parameter</ShortDescription>
        <LongDescription>构造方法 {1} declares a Logger parameter</LongDescription>
        <Details>
            <![CDATA[
            <p>This constructor declares a parameter that is a Logger. As loggers are meant to be
            created statically per class, it doesn't make sense that you would pass a Logger from one
            class to another. Declare the Logger static in each class instead.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_STUTTERED_MESSAGE">
        <ShortDescription>方法 stutters exception message in logger</ShortDescription>
        <LongDescription>方法 {1} stutters exception message in logger</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses a logger method that takes an exception, and passes the result of
            the exception's getMessage() method as the log message.
            Since you are already passing in the exception, that message is already present in the
            logs, and by passing it in as the message, you are just stuttering information.
            It would be more helpful to provide a handwritten message that describes the error in
            this method, possibly including the values of key variables.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_INVALID_FORMATTING_ANCHOR">
        <ShortDescription>方法 attempts to log using numbered formatting anchors</ShortDescription>
        <LongDescription>方法 {1} attempts to log using numbered formatting anchors</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 attempts to use an SLF4J or Log4j2 logger to log a parameterized expression using formatting anchors.
            However, SLF4J and Log4j2 use simple non numbered anchors such as {}, rather than anchors with digits in them as the
            code uses. Thus no parameter replacement will occur.</p>
            <p>This pattern is invalid:
            <code>LOGGER.error("{0} is broken", theThing);</code>
            Use instead
            <code>LOGGER.error("{} is broken", theThing);</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

        <BugPattern type="LO_INVALID_STRING_FORMAT_NOTATION">
        <ShortDescription>方法 attempts to log using String.format notation</ShortDescription>
        <LongDescription>方法 {1} attempts to log using String.format notation</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 attempts to use an SLF4J or Log4j2 logger to log a parameterized expression using String.format notation.
            However, SLF4J and Log4j2 uses simple non numbered anchors such as {}, rather than anchors with percent signs in them as the
            code uses. Thus no parameter replacement will occur.</p>
            <p>This pattern is invalid:
            <code>LOGGER.error("%s is broken", theThing);</code>
            Use instead
            <code>LOGGER.error("{} is broken", theThing);</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_INCORRECT_NUMBER_OF_ANCHOR_PARAMETERS">
        <ShortDescription>方法 passes an incorrect number of parameters to an SLF4J or Log4j2 logging statement</ShortDescription>
        <LongDescription>方法 {1} passes an incorrect number of parameters to an SLF4J or Log4j2 logging statement</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 passes the wrong number of parameters to an SLF4J or Log4j2 logging method (error, warn, info, debug) based on the number of anchors {} in the
            format string. An additional exception argument is allowed if found.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_EXCEPTION_WITH_LOGGER_PARMS">
        <ShortDescription>方法 creates exception with logger parameter markers in message</ShortDescription>
        <LongDescription>方法 {1} creates exception with logger parameter markers in message</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 passes a standard exception as a logger parameter, and expects this exception to be substituted in
            an SLF4J or Log4j style parameter marker '{}'. This marker will not be translated as SLF4J and Log4j2 don't process the Exception
            class for markers.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_APPENDED_STRING_IN_FORMAT_STRING">
        <ShortDescription>方法 passes a concatenated string to SLF4J's or Log4j2's format string</ShortDescription>
        <LongDescription>方法 {1} passes a concatenated string to SLF4J's or Log4j2's format string</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses an SLF4J or Log4j2 logger to log a string, where the first (format) string is created using concatenation.
            You should use {} markers to inject dynamic content into the string, so that String building is delayed until the
            actual log string is needed. If the log level is high enough that this log statement isn't used, then the appends
            will never be executed.</p>
            ]]>
        </Details>
    </BugPattern>


    <BugPattern type="LO_EMBEDDED_SIMPLE_STRING_FORMAT_IN_FORMAT_STRING">
        <ShortDescription>方法 passes a simple String.format result to an SLF4J's or Log4j2's format string</ShortDescription>
        <LongDescription>方法 {1} passes a simple String.format result to an SLF4J's or Log4j2's format string</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses an SLF4J or Log4J2 logger to log a string which was produced through a call to String.format, where
            the format string passed was a constant string containing only simple format markers that could be directly handled
            by SLF4J or Log4J. Rather than doing
            <pre>
                logger.error(String.format("This %s is an error", s));
            <pre>
            do
            <pre>
                logger.error("This {} is an error", s);
            </pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_TOSTRING_PARAMETER">
        <ShortDescription>方法 explicitly calls toString() on a logger parameter</ShortDescription>
        <LongDescription>方法 {1} explicitly calls toString() on a logger parameter</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses parameterized logging to avoid the cost of string concatenation in the case that
            the log level does not meet the needed level. However, one or more of the parameters passed to the logging
            method uses .toString() to present a String representation for the parameter. This is unneeded as the logger
            will do this for you, and because it is explicitly done, will always be called even if the log statement is
            not actually written. Also, by dropping the '.toString()' you may avoid unnecessary NPEs.
            Just pass the variable as a parameter instead.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_NON_PRIVATE_STATIC_LOGGER">
        <ShortDescription>类 defines non private logger using a static class context</ShortDescription>
        <LongDescription>类 {0} defines a non private logger using a static class context</LongDescription>
        <Details>
            <![CDATA[
                <p>This class defines a static logger as non private. It does so by passing the name of a
                class such as
                <code><pre>public static final Logger LOG = LoggerFactory.getLogger(Foo.class);</pre></code>
                Since this class is public it may be used in other classes, but doing so will provide the incorrect
                class reference as the class is hard coded.
                </p>
                <p>
                It is recommend to define static loggers as private, and just redefine a new logger in any class
                that you need to have logging done.
                <p>
                <p>If you wish to have a base class define the logger, and have derived classes use that logger, you can
                potentially use instance based logging, such as
                <code><pre>protected final Logger LOG = LoggerFactory.getLogger(getClass());</pre></code>
                However this has the downside of being an instance based logger, and creating a logger object in each instance
                of the class where it is used.
                </p>
                ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IICU_INCORRECT_INTERNAL_CLASS_USE">
        <ShortDescription>类 relies on internal API classes</ShortDescription>
        <LongDescription>类 {0} relies on internal API classes</LongDescription>
        <Details>
            <![CDATA[
            <p>This class makes use of internal API classes. As these
            classes are not documented, nor externally released as part of the API, they are subject
            to change or removal. You should not be using these classes.</p>
            Packages that shouldn't be used are:
            <ul>
                <li>sun.xxx</li>
                <li>org.apache.xerces.xxx</li>
                <li>org.apache.xalan.xxx</li>
            </ul>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DSOC_DUBIOUS_SET_OF_COLLECTIONS">
        <ShortDescription>方法 uses a set of collections</ShortDescription>
        <LongDescription>方法 {1} uses a set of collections</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 creates a set that contains other collections, or a Map whose keySet is
            another collection. As collections tend to calculate hashCode, equals, and compareTo by
            iterating the contents of the collection, this can perform poorly.</p>
            <p>In addition, when a set is used, you typically are using it to do 'contains', or 'find'
            type functionality, which seems dubious when done on a collection.</p>
            <p>Finally, as a collection is often modified, problems will occur if the collection is
            contained in a set, because the hashCode, equals or compareTo values will change while the
            collection is in the set.</p>
            <p>If you wish to maintain a collection of collections, it is probably better to use a List
            as the outer collection.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BED_BOGUS_EXCEPTION_DECLARATION">
        <ShortDescription>非派生方法 declares throwing an exception that isn't thrown</ShortDescription>
        <LongDescription>非派生方法 {1} declares throwing an exception that isn't thrown</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 declares that it throws a checked exception that it does not throw. As this method is
            either a constructor, static method or private method, there is no reason for this method to declare
            the exception in its throws clause, and just causes calling methods to unnecessarily handle an exception
            that will never be thrown. The exception in question should be removed from the throws clause.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BED_HIERARCHICAL_EXCEPTION_DECLARATION">
        <ShortDescription>方法 declares throwing two or more exceptions related by inheritance</ShortDescription>
        <LongDescription>方法 {1} declares throwing two or more exceptions related by inheritance</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 declares that it throws an exception that is the child of another exception that is
            also declared to be thrown. Given that the parent exception is declared, there is no need for the child
            exception to also be declared; it just adds confusion.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UNNC_UNNECESSARY_NEW_NULL_CHECK">
        <ShortDescription>方法 checks the result of a new allocation</ShortDescription>
        <LongDescription>方法 {1} checks the result of a new allocation</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 allocates an object with <code>new</code>, and then checks that the object is null
            or non null. As the new operator is guaranteed to either succeed or throw an exception,
            this null check is unnecessary and can be removed.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DTEP_DEPRECATED_TYPESAFE_ENUM_PATTERN">
        <ShortDescription>类 appears to implement the old style type safe enum pattern</ShortDescription>
        <LongDescription>类 {0} appears to implement the old style type safe enum pattern</LongDescription>
        <Details>
            <![CDATA[
            <p>This class appears to implement the old-style typesafe enum pattern that was used in place of
            real enums. Since this class is compiled with Java 1.5 or better, it would be simpler and more
            easy to understand if it was just switched over to an <code>enum</code>.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="TBP_TRISTATE_BOOLEAN_PATTERN">
        <ShortDescription>方法 returns null for Boolean type</ShortDescription>
        <LongDescription>方法 {1} returns null for Boolean type</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 declares that it returns a Boolean value. However, the code
            can return a null value. As this is now three values that can be returned -
            Boolean.TRUE, Boolean.FALSE, null - you have changed what a Boolean means.
            It would be clearer to just create a new Enum that has the three values
            you want, and define that the method returns that type.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SUA_SUSPICIOUS_UNINITIALIZED_ARRAY">
        <ShortDescription>方法 returns an array that appears not to be initialized</ShortDescription>
        <LongDescription>方法 {1} returns an array that appears not to be initialized</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 returns an array that was allocated but apparently not initialized. It is
            possible that the caller of this method will do the work of initializing this array, but
            that is not a common pattern, and it is assumed that this array has just been forgotten to
            be initialized.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ITU_INAPPROPRIATE_TOSTRING_USE">
        <ShortDescription>方法 performs algorithmic operations on the result of a toString() call</ShortDescription>
        <LongDescription>方法 {1} performs algorithmic operations on the result of a toString() call</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls algorithmic operations on a String that was returned from a toString() method.
            As these methods are for debugging/logging purposes, it shouldn't be the basis of core logic in your code.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IKNC_INCONSISTENT_HTTP_ATTRIBUTE_CASING">
        <ShortDescription>方法 uses the same HttpSession attribute name but with different casing</ShortDescription>
        <LongDescription>方法 {1} uses the same HttpSession attribute name but with different casing</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 sets or gets an HttpSession attribute with a parameter name that was used in other locations
            but with a different casing. As HttpSession attribute are case-sensitive, this will be very confusing.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IKNC_INCONSISTENT_HTTP_PARAM_CASING">
        <ShortDescription>方法 uses the same HttpRequest parameter name but with different casing</ShortDescription>
        <LongDescription>方法 {1} uses the same HttpRequest parameter name but with different casing</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 fetches an HttpServletRequest parameter with a parameter name that was used in other locations
            but with a different casing. As HttpServletRequest parameters are case-sensitive, this will be very confusing.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OC_OVERZEALOUS_CASTING">
        <ShortDescription>方法 manually casts the right hand side of an assignment more specifically than needed</ShortDescription>
        <LongDescription>方法 {1} manually casts the right hand side of an assignment more specifically than needed</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 casts the right hand side of an expression to a class that is more specific than the
            variable on the left hand side of the assignment. The cast only has to be as specific as the variable
            that is on the left. Using a more specific type on the right hand side just increases cohesion.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PDP_POORLY_DEFINED_PARAMETER">
        <ShortDescription>方法 defines parameters more abstractly than needed to function properly</ShortDescription>
        <LongDescription>方法 {1} defines parameters more abstractly than needed to function properly</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 defines parameters at a more abstract level than is actually needed to function correctly,
            as the code casts these parameters to more concrete types. Since this method is not derivable, you should
            just define the parameters with the type that is needed.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NSE_NON_SYMMETRIC_EQUALS">
        <ShortDescription>Equals 方法 compares this object against other types in a non symmetric way</ShortDescription>
        <LongDescription>Equals 方法 {1} compares this object against other types in a non symmetric way</LongDescription>
        <Details>
            <![CDATA[
            <p>This class implements an equals method that compares this object against another type of object.
            This is almost always a bad thing to do, but if it is to be done, you must make sure that the basic
            symmetry rule of equivalence is maintained, that being if a equals b, then b equals a. It does not
            appear that the class that is being compared to this class knows about this class, and doesn't compare itself
            to this.</p>
            <p>
            Here's an example of a BAD equals method, do NOT do this:
<pre><code>
class Person {
    public boolean equals(Object o) {
        if (o instanceof Person) {
            return name.equals(((Person) o).name);
        } else if (o instanceof String) {
            return name.equals(o);
        }
        return false;
    }
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CVAA_CONTRAVARIANT_ARRAY_ASSIGNMENT">
        <ShortDescription>方法 performs a contravariant array assignment</ShortDescription>
        <LongDescription>方法 {1} performs a contravariant array assignment</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 contains a contravariant array assignment. Since arrays are mutable data structures, their use
            must be restricted to covariant or invariant usage.</p>

<pre><code>
class A {}
class B extends A {}

B[] b = new B[2];
A[] a = b;
</code></pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CVAA_CONTRAVARIANT_ELEMENT_ASSIGNMENT">
        <ShortDescription>方法 performs a contravariant array element assignment</ShortDescription>
        <LongDescription>方法 {1} performs a contravariant array element assignment</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 contains a contravariant array element assignment. Since arrays are mutable
            data structures, their use must be restricted to covariant or invariant usage.</p>

<pre><code>
class A {}
class B extends A {}

B[] b = new B[2];
A[] a = b;
a[0] = new A(); // results in ArrayStoreException (Runtime)
</code></pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NFF_NON_FUNCTIONAL_FIELD">
        <ShortDescription>可序列化类 defines a final transient field</ShortDescription>
        <LongDescription>可序列化类 {0} defines a final transient field</LongDescription>
        <Details>
            <![CDATA[
            <p>This serializable class defines a field as both transient and final. As transient fields
            are not serialized across the stream, it is required that some piece of code reinitialize that field
            when it is deserialized. But since constructors aren't called when deserializing, the field is not initialized.
            And since the field is final, no other method can initialize it either.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SNG_SUSPICIOUS_NULL_FIELD_GUARD">
        <ShortDescription>方法 tests a field for not null as guard and reassigns it</ShortDescription>
        <LongDescription>方法 {1} tests a field for not null as guard and reassigns it</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 tests a field to make sure it's not null before executing a conditional block of
            code. However, in the conditional block it reassigns the field. It is likely that the guard
            should have been a check to see if the field is null, not that the field was not null.</p>
            <p>example:
<pre><code>
if (name != null) {
    name = person.getName();
}
</code></pre>
            It is possible this is correct, but it seems likely the guard was meant to be <code>if (name == null)</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SNG_SUSPICIOUS_NULL_LOCAL_GUARD">
        <ShortDescription>方法 tests a local variable for not null as guard and reassigns it</ShortDescription>
        <LongDescription>方法 {1} tests a local variable for not null as guard and reassigns it</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 tests a local variable to make sure it's not null before executing a conditional block of
            code. However, in the conditional block it reassigns the local variable. It is likely that the guard
            should have been a check to see if the local variable is null, not that the local variable was not null.</p>
            <p>example:
<pre><code>
if (name != null) {
    name = person.getName();
}
</code></pre>
            It is possible this is correct, but it seems likely the guard was meant to be <code>if (name == null)</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_RUNTIME_EXIT_OR_HALT">
        <ShortDescription>方法 calls Runtime.exit() or Runtime.halt()</ShortDescription>
        <LongDescription>方法 {1} calls {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>Calling <code>Runtime.exit()</code> or <code>Runtime.halt()</code> shuts down the entire Java virtual machine.
            This should only be done in very rare circumstances. Such calls make it hard or impossible for your code to be
            invoked by other code. Consider throwing a RuntimeException instead.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_RUNFINALIZATION">
        <ShortDescription>方法 triggers finalization</ShortDescription>
        <LongDescription>方法 {1} triggers finalization when calling {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>Manually triggering finalization can result in serious performance problems and may be masking resource cleanup bugs.
            Only the garbage collector, not application code, should be concerned with finalization.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_BIGDECIMAL_EQUALS">
        <ShortDescription>方法 calls BigDecimal.equals()</ShortDescription>
        <LongDescription>方法 {1} calls BigDecimal.equals(), which is normally a mistake</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls <code>equals()</code> to compare two <code>java.math.BigDecimal</code> numbers.
            This is normally a mistake, as two <code>BigDecimal</code> objects are only equal if they are
            equal in both value and scale, so that <i>2.0</i> is not equal to <i>2.00</i>.
            To compare <code>BigDecimal</code> objects for mathematical equality, use <code>compareTo()</code> instead.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_INETADDRESS_GETLOCALHOST">
        <ShortDescription>方法 calls InetAddress.getLocalHost()</ShortDescription>
        <LongDescription>方法 {1} calls InetAddress.getLocalHost(), which may be a security risk</LongDescription>
        <Details>
            <![CDATA[
            <p>Do not call <code>InetAddress.getLocalHost()</code> on multihomed servers. On a multihomed server,
            <code>InetAddress.getLocalHost()</code> simply returns the IP address associated with the server's internal hostname.
            This could be any of the network interfaces, which could expose the machine to security risks. Server applications
            that need to listen on sockets should add configurable properties to define which network interfaces the server should bind.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_PROMISCUOUS_SERVERSOCKET">
        <ShortDescription>方法 creates promiscuous ServerSocket object</ShortDescription>
        <LongDescription>方法 {1} creates a promiscuous ServerSocket, which may be a security risk</LongDescription>
        <Details>
            <![CDATA[
            <p>Do not use the <code>ServerSocket</code> constructor or <code>ServerSocketFactory.createServerSocket()</code> factory methods that
            accept connections on any network interface. By default, an application that listens on a socket will listen for connection attempts
            on any network interface, which can be a security risk. Only the long form of the <code>ServerSocket</code> constructor or
            <code>ServerSocketFactory.createServerSocket()</code> factory methods take a specific local address to define which network interface
            the socket should bind.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_RANDOM_SEED">
        <ShortDescription>方法 creates insecure Random object</ShortDescription>
        <LongDescription>方法 {1} creates an insecure Random object, which may be a security risk</LongDescription>
        <Details>
            <![CDATA[
            <p><code>Random()</code> constructor without a seed is insecure because it defaults to an easily guessable seed:
            <code>System.currentTimeMillis()</code>. Initialize a seed like <code>new Random(SecureRandom.getInstance("SHA1PRNG").nextLong())</code>
            or replace <code>Random()</code> with <code>SecureRandom.getInstance("SHA1PRNG")</code> instead.
            "SHA1PRNG" is the random algorithm supported on all platforms.
        </p>

            <p>
                As of Java 6, you may use <code>new Random(new SecureRandom().nextLong())</code> or <code>new SecureRandom()</code> instead.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_SECURERANDOM">
        <ShortDescription>方法 calls deprecated SecureRandom method</ShortDescription>
        <LongDescription>方法 {1} calls deprecated SecureRandom method {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>In JDK 1.5 or less, the <code>SecureRandom()</code> constructors and <code>SecureRandom.getSeed()</code> method are recommended against using.
            Call <code>SecureRandom.getInstance()</code> and <code>SecureRandom.getInstance().generateSeed()</code> instead.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_THREAD_PRIORITIES">
        <ShortDescription>方法 uses suspicious thread priorities</ShortDescription>
        <LongDescription>方法 {1} uses suspicious thread priorities by calling method {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>Getting or setting thread priorities is not portable and could cause or mask race conditions.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_THREAD_YIELD">
        <ShortDescription>方法 attempts to manually schedule threads</ShortDescription>
        <LongDescription>方法 {1} attempts to manually schedule threads by calling method {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>Manual thread scheduling with <code>Thread.sleep()</code> or <code>Thread.yield()</code> has no guaranteed semantics and is often used to mask race conditions.
            These methods exist for supporting early processors when java was first released, and are not advised for modern processors. The operating system will take care
            of yielding threads for you.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_WAIT_WITHOUT_TIMEOUT">
        <ShortDescription>方法 sleeps without timeout</ShortDescription>
        <LongDescription>方法 {1} sleeps without timeout when calling {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>Calling one of the following methods without timeout could block forever. Consider using a timeout to detect deadlocks or performance problems.
            Methods:
            <ul>
            <li>Thread.join()</li>
            <li>Object.wait()</li>
            <li>Condition.await()</li>
            <li>Lock.lock()</li>
            <li>Lock.lockInterruptibly()</li>
            <li>ReentrantLock.lock()</li>
            <li>ReentrantLock.lockInterruptibly()</li>
            </ul>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_THREAD_FAIRNESS">
        <ShortDescription>方法 ignores Lock's fairness settings by calling tryLock()</ShortDescription>
        <LongDescription>方法 {1} ignores Lock's fairness settings by calling {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>Calling <code>Lock.tryLock()</code> or <code>ReentrantLock.tryLock()</code> without a timeout does not honor the lock's fairness setting. If you want to honor the fairness setting for this lock, then use <code>tryLock(0, TimeUnit.SECONDS)</code> which is almost equivalent (it also detects interruption).</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_SIGNAL_NOT_SIGNALALL">
        <ShortDescription>方法 calls Condition.signal() rather than Condition.signalAll()</ShortDescription>
        <LongDescription>方法 {1} calls Condition.signal() rather than Condition.signalAll()</LongDescription>
        <Details>
            <![CDATA[
            <p><code>Condition.signalAll()</code> is preferred over <code>Condition.signal()</code>. Calling <code>signal()</code> only wakes up one thread, meaning that the thread woken up might not be the one waiting for the condition that the caller just satisfied.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_LOCK_ISLOCKED">
        <ShortDescription>方法 tests if a lock is locked</ShortDescription>
        <LongDescription>方法 {1} tests if a lock is locked by calling {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>Calling <code>ReentrantLock.isLocked()</code> or <code>ReentrantLock.isHeldByCurrentThread()</code> might indicate race conditions or incorrect locking. These methods are designed for use in debug code or monitoring of the system state, not for synchronization control.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_STRING_BYTES_ENCODING">
        <ShortDescription>方法 encodes String bytes without specifying the character encoding</ShortDescription>
        <LongDescription>方法 {1} encodes String bytes without specifying the character encoding</LongDescription>
        <Details>
            <![CDATA[
            <p>The behavior of the <code>String(byte[] bytes)</code> and <code>String.getBytes()</code> is undefined if the string cannot be encoded in the platform's default charset. Instead, use the <code>String(byte[] bytes, String encoding)</code> or <code>String.getBytes(String encoding)</code> constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.</p>

            <p>As per the Java specifications, "UTF-8", "US-ASCII", "UTF-16" and "ISO-8859-1" will all be valid <a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard">encoding charsets</a>.  If you aren't sure, try "UTF-8".</p>

            <p><b>New in Java 1.7</b>, you can specify an encoding from <code>StandardCharsets</code>, like <code>StandardCharsets.UTF_8</code>.  These are generally preferrable because you don't have to deal with <code>UnsupportedEncodingException</code>.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_SETDEFAULTLOCALE">
        <ShortDescription>方法 calls Locale.setDefault()</ShortDescription>
        <LongDescription>方法 {1} calls Locale.setDefault(), changing locale for all threads</LongDescription>
        <Details>
            <![CDATA[
            <p>Do not use the <code>Locale.setDefault()</code> method to change the default locale. It changes the JVM's default locale for all threads and makes your applications unsafe to threads. It does not affect the host locale. Since changing the JVM's default locale may affect many different areas of functionality, this method should only be used if the caller is prepared to reinitialize locale-sensitive code running within the same Java Virtual Machine, such as the user interface.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ROOM_REFLECTION_ON_OBJECT_METHODS">
        <ShortDescription>方法 uses reflection to call a method available on java.lang.Object</ShortDescription>
        <LongDescription>方法 {1} uses reflection to call a method available on java.lang.Object</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses reflection to call a method that is defined in java.lang.Object.
            As these methods are always available, it is not necessary to call these methods with
            reflection.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IPU_IMPROPER_PROPERTIES_USE">
        <ShortDescription>方法 puts non-String values into a Properties object</ShortDescription>
        <LongDescription>方法 {1} puts non-String values into a Properties object</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 places non-String objects into a Properties object. As the Properties object
            is intended to be a String to String map, putting non String objects is wrong, and takes advantage
            of a design flaw in the Properties class by deriving from Hashtable instead of using aggregation.
            If you want a collection that holds other types of objects, use a Hashtable, or better still newer collections
            like HashMap or TreeMap.</p>
            <p>
            Don't use <code>properties.put("foo", bar);</code>
            </p>
            <p>
            Do use <code>properties.setProperty("foo", "bar");</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IPU_IMPROPER_PROPERTIES_USE_SETPROPERTY">
        <ShortDescription>方法 uses Properties.put instead of Properties.setProperty</ShortDescription>
        <LongDescription>方法 {1} uses Properties.put instead of Properties.setProperty</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses the inherited method from Hashtable put(String key, Object value) in
            a Properties object. Since the Properties object was intended to be only a String to String
            map, use of the derived put method is discouraged. Use the Properties.setProperty method instead.</p>
            <p>
            Don't use <code>properties.put("foo", "bar");</code>
            </p>
            <p>
            Do use <code>properties.setProperty("foo", "bar");</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PCAIL_POSSIBLE_CONSTANT_ALLOCATION_IN_LOOP">
        <ShortDescription>方法 allocates an object that is used in a constant way in a loop</ShortDescription>
        <LongDescription>方法 {1} allocates an object that is used in a constant way in a loop</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 allocates an object using the default constructor in a loop, and then
            only uses it in a quasi-static way. It is never assigned to anything that lives outside
            the loop, and could potentially be allocated once outside the loop. Often this can be
            achieved by calling a clear() like method in the loop, to reset the state of the object
            in the loop.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WOC_WRITE_ONLY_COLLECTION_LOCAL">
        <ShortDescription>方法 creates and initializes a collection but never reads or gains information from it</ShortDescription>
        <LongDescription>方法 {1} creates and initializes a collection but never reads or gains information from it</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 creates and initializes a collection but then never accesses this collection
            to gain information or fetch items from the collection. It is likely that this collection
            is left over from a past effort, and can be removed.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WOC_WRITE_ONLY_COLLECTION_FIELD">
        <ShortDescription>类 creates and initializes a collection but never reads or gains information from it</ShortDescription>
        <LongDescription>类 {0} creates and initializes a collection but never reads or gains information from it</LongDescription>
        <Details>
            <![CDATA[
            <p>This class creates and initializes a collection as a field but then never accesses this collection
            to gain information or fetch items from the collection. It is likely that this collection
            is left over from a past effort, and can be removed.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UVA_USE_VAR_ARGS">
        <ShortDescription>方法 defines parameter list with array as last argument, rather than vararg</ShortDescription>
        <LongDescription>方法 {1} defines parameter list with array as last argument, rather than vararg</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 defines a parameter list that ends with an array. As this class is compiled with
            Java 1.5 or better, this parameter could be defined as a vararg parameter instead, which can be
            more convenient for client developers to use. This is not a bug, per se, just an improvement.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PUS_POSSIBLE_UNSUSPECTED_SERIALIZATION">
        <ShortDescription>方法 serializes an instance of a non-static inner class</ShortDescription>
        <LongDescription>方法 {1} serializes an instance of a non-static inner class</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 serializes an instance of a non-static inner class. Since this class has a
            reference to the containing class, this outer class will be serialized as well. This is often
            not intentional, and will make the amount of data that is serialized much more than is needed.
            If the outer class is not desired to be serialized, either make the inner class static, or
            pull it out into a separate "first class" class.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SEC_SIDE_EFFECT_CONSTRUCTOR">
        <ShortDescription>方法 uses a Side Effect Constructor</ShortDescription>
        <LongDescription>方法 {1} uses a Side Effect Constructor</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 creates an object but does not assign this object to any variable or field.
            This implies that the class operates through side effects in the constructor, which is a
            bad pattern to use, as it adds unnecessary coupling. Consider pulling the side effect out of
            the constructor, into a separate method, or into the calling method.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SGSU_SUSPICIOUS_GETTER_SETTER_USE">
        <ShortDescription>方法 uses same bean's getter value for setter</ShortDescription>
        <LongDescription>方法 {1} uses same bean's getter value for setter</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 retrieves the property of a Java bean, only to use it in the setter
            for the same property of the same bean. This is usually a copy/paste typo.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LGO_LINGERING_GRAPHICS_OBJECT">
        <ShortDescription>方法 allocations a java.awt.Graphics object without disposing it</ShortDescription>
        <LongDescription>方法 {1} allocations a java.awt.Graphics object without disposing it</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 allocates a java.awt.Graphics object but doesn't dispose of it when done. While
            the garbage collector will clean this up, given that a large number of Graphics objects can be
            created in a short period of time, it is recommended that you explicitly dispose() of them.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="STB_STACKED_TRY_BLOCKS">
        <ShortDescription>方法 stacks similar try/catch blocks</ShortDescription>
        <LongDescription>方法 {1} stacks similar try/catch blocks</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 declares two try-catch blocks one after another, where each
            catch block catches the same type of exception. They also throw uniformly the
            same type of exception. These two catch blocks can be combined into one to
            simplify the method.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CEBE_COMMONS_EQUALS_BUILDER_ISEQUALS">
        <ShortDescription>方法 returns the result of invoking equals() on EqualsBuilder</ShortDescription>
        <LongDescription>方法 {1} returns the result of invoking equals() in EqualsBuilder</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 returns the result of <code>equals</code> on the EqualsBuilder type
            instead of calling the method isEqual().</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CHTH_COMMONS_HASHCODE_BUILDER_TOHASHCODE">
        <ShortDescription>方法 returns the result of invoking hashCode() on HashCodeBuilder</ShortDescription>
        <LongDescription>方法 {1} returns the result of invoking hashCode() in HashCodeBuilder</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 returns the result of <code>hashCode</code> on the HashCodeBuilder type
            instead of calling the method toHashCode().</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CSBTS_COMMONS_STRING_BUILDER_TOSTRING">
        <ShortDescription>方法 returns the result of invoking toString() without intermediate invocation of append() in ToStringBuilder</ShortDescription>
        <LongDescription>方法 {1} returns the result of invoking toString() without intermediate invocation of append() in ToStringBuilder</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 returns the result of <code>toString</code> on a ToStringBuilder without an
            intermediate invocation of append().</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CCNE_COMPARE_CLASS_EQUALS_NAME">
        <ShortDescription>方法 compares class name instead of comparing class</ShortDescription>
        <LongDescription>方法 {1} compares class name instead of comparing the class</LongDescription>
        <Details>
            <![CDATA[
            <p>In a JVM, two classes are the same class (and consequently the same type) if
            they are loaded by the same class loader, and they have the same fully
            qualified name [JVMSpec 1999].

            Comparing class name ignores the class loader.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BRPI_BACKPORT_REUSE_PUBLIC_IDENTIFIERS">
        <ShortDescription>方法 uses backported libraries that are now built in</ShortDescription>
        <LongDescription>方法 {1} uses backported libraries that are now built in</LongDescription>
        <Details>
            <![CDATA[
            <p>This class uses either Backport Utils concurrent classes from Emory, or Time classes from ThreeTen Backport.
            Updated/efficient versions of these classes are available in the version of the JDK that this code is compiled against -
            JDK 1.5 for the concurrent classes, and JDK 1.8 for the time classes - and these
            classes should only be used if you are targeting a JDK lower than this.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CU_CLONE_USABILITY_OBJECT_RETURN">
        <ShortDescription>克隆方法 declares it returns an Object</ShortDescription>
        <LongDescription>克隆方法 {1} declares it returns an Object</LongDescription>
        <Details>
            <![CDATA[
            <p>This class implements the Cloneable interface but defines its clone method to return an
            Object. Since most likely users of this method will need to cast it to the real type, this will
            be more painful than necessary. Just declare the return value to be the type of this class.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CU_CLONE_USABILITY_MISMATCHED_RETURN">
        <ShortDescription>克隆方法 declares it returns a type different than the owning class</ShortDescription>
        <LongDescription>克隆方法 {1} declares it returns a type different than the owning class</LongDescription>
        <Details>
            <![CDATA[
            <p>This class implements the Cloneable interface but defines its clone method to return a type
            that is different than the class itself, or any interfaces that the class implements.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CU_CLONE_USABILITY_THROWS">
        <ShortDescription>克隆方法 declares it throws CloneNotSupportedException</ShortDescription>
        <LongDescription>克隆方法 {1} declares it throws CloneNotSupportedException</LongDescription>
        <Details>
            <![CDATA[
            <p>This class implements the Cloneable interface but defines its clone method to still throw
            a CloneNotSupportedException. Since you are implementing clone() it would make sense that the method
            in question will <em>not</em> throw that exception, so annotating your method with it just makes clients'
            use of your class more painful as they have to handle an exception that will never happen.
            Just remove the throws clause from your method.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CAAL_CONFUSING_ARRAY_AS_LIST">
        <ShortDescription>方法 calls Array.asList on an array of primitive values</ShortDescription>
        <LongDescription>方法 {1} calls Array.asList on an array of primitive values</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 passes an array of primitive values to the Arrays.asList call. As primitive
            values in arrays aren't automatically promoted to boxed primitives in arrays, the asList call
            cannot convert this array to a list of boxed primitives. It therefore just creates an array
            with one item in it, the array itself. This is rarely what is desired.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PSC_PRESIZE_COLLECTIONS">
        <ShortDescription>方法 does not presize the allocation of a collection</ShortDescription>
        <LongDescription>方法 {1} does not presize the allocation of a collection</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 allocates a collection using the default constructor even though it is known
            a priori (or at least can be reasonably guessed) how many items are going to be placed in the collection,
            and thus needlessly causes intermediate reallocations of the collection.</p>
            <p>You can use the constructor that takes an initial size and that will be much better, but
            due to the loadFactor of Maps and Sets, even this will not be a correct estimate.</p>
            <p>If you are using Guava, use its methods that allocate maps and sets with a predetermined size,
            to get the best chance for no reallocations, such as:
            <ul>
                <li>Sets.newHashSetWithExpectedSize(int)</li>
                <li>Maps.newHashMapWithExpectedSize(int)</li>
            </ul>
            If not, a good estimate would be the expectedSize / {LOADING_FACTOR} which by default is 0.75
            </p>
            ]]>
        </Details>
    </BugPattern>

        <BugPattern type="PSC_SUBOPTIMAL_COLLECTION_SIZING">
        <ShortDescription>方法 uses suboptimal sizing to allocate a collection</ShortDescription>
        <LongDescription>方法 {1} uses suboptimal sizing to allocate a collection</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 allocates a collection using the a constructor that takes a size parameter. However,
            because Maps and Sets have a loading factor, passing in the exact size you want is an
            incorrect way to presize the collection, and may still cause reallocations. Since you are using
            Guava, it is better to use
            <code><pre>
                Maps.newHashMapWithExpectedSize(c.size());
            </pre></code>
            or
            <code><pre>
                Sets.newHashSetWithExpectedsize(c.size());
            </pre></code>
            as this method calculates the correct size taking into account the loading factor.

            Alternatively, if you know that the collection will not grow beyond the initial size,
            you can specify a load factor of 1.0F in the constructor.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UMTP_UNBOUND_METHOD_TEMPLATE_PARAMETER">
        <ShortDescription>方法 declares unbound method template parameter(s)</ShortDescription>
        <LongDescription>方法 {1} declares unbound method template parameter(s)</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 declares a method level template parameter that is not bound by any parameter of this
            method. Therefore the template parameter adds no validation or type safety and can be removed, as it's
            just confusing to the reader.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NPMC_NON_PRODUCTIVE_METHOD_CALL">
        <ShortDescription>方法 ignores return value of a non mutating method</ShortDescription>
        <LongDescription>方法 {1} ignores return value of a non mutating method</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 ignores the return value of a common method that is assumed to be non-mutating.
            If this method does in fact not modify the object it is called on, there is no reason to call
            this method, and it can be removed.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AIOB_ARRAY_INDEX_OUT_OF_BOUNDS">
        <ShortDescription>方法 attempts to access an array element outside the array's size</ShortDescription>
        <LongDescription>方法 {1} attempts to access an array element outside the array's size</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 accesses an array element using a literal index that is known to be outside the size
            of the specified array. This will cause an ArrayIndexOutOfBoundsException at runtime.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AIOB_ARRAY_STORE_TO_NULL_REFERENCE">
        <ShortDescription>方法 attempts to store an array element to an array that does not appear to be allocated</ShortDescription>
        <LongDescription>方法 {1} attempts to store an array element to an array that does not appear to be allocated</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 attempts to store an array element into an array that appears not to have been allocated.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ICA_INVALID_CONSTANT_ARGUMENT">
        <ShortDescription>方法 passes an invalid value as a method argument</ShortDescription>
        <LongDescription>方法 {1} passes an invalid value as a method argument</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 passes an invalid constant value to a method parameter that expects only a select number of possible values.
            This is likely going to cause this method to fail to operate correctly.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CNC_COLLECTION_NAMING_CONFUSION">
        <ShortDescription>集合变量 is named with a different type of collection in the name</ShortDescription>
        <LongDescription>集合变量 {1} is named with a different type of collection in the name</LongDescription>
        <Details>
            <![CDATA[
            <p>This class defines a field or local collection variable with a name that contains a different type
            of collection in its name. An example would be a Set<User> called userList. This is confusing to the reader,
            and likely caused by a previous refactor of type, without changing the name. This detector is obviously
            only checking for English names.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PME_POOR_MANS_ENUM">
        <ShortDescription>简单字段 is used like an enum</ShortDescription>
        <LongDescription>简单字段 {1} is used like an enum</LongDescription>
        <Details>
            <![CDATA[
            <p>This field, although defined as a simple variable (int, String, etc), only has a set of constant values
            assigned to it. Thus it appears to be used like an enum value, and should probably be defined as such.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UP_UNUSED_PARAMETER">
        <ShortDescription>私有方法或静态方法 has unused parameters</ShortDescription>
        <LongDescription>私有方法或静态方法 {1} has unused parameters</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 defines parameters that are never used. As this method is either static or private,
            and can't be derived from, it is safe to remove these parameters and simplify your method.
            You should consider, while unlikely, that this method may be used reflectively, and thus you will
            want to change that call as well. In this case, it is likely that once you remove the parameter,
            there will be a chain of method calls that have spent time creating this parameter and passing it
            down the line. All of this may be able to be removed.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="FCCD_FIND_CLASS_CIRCULAR_DEPENDENCY">
        <ShortDescription>类 has a circular dependency with other classes</ShortDescription>
        <LongDescription>类 {0} has a circular dependency with other classes</LongDescription>
        <Details>
            <![CDATA[
            <p>
            This class has a circular dependency with other classes. This makes building these classes
            difficult, as each is dependent on the other to build correctly. Consider using interfaces
            to break the hard dependency. The dependency chain can be seen in the GUI version of FindBugs.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUC_MODIFYING_UNMODIFIABLE_COLLECTION">
        <ShortDescription>方法 attempts to modify collection that appears to possibly be immutable</ShortDescription>
        <LongDescription>方法 {1} attempts to modify collection that appears to possibly be immutable</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 attempts to modify a collection that it got from a source that could potentially have created an
            immutable collection, through Arrays.asList, Collections.unmodifiableXXX, or one of Guava's methods.
            Doing so will cause an exception, as these collections are not mutable.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="HES_EXECUTOR_NEVER_SHUTDOWN">
        <ShortDescription>ExecutorService field doesn't ever get shutdown</ShortDescription>
        <LongDescription>ExecutorService {2} is instantiated, but never shutdown, potentially preventing the entire JVM from shutting down</LongDescription>
        <Details>
            <![CDATA[
            <p>Most <code>ExecutorService</code> objects must be explicitly shut down,
            otherwise their internal threads can prolong the running of the JVM, even when everything
            else has stopped.</p>

            <p>FindBugs has detected that there are no calls to either the <code>shutdown()</code> or <code>shutdownNow()</code>
            method, and thus, the <code>ExecutorService</code> is not guaranteed to ever terminate.  This is especially
            problematic for <code>Executors.newFixedThreadPool()</code> and most of the other convenience methods in
            the <code>Executors</code> class.</p>

            <p>Even though there are some exceptions to this, particularly when a custom <code>ThreadFactory</code> is
            provided, or for <code>ThreadPoolExecutor</code>s with <code>allowsCoreThreadTimeOut()</code> set to true,
            it is good practice to explicitly shutdown the <code>ExecutorService</code> when its utility is done.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="HES_LOCAL_EXECUTOR_SERVICE">
        <ShortDescription>Suspicious Local Executor Service</ShortDescription>
        <LongDescription>ExecutorService is created as a local variable, which is unusual</LongDescription>
        <Details>
            <![CDATA[
            <p><code>ExecutorService</code>s are typically instantiated as fields so that many tasks can be executed on a controlled number of <code>Thread</code>s across many method calls.  Therefore, it is unusual for <code>ExecutorService</code>s to be a local variable, where tasks will be added only one time, in the enclosing method. </p>

            <p>Furthermore, when a local <code>ExecutorService</code> reaches the end of scope and goes up for garbage collection, the internal <code>Thread</code>s are not necessarily terminated and can prevent the JVM from ever shutting down.</p>

            <p>Consider making this local variable a field and creating a method that will explicitly shut down the <code>ExecutorService</code></p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="HES_EXECUTOR_OVERWRITTEN_WITHOUT_SHUTDOWN">
        <ShortDescription>An ExecutorService isn't shutdown before the reference to it is lost</ShortDescription>
        <LongDescription>ExecutorService {2} is replaced with another ExecutorService without being shutdown, potentially preventing the entire JVM from shutting down</LongDescription>
        <Details>
            <![CDATA[
            <p>Most <code>ExecutorService</code> objects must be explicitly shut down, otherwise their internal threads
            can prevent the JVM from ever shutting down, even when everything else has stopped.</p>

            <p>FindBugs has detected that something like the following is happening:<br/>
<pre><code>
ExecutorService executor = ... //e.g. Executors.newCachedThreadPool();
...
public void reset() {
    this.executor = Executors.newCachedThreadPool();
    this.executor.execute(new SampleExecutable());
}<br/>
</code></pre>
            For normal objects, losing the last reference to them like this would trigger the object to be cleaned up
            in garbage collection.  For <code>ExecutorService</code>s, this isn't enough to terminate the internal threads in the
            thread pool, and the <code>ExecutorService</code> isn't guaranteed to shut down, causing the JVM to never stop. <br/>
            To fix this, simply add a call to <code>shutdown()</code> like this:<br/>
<pre><code>
ExecutorService executor = ... //e.g. Executors.newCachedThreadPool();
...
public void reset() {
    this.executor.shutDown(); //Fix
    this.executor = Executors.newCachedThreadPool();
    this.executor.execute(new SampleExecutable());
}
</code></pre>
            </p>

            <p>Even though there are some exceptions to this, particularly when a custom <code>ThreadFactory</code> is
            provided, or for <code>ThreadPoolExecutor</code>s with <code>allowsCoreThreadTimeOut()</code> set to true,
            it is good practice to explicitly shut down the <code>ExecutorService</code> at the end of execution, or
            when it is being replaced.</p>

            <p><b>Note:</b> <code>ExecutorService</code>s are generally created once in a program's life cycle.  If you find yourself
            replacing the <code>ExecutorService</code>, perhaps you may consider restructuring your code to use calls like
            <code>awaitTermination()</code> or <code>Future</code>s/<code>Callable</code>s to avoid recreating the <code>ExecutorService</code>.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="HCP_HTTP_REQUEST_RESOURCES_NOT_FREED_FIELD">
        <ShortDescription>Unreleased HttpRequest network resources (field)</ShortDescription>
        <LongDescription>The HttpRequest field {1} does not release its network resources, which could freeze the running code</LongDescription>
        <Details>
            <![CDATA[
            <p>FindBugs has detected an <code>org.apache.http.HttpRequest</code> (e.g. <code>HttpGet</code>, <code>HttpPost</code>, etc)
            that didn't release its associated resources.  Code like the following: <br/>
<pre>code>
private HttpGet httpGet;

public String requestInfo(URI u) {
    this.httpGet = new HttpGet(u);
    try(CloseableHttpResponse response = client.execute(httpGet);) {
        return getResponseAsString(response);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>
                will freeze after a few requests, usually with no indication as to why.  </p>

            <p>
                The reason this code freezes is because <code>org.apache.http.HttpRequest</code>s need to explicitly release their connection
                with a call to either <code>reset()</code> or <code>releaseConnection()</code>.  The above example can be easily fixed:<br/>
<pre><code>
private HttpGet httpGet;
...
public String requestInfo(URI u) {
    this.httpGet = new HttpGet(u);
    try(CloseableHttpResponse response = client.execute(httpGet);) {
        return getResponseAsString(response);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
    <b>finally {
        this.httpGet.reset();
    }</b>
    return null;
}<br/>
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="HCP_HTTP_REQUEST_RESOURCES_NOT_FREED_LOCAL">
        <ShortDescription>Unreleased HttpRequest network resources (local)</ShortDescription>
        <LongDescription>The local HttpRequest {1} does not release its network resources before being garbage collected, which could freeze the running code</LongDescription>
        <Details>
            <![CDATA[
            <p>FindBugs has detected an <code>org.apache.http.HttpRequest</code> (e.g. <code>HttpGet</code>, <code>HttpPost</code>, etc)
            that didn't release its associated resources.  Code like the following: <br/>
<pre><code>
public String requestInfo(URI u) {
    HttpGet httpGet = new HttpGet(u);
    try(CloseableHttpResponse response = client.execute(httpGet);) {
        return getResponseAsString(response);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>
                will freeze after a few requests, usually with no indication as to why. </p>

            <p>
                The reason this code freezes is because <code>org.apache.http.HttpRequest</code>s need to explicitly release their connection
                with a call to either <code>reset()</code> or <code>releaseConnection()</code>, <b>even if the request is a local</b>.
                The garbage collector will not release these resources, leading to the frustrating freezing scenario described above.

                <br/>The above example can be easily fixed:<br/>
<pre><code>
public String requestInfo(URI u) {
    HttpGet httpGet = new HttpGet(u);
    try(CloseableHttpResponse response = client.execute(httpGet);) {
        return getResponseAsString(response);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
    <b>finally {
        httpGet.reset();
    }</b>
    return null;
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UJM_UNJITABLE_METHOD">
        <ShortDescription>方法 is too long to be compiled by the JIT</ShortDescription>
        <LongDescription>方法 {1} is too long to be compiled by the JIT</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 is longer than 8000 bytes. By default the JIT will not attempt to compile this method no matter
            how hot it is, and so this method will always be interpreted. If performance is important, you should consider
            breaking this method up into smaller chunks. (And it's probably a good idea for readability too!)</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CTU_CONFLICTING_TIME_UNITS">
        <ShortDescription>方法 performs arithmetic operations on time values with different units</ShortDescription>
        <LongDescription>方法 {1} performs arithmetic operations on time values with different units</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 takes two values that appear to be representing time, and performs arithmetic operations on these
            two values directly, even though it appears that the two values are representing different time units, such as
            adding a millisecond value to a nanosecond value. You should convert the two values to the same time unit before
            performing this calculation in order for it to be meaningful.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CSI_CHAR_SET_ISSUES_USE_STANDARD_CHARSET">
        <ShortDescription>方法 needlessly uses a String literal as a Charset encoding</ShortDescription>
        <LongDescription>方法 "{3}" needlessly uses a String literal to define an encoding.  A built-in Charset could be used instead like: {4}</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses a string literal to specify a <code>Charset</code> encoding. However, the method invoked has an
            alternative signature that takes a <code>Charset</code> object. You should use this signature, as this class is compiled
            with JDK 7 (or better), and the <code>Charset</code> in question is available as a constant from the
            <code>java.nio.charset.StandardCharsets</code> class.</p>
            <p>Instead of specifying "UTF-8", use <code>StandardCharsets.UTF_8</code>, for instance. An added benefit of this is
            that you will not need to catch <code>UnsupportedEncodingException</code>.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CSI_CHAR_SET_ISSUES_USE_STANDARD_CHARSET_NAME">
        <ShortDescription>方法 should use a StandardCharsets.XXX.name() to specify an encoding</ShortDescription>
        <LongDescription>方法 {3} should use a StandardCharsets.XXX.name() to specify an encoding</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses a hand-typed <code>String</code> literal to specify a <code>Charset</code> encoding. As this class is compiled
            with JDK 7 (or better), and the charset in question is available as a constant from the
            <code>java.nio.charset.StandardCharsets</code> class, it is better to use the .name() method of the appropriate
            <code>StandardCharsets</code> constant.</p>

            <p>The method in question doesn't directly support a <code>Charset</code> as a parameter, only a <code>String</code>.
            Still, instead of specifying something like "UTF-8" (and potentially mistyping it), use <code>StandardCharsets.UTF_8.name()</code>.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CSI_CHAR_SET_ISSUES_UNKNOWN_ENCODING">
        <ShortDescription>方法 uses an unknown character encoding literal</ShortDescription>
        <LongDescription>方法 {3} uses an unknown character encoding literal "{4}"</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 specifies a <code>Charset</code> encoding with a String literal that is not recognized by the current
            JDK. It's possible that this application will only be deployed on a JVM that does recognize this encoding, but
            it seems dubious that this is the case.</p>
            <p>
            The standard JDK encodings (for Java 8) are "UTF-8", "US-ASCII", "ISO-8859-1", "UTF-16BE", "UTF-16LE", "UTF-16".  These are all case-sensitive.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CBC_CONTAINS_BASED_CONDITIONAL">
        <ShortDescription>方法 uses an excessively complex conditional that can be replaced with Set.contains</ShortDescription>
        <LongDescription>方法 {1} uses an excessively complex conditional that can be replaced with Set.contains</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses an overly complex <code>if</code> expression made up of multiple conditions joined by OR, where the same
            local variable is compared to a static value. When the number of conditions grows, it is much cleaner
            to build a static set of the possible values, and use the contains method on that set. This will
            shorten the code, and make it more self documenting.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OPM_OVERLY_PERMISSIVE_METHOD">
        <ShortDescription>方法 is declared more permissively than is used in the code base</ShortDescription>
        <LongDescription>方法 {1} is declared more permissively than is used in the code base</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 is declared more permissively than the code is using. Having this method be more
            permissive than is needed limits your ability to make observations about this method, like
            parameter usage, refactorability, and derivability. It is possible that this detector will report
            erroneously if:
            <ul>
                <li>The method is called from code not being scanned, such as unit tests</li>
                <li>The method is an API method, expected to be used by unknown client code</li>
                <li>The method is called through reflection
            </ul>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="STT_TOSTRING_STORED_IN_FIELD">
        <ShortDescription>方法 stores the value of a toString() call into a field</ShortDescription>
        <LongDescription>方法 {0} stores the value of a toString() call into a field</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls the toString() method on an object and stores the value in a field. Doing this
            throws away the type safety of having the object defined by a Class. Using String makes it very easy to
            use the wrong type of value, and the compiler will not catch these mistakes. You should delay converting
            values to Strings for as long as possible, and thus not store them as fields.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="STT_STRING_PARSING_A_FIELD">
        <ShortDescription>方法 parses a String that is a field</ShortDescription>
        <LongDescription>方法 {1} parses a String that is a field</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls a parsing method (indexOf, lastIndexOf, startsWith, endsWith, substring, indexOf) on a String
            that is a field, or comes from a collection that is a field. This implies that the String in question is holding
            multiple parts of information inside the string, which would be more maintainable and type safe if that value was a
            true collection or a first class object with fields, rather than a String.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="STT_TOSTRING_MAP_KEYING">
        <ShortDescription>方法 uses a concatenated String as a map key</ShortDescription>
        <LongDescription>方法 {1} uses a concatenated String as a map key</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 builds a key for a map, using a StringBuilder, either implicitly or explicitly. This means the type
            of the key is something more than a String constant, it is a properly formatted String. However, there is no
            type based verification that all uses of this key will follow this formatting. It is much better to use a proper, simple,
            bean class that holds two (or more) fields so that it is clear what is expected for key use.
            </p>
            <p>
            Example<br/>
                instead of
                <pre><code>
                    V v = myMap.get(tableName + "-" + columnName);
                </code></pre>
                use
                <pre><code>
                    V v = myMap.get(new ColumnSpec(tableName, columnName));
                </code></pre>
                where ColumnSpec is a simple bean-like class of your creation. The advantages, are
                <ul>
                    <li>The ColumnSpec fully describes what is expected, you need a tableName and columnName</li>
                    <li>There is no guessing by the programmer what the format is, was it tableName + "_" + columnName?</li>
                </ul>
                </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SLS_SUSPICIOUS_LOOP_SEARCH">
        <ShortDescription>方法 continues a loop after finding an equality condition</ShortDescription>
        <LongDescription>方法 {1} continues a loop after finding an equality condition</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 continues with a loop, and does not break out of it, after finding and setting a variable in an
            <code>if</code> condition based on equality. Since continuing on in the loop would seem to be unlikely to find the item again,
            breaking at this point would seem to be the proper action.</p>
            <p>Example:
<pre><code>
int age = 0;
for (Person p : people) {
    if (p.getName().equals("Dave")) {
        age = p.getAge();
    }
}
</code></pre>
            It is likely you wanted a break after getting the age for "Dave".</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CRF_CONFLATING_RESOURCES_AND_FILES">
        <ShortDescription>方法 accesses URL resources using the File API</ShortDescription>
        <LongDescription>方法 {1} accesses URL resources using the File API</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 fetches a resource from a URL, and uses the File API to manipulate it. If this resource is a
            classpath resource, it will work if the resource is a file in a directory. If, however, the file is inside a JAR file
            this will fail. To avoid this confusing inconsistency, use the URL.openStream API instead to access the data of the classpath resource.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_NO_EQUALS">
        <ShortDescription>类 does not implement an equals method</ShortDescription>
        <LongDescription>类 {0} does not implement an equals method</LongDescription>
        <Details>
            <![CDATA[
            <p>This class, which has instance fields, has no equals(Object o) method. It is possible that this
            class is never used in a context where this is required; it is often assumed, however, from clients
            of this class that it is, so it is good to add such methods when you create them.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_NO_HASHCODE">
        <ShortDescription>类 does not implement a hashCode method</ShortDescription>
        <LongDescription>类 {0} does not implement a hashCode method</LongDescription>
        <Details>
            <![CDATA[
            <p>This class, which has instance fields, has no hashCode() method. It is possible that this
            class is never used in a context where this is required; it is often assumed, however, from clients
            of this class that it is, so it is good to add such methods when you create them.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_NO_PACKAGE">
        <ShortDescription>类 is defined in the default package</ShortDescription>
        <LongDescription>类 {0} id defined in the default package</LongDescription>
        <Details>
            <![CDATA[
            <p>This class has been created in the default package. Classes should be defined in a
            proper package structure, typically defined by the reverse of the domain name of the
            owner of the code base. Putting code in the default (no) package limits its usefulness, including:
            <ol>
            <li>Not being able to import this class into classes with packages</li>
            <li>Leaving it open to name collisions with other packages.</li>
            </ol>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_NO_TOSTRING">
        <ShortDescription>类 does not implement a toString method</ShortDescription>
        <LongDescription>类 {0} does not implement a toString method</LongDescription>
        <Details>
            <![CDATA[
            <p>This class, which has instance fields, has no toString() method, which will make debugging with this
            class more difficult than it could be. Consider adding a toString() method. Using libraries like commons-lang3
            ToStringBuilder makes this process easy.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_IDE_GENERATED_PARAMETER_NAMES">
        <ShortDescription>方法 uses IDE generated parameter names</ShortDescription>
        <LongDescription>方法 {1} uses IDE generated parameter names</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 appears to have been generated from an interface or superclass using an IDE.
            As such the IDE generated generic names (arg0, arg1, arg2) for parameters for this method,
            and the author of this method did not change them to be meaningful. For better understandability
            it is recommended that you name these parameters with regard to their function.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_PRINTSTACKTRACE">
        <ShortDescription>方法 prints the stack trace to the console</ShortDescription>
        <LongDescription>方法 {1} prints the stack trace to the console</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 prints a stack trace to the console. This is non configurable, and causes an
            application to look unprofessional. Switch to using loggers so that users can control what
            is logged and where.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_WRONG_FIELD_ORDER">
        <ShortDescription>类 orders instance fields before static fields</ShortDescription>
        <LongDescription>类 {0} orders instance fields before static fields</LongDescription>
        <Details>
            <![CDATA[
            <p>This class defines fields in an order that is confusing, and not expected by
            other developers. The standard is for static fields to be listed first, followed by instance
            fields. When fields are listed out of order, developers may make assumptions about their
            behaviour that are incorrect and lead to bugs.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_UPPER_PACKAGE">
        <ShortDescription>类 is defined in a package with upper case characters</ShortDescription>
        <LongDescription>类 {0} is defined in a package with upper case characters</LongDescription>
        <Details>
            <![CDATA[
            <p>This class is defined within a package that uses upper case letters. Package names are
            expected to be in the form of all lowercase.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_LOWER_CLASS">
        <ShortDescription>类 does not start with an upper case letter</ShortDescription>
        <LongDescription>类 {0} does not start with an upper case letter</LongDescription>
        <Details>
            <![CDATA[
            <p>This class has been given a name that does not start with an upper case letter.
            Classes should follow a pattern of uppercasing the first letter of each word, AsAnExample</p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="IMC_IMMATURE_CLASS_BAD_SERIALVERSIONUID">
        <ShortDescription>类 defines a computed serialVersionUID that doesn't equate to the calculated value</ShortDescription>
        <LongDescription>类 {0} defines a computed serialVersionUID that doesn't equate to the calculated value</LongDescription>
        <Details>
            <![CDATA[
            <p>This serializable class defines a serialVersionUID that appears to be a computed value, however the value does not
            match the computed value, and thus losses it's value as version indicator. Either create a custom value like 1, 2, 3, 4.. etc, or
            recompute the serialVersionUID using your IDE.</p>
            ]]>
        </Details>
    </BugPattern> 
    
    <BugPattern type="IMC_IMMATURE_CLASS_VAR_NAME">
        <ShortDescription>类 defines a field or local variable named 'var'</ShortDescription>
        <LongDescription>类 {0} defines a field or local variable named 'var'</LongDescription>
        <Details>
            <![CDATA[
            <p>A field or variable is named 'var' which will conflict with the built in Java 10 feature using 'var' as a keyword.</p>
            ]]>
        </Details>
    </BugPattern>       

    <BugPattern type="JXI_GET_ENDPOINT_CONSUMES_CONTENT">
        <ShortDescription>JAX-RS Method implements a GET request but consumes input</ShortDescription>
        <LongDescription>JAX-RS Method {1} implements a GET request but consumes input</LongDescription>
        <Details>
            <![CDATA[
            <p>This JAX-RS endpoint is annotated to be used with @GET requests, but also documents that it
            consumes JSON or XML data. Since a GET request pulls parameters from the URL, and not
            the body of the request, this pattern is problematic. If you wish to consume JSON or XML data,
            this request should be annotated with @POST.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JXI_INVALID_CONTEXT_PARAMETER_TYPE">
        <ShortDescription>JAX-RS Method specifies an invalid @Context parameter type</ShortDescription>
        <LongDescription>JAX-RS {1} Method specifies an invalid @Context parameter type</LongDescription>
        <Details>
            <![CDATA[
            <p>This JAX-RS endpoint annotates a parameter with a @Context annotation. This annotation can supply values
            for the following types:
            <ul>
                <li>javax.ws.rs.core.UriInfo</li>
                <li>javax.ws.rs.core.HttpHeaders</li>
                <li>javax.ws.rs.core.Request</li>
                <li>javax.ws.rs.core.SecurityContext</li>
                <li>javax.ws.rs.ext.Providers</li>
                <li>javax.servlet.ServletConfig</li>
                <li>javax.servlet.ServletContext</li>
                <li>javax.servlet.HttpServletRequest</li>
                <li>javax.servlet.HttpServletResponse</li>
            </ul>
            It is possible that your container can supply additional types, but these types are not standard and may
            not be supported on other application servers.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JXI_PARM_PARAM_NOT_FOUND_IN_PATH">
        <ShortDescription>JAX-RS Method specifies non-resolveable @PathParam</ShortDescription>
        <LongDescription>JAX-RS Method {1} specifies non-resolveable @PathParam</LongDescription>
        <Details>
            <![CDATA[
            <p>This JAX-RS endpoint has a @PathParam specified that is not found in the @Path annotation
            and thus can not determine from where to populate that parameter.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JXI_UNDEFINED_PARAMETER_SOURCE_IN_ENDPOINT">
        <ShortDescription>JAX-RS Method defines a parameter that has no @*Param or @Context annotation, or @Consumes method annotation</ShortDescription>
        <LongDescription>JAX-RS Method {1} defines a parameter that has no @*Param or @Context annotation, or @Consumes method annotation</LongDescription>
        <Details>
            <![CDATA[
            <p>This JAX-RS endpoint declares a parameter without specifying where the value of this parameter comes from.
            You can specify this by using one of several 'Param' annotations (@PathParam, @CookieParam, @FormParam @HeaderParam @MatrixParam @QueryParam),
            by adding a @Context parameter annotation, or you can declare that the method @Consumes an XML or JSON stream.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_TRANSACTION_ON_NON_PUBLIC_METHOD">
        <ShortDescription>方法 has a Spring @Transactional annotation on it, but is non-public</ShortDescription>
        <LongDescription>方法 {1} has a Spring @Transactional annotation on it, but is non-public</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 specifies a Spring @Transactional annotation but the method is defined as being non-public.
            Spring only creates transactional boundaries on methods that are public, and so this annotation is not doing
            anything for this method. Make the method public, or place the annotation on a more appropriate method.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_HC_EQUALS_ON_MANAGED_ENTITY">
        <ShortDescription>JPA Entity with Generated @Id defined with hashCode/equals</ShortDescription>
        <LongDescription>JPA Entity {0} with Generated @Id defined with hashCode/equals</LongDescription>
        <Details>
            <![CDATA[
            <p>This class is defined to be a JPA Entity, and has an @Id field that is generated by the JPA provider.
            Since you do not control when that Id is created directly, it is risky to implement hashCode/equals for this
            class, and especially for use with Collections, as the data behind the algorithms will not be immutable, and
            thus cause problems when those fields change, and the object is in the collection. It is usually safer
            to not define hashCode and equals for entity objects, but treat them as objects for IdentityHashSet/Maps instead.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_NON_PROXIED_TRANSACTION_CALL">
        <ShortDescription>方法 annotated with @Transactional is called from a non Spring proxy</ShortDescription>
        <LongDescription>方法 {1} annotated with @Transactional is called from a non Spring proxy</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 call is to a method that has a @Transactional annotation on it. However, since this call is from the
            same class, it is not going through any Spring proxy, and thus the transactional quality of this method is completely
            lost. @Transactional methods must always be called through a Spring bean that is autowired.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_INEFFICIENT_EAGER_FETCH">
        <ShortDescription>OneToMany join specifies 1+n EAGER join</ShortDescription>
        <LongDescription>OneToMany join specifies 1+n EAGER join</LongDescription>
        <Details>
        <![CDATA[
        <p>This JPA entity specifies a @OneToMany join with a fetch type of EAGER. By default EAGER joins perform
        select operations on each element returned from the original query in sequence, thus producing 1 + n queries.
        If you are going to use EAGER joins, it is wise to specify a Join type by using @Fetch annotations in
        Hibernate or @JoinFetch/@BatchFetch annotations (or hints) in EclipseLink, for example. Even so, these
        annotations may only apply in limited cases, such as in the use of find.</p>
        ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_IGNORED_MERGE_RESULT">
        <ShortDescription>方法 ignores the return value of EntityManager.merge</ShortDescription>
        <LongDescription>方法 {1} ignores the return value of EntityManager.merge</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls EntityManager.merge, and throws away the resultant value. This result is the
            managed entity version of the potentially unmanaged object that was passed to merge. You should use
            the returned managed entity for any further use.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_NON_SPECIFIED_TRANSACTION_EXCEPTION_HANDLING">
        <ShortDescription>方法 does not specify how to handle transaction when exception is thrown</ShortDescription>
        <LongDescription>方法 {1} does not specify how to handle transaction when exception is thrown</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 declares that it throws one or more non-runtime exceptions. It also is annotated with a
            @Transactional annotation but fails to describe whether to rollback the transaction or not based on this
            thrown exception. Use 'rollbackFor' or 'noRollbackFor' attributes of the Transactional annotation to
            document this.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_UNNECESSARY_TRANSACTION_EXCEPTION_HANDLING">
        <ShortDescription>方法 declares handling a transactional exception that won't be thrown</ShortDescription>
        <LongDescription>方法 {1} declares handling a transactional exception that won't be thrown</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 declares that it either rolls back or does not rollback a transaction based on an
            expected exception being thrown. However, neither this exception, nor any derived exceptions can be thrown
            from this method, and so the annotation is useless.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SEO_SUBOPTIMAL_EXPRESSION_ORDER">
        <ShortDescription>方法 orders expressions in a conditional in a sub optimal way</ShortDescription>
        <LongDescription>方法 {1} orders expressions in a conditional in a sub optimal way</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 builds a conditional expression, for example, in an <code>if</code> or <code>while</code> statement,
            where the expressions contain both simple local variable comparisons and comparisons on method calls.
            The expression orders these so that the method calls come before the simple local variable comparisons.
            This causes method calls to be executed in conditions when they do not need to be, and thus potentially causes a lot of code
            to be executed for nothing. By ordering the expressions so that the simple conditions containing local variable conditions are first,
            you eliminate this waste. This assumes that the method calls do not have side effects. If the methods do have side effects,
            it is probably a better idea to pull these calls out of the condition and execute them first, assigning a value to a local variable.
            In this way you give a hint that the call may have side effects.</p>
            <p>Example:
<pre><code>
if ((calculateHaltingProbability() &gt; 0) && shouldCalcHalting) { }
</code></pre>
            would be better as
<pre><code>
if (shouldCalcHalting && (calculateHaltingProbability() &gt; 0) { }
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IOI_DOUBLE_BUFFER_COPY">
        <ShortDescription>方法 passes a Buffered Stream/Reader/Writer to a already buffering copy method</ShortDescription>
        <LongDescription>方法 {1} passes a Buffered Stream/Reader/Writer to a already buffering copy method</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 copies data from input to output using streams or reader/writers using a well known copy method, from java.nio, commons-io,
            springframework, guava or poi. These methods are efficient in that they copy these files using buffers. However, this method is also
            buffering the streams, causing a double buffering to occur. So data first goes to one buffer, then is copied to another buffer, before
            making it to the destination (or vice-versa). This just causes the copy operation to be inefficient both from a time perspective and
            a memory allocation one. When using these copy methods, do not pass buffered streams/readers/writers.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IOI_COPY_WITH_READER">
        <ShortDescription>方法 performs bulk stream copy with a java.io.Reader derived input</ShortDescription>
        <LongDescription>方法 {1} performs bulk stream copy with a java.io.Reader derived input</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 copies data from a java.io.Reader derived class to an output class, using a bulk copy method
            supplied by java.nio, commons-io, springframework, guava or poi. Since you are copying the entire stream, you
            don't care about its contents, and thus using a Reader is wasteful, as a reader has to do the hard work of
            converting byte data to characters, when there is no need to do this. Use stream based inputs for better performance.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IOI_USE_OF_FILE_STREAM_CONSTRUCTORS">
        <ShortDescription>方法 uses a FileInputStream or FileOutputStream constructor</ShortDescription>
        <LongDescription>方法 {1} uses a FileInputStream or FileOutputStream constructor</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 creates and uses a java.io.FileInputStream or java.io.FileOutputStream object. Unfortunately both
            of these classes implement a finalize method, which means that objects created will likely hang around until a
            full garbage collection occurs, which will leave excessive garbage on the heap for longer, and potentially much
            longer than expected. Java 7 introduced two ways to create streams for reading and writing files that do not have this concern.
            You should consider switching from these above classes to
            <code>
            InputStream is = java.nio.file.Files.newInputStream(myfile.toPath());
            OutputStream os = java.nio.file.Files.newOutputStream(myfile.toPath());
            </code>
            </p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="IOI_UNENDED_ZLIB_OBJECT">
        <ShortDescription>方法 creates a ZLIB Inflater or Deflater and doesn't appear to end() it</ShortDescription>
        <LongDescription>方法 {1} creates a ZLIB Inflater or Deflater and doesn't appear to end() it</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 constructs a java.util.zip.Inflater or java.util.zip.Deflater and does not appear to call end() on
            it. This will cause a potentially large amount of memory to hang around inside the object until the object gets 
            garbage collected. To avoid this unnecessary bloat, put a call to end() in a finally block of the code where you
            are using this instance.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DMC_DUBIOUS_MAP_COLLECTION">
        <ShortDescription>类 holds a map-type field, but uses it as only a List</ShortDescription>
        <LongDescription>类 {0} holds a map-type field {1}, but uses it as only a List</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 instantiates a map-type field in a static initializer or constructor, but then only uses it
            through iteration. This means that this data structure should really just be a List&lt;SomeObject&gt;,
            where the class held by the list contains the two fields held by the key and value of the Map.
            It was likely done this way to avoid having to create a class, but this just obfuscates the purpose of the field.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BL_BURYING_LOGIC">
        <ShortDescription>方法 buries logic to the right (indented) more than it needs to be</ShortDescription>
        <LongDescription>方法 {1} buries logic to the right (indented) more than it needs to be</LongDescription>
        <Details>
            <![CDATA[
            <p>Looks for relatively large <code>if</code> blocks of code, where you unconditionally return from them,
            and then follow that with an unconditional return of a small block. This places the bulk of the logic to the right indentation-wise,
            making it more difficult to read than needed. It would be better to invert the logic of the if block, and immediately return,
            allowing the bulk of the logic to be move to the left for easier reading.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WI_DUPLICATE_WIRED_TYPES">
        <ShortDescription>类 auto wires the same object into two separate fields in a class hierarchy</ShortDescription>
        <LongDescription>类 {0} auto wires the same object into two separate fields in a class hierarchy</LongDescription>
        <Details>
            <![CDATA[
            <p>This class has two fields in either itself or a parent class, which autowire (without specialization) the same object
            for both fields. This is likely caused by a developer just not being aware that the field already is available for your use,
            and just causes wasted space, and confuses code access to the same object through two different pathways.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WI_MANUALLY_ALLOCATING_AN_AUTOWIRED_BEAN">
        <ShortDescription>方法 allocates an object with new when the class is defined as an autowireable bean</ShortDescription>
        <LongDescription>方法 {1} allocates an object with new when the class is defined as an autowireable bean</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 allocates an object with new, but the class of the object that is being created is marked with a Spring annotation
            denoting that this class is to be used through an @Autowire annotation. Allocating it with <code>new</code> will likely mean that fields on the
            class will not be autowired, but instead be null. You should just autowire an instance of this class into the class in question, or if
            need be, use Spring's getBean(name) method to fetch one.</p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="WI_WIRING_OF_STATIC_FIELD">
        <ShortDescription>Static field is autowired</ShortDescription>
        <LongDescription>Static Field {1} is autowired</LongDescription>
        <Details>
            <![CDATA[
            <p>Autowiring of static fields does not work using simple @Autowire annotations, not should you attempt to do 
            so as it's an anti pattern. Use PostConstruct methods to initialize static fields if you must do something 
            like this.</p>
            ]]>
        </Details>
    
    </BugPattern>

    <BugPattern type="CCI_CONCURRENT_COLLECTION_ISSUES_USE_PUT_IS_RACY">
        <ShortDescription>方法 gets and sets a value of a ConcurrentHashMap in a racy manner</ShortDescription>
        <LongDescription>方法 {1} gets and sets a value of a ConcurrentHashMap in a racy manner </LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 retrieves the value of a key from a ConcurrentHashMap, where the value is itself a collection. It checks this
            value for null, and if it is so, creates a new collection and places it in the map. This may cause thread race conditions
            where two threads overwrite each other's values. You should be using
            <code>
                ConcurrentHashMap.putIfAbsent(K, V)
            </code>
            instead.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTWR_USE_TRY_WITH_RESOURCES">
        <ShortDescription>方法 manually handles closing an auto-closeable resource</ShortDescription>
        <LongDescription>方法 {1} manually handles closing an auto-closeable resource</LongDescription>
        <Details>
            <![CDATA[[
            <p>这个方法 allocates and uses an auto closeable resource. However, it manually closes the resource in a finally block.
            While this is correct management, it doesn't rely on the idiomatic way available to JDK 7 and above, allows for possible
            subtle problems, and complicates the reading of code by developers expecting the use of try-with-resources.
            </p>
            <p>Switch to using try with resources, as:
            <pre>
                try (InputStream is = getAStream()) {
                    useTheStream(is);
                }
            </pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SSCU_SUSPICIOUS_SHADED_CLASS_USE">
        <ShortDescription>方法 calls a method from a class that has been shaded by a 3rdparty jar</ShortDescription>
        <LongDescription>方法 {1} calls a method from a class that has been shaded by a 3rdparty jar</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls a method found in a 3rd-party library, which appears to be shaded from another 3rd-party library.
            This occurs when a jar includes other code that uses tools like the maven shade plugin. It is likely you wanted to use the
            "first-class" class from the original jar, rather than the class with the shaded package structure, but your IDE pulled in
            the wrong import.</p>
            <p>An example might be, you attempted to use a method from the class:
            <pre><code>
            com.google.common.collect.Sets
            </code></pre>
            But instead, you import:
            <pre><code>
            org.apache.jena.ext.com.google.common.collect.Sets
            </code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="USFW_UNSYNCHRONIZED_SINGLETON_FIELD_WRITES">
        <ShortDescription>方法 of Singleton class writes to a field in an unsynchronized manner</ShortDescription>
        <LongDescription>方法 {1} of Singleton class writes to a field in an unsynchronized manner</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 writes to a field of this class. Since this class is seen as a Singleton this can produce race
            conditions, or cause non-visible changes to other threads, because the field isn't accessed synchronously.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OI_OPTIONAL_ISSUES_USES_IMMEDIATE_EXECUTION">
        <ShortDescription>方法 uses immediate execution of a block of code that is often not used</ShortDescription>
        <LongDescription>方法 {1} uses immediate execution of a block of code that is often not used</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses the Optional.orElse() method passing in some code that will execute immediately, whether
            or not the else case of the Optional is needed. This may cause incorrect side effects to happen, or at the
            minimum, code to execute for no reason. It would be better to use Optional.orElseGet()
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OI_OPTIONAL_ISSUES_USES_DELAYED_EXECUTION">
        <ShortDescription>方法 uses delayed execution of a block of code that is trivial</ShortDescription>
        <LongDescription>方法 {1} uses immediate execution of a block of code that is trivial</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses the Optional.orElseGet() method passing in a simple variable or constant value.
            As this value takes no time to execute and causes no side effects, the use of Optional.orElseGet is
            unnecessary and potentially confusing. You can use Optional.orElse() instead.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OI_OPTIONAL_ISSUES_CHECKING_REFERENCE">
        <ShortDescription>方法 checks an Optional reference for null</ShortDescription>
        <LongDescription>方法 {1} checks an Optional reference for null</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 compares an Optional reference variable against null. As the whole point of the
            Optional class is to avoid the null pointer exception, this use pattern is highly suspect.
            The code should always make sure the Optional reference is valid, and should count on the APIs
            of this class to check for the held reference instead.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OI_OPTIONAL_ISSUES_PRIMITIVE_VARIANT_PREFERRED">
        <ShortDescription>方法 uses a java.util.Optional when use of OptionalInt, OptionalLong, OptionalDouble would be more clear</ShortDescription>
        <LongDescription>方法 {1} uses a java.util.Optional when use of OptionalInt, OptionalLong, OptionalDouble would be more clear</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 creates an Optional object to hold an int, double or long. In these cases it
            is more natural to use the Optional variants OptionalInt, OptionalDouble and OptionalLong.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OI_OPTIONAL_ISSUES_USES_ORELSEGET_WITH_NULL">
        <ShortDescription>方法 uses Optional.orElseGet(null)</ShortDescription>
        <LongDescription>方法 {1} uses Optional.orElseGet(null)</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses Optional.orElseGet(null). This method is supposed to to receive a lambda expression for what to execute
            when the Optional is not there. If you want to just return null, use Optional.orElse(null) instead.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UAC_UNNECESSARY_API_CONVERSION_DATE_TO_INSTANT">
        <ShortDescription>方法 constructs a Date object, merely to convert it to an Instant object</ShortDescription>
        <LongDescription>方法 {1} constructs a Date object, merely to convert it to an Instant object</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 creates a java.time.Instant object by first creating a java.util.Date object, and then calling
            toInstant() on it. It is simpler to just construct the Instant object directly, say by using
            {@code Instant.now()} to get the current time, of by using {@code Instant.parse(CharSequence)} to convert a String.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UAC_UNNECESSARY_API_CONVERSION_FILE_TO_PATH">
        <ShortDescription>方法 constructs a File object, merely to convert it to a Path object</ShortDescription>
        <LongDescription>方法 {1} constructs a File object, merely to convert it to a Path object</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 creates a java.nio.file.Path object by first creating a java.io.File object, and then calling
            toPath() on it. It is simpler to just construct the Path object directly, say by using
            {@code Paths.get(String...)}.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="RFI_SET_ACCESSIBLE">
        <ShortDescription>方法 uses AccessibleObject.setAccessible to modify accessibility of classes</ShortDescription>
        <LongDescription>方法 {1} uses AccessibleObject.setAccessible to modify accessibility of classes</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 uses the reflective setAccessible method to alter the behavior of methods and fields in classes
            in ways that were not expected to be accessed by the author. Doing so circumvents the protections that the author
            provided through the class definition, and may expose your application to unexpected side effects and problems. This
            functionality is deprecated in Java 9, and in Java 10 it is expected that this functionality won't work at all.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AI_ANNOTATION_ISSUES_NEEDS_NULLABLE">
        <ShortDescription>方法 that can return null, is missing a @Nullable annotation</ShortDescription>
        <LongDescription>方法 {1} that can return null, is missing a @Nullable annotation</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 can return null, but is not annotated with an @Nullable annotation. Without this annotation,
            various IDEs, and static analysis tools may not be able to fully discover possible NullPointerExceptions in
            your code. By adding these annotations, you will discover problems around null-ness, more easily.</p>
            <p>Unfortunately there isn't just one @Nullable annotation, but this detector will recognize:</p>
            <ul>
            <li>org.jetbrains.annotations.Nullable</li>
            <li>javax.annotation.Nullable</li>
            <li>javax.annotation.CheckForNull</li>
            <li>edu.umd.cs.findbugs.annotations.Nullable</li>
            <li>org.springframework.lang.Nullable</li>
            <li>android.support.annotations.Nullable</li>
            </ul>
            <p>
            You can supply a comma separated list of classes that are custom Nullable Annotations if you desire, by using the
            system property -Dfb-contrib.ai.annotations="com.acme.Foo,com.acme.Boo" when run.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUI_CALLING_SIZE_ON_SUBCONTAINER">
        <ShortDescription>方法 calls size() on a sub collection of a Map</ShortDescription>
        <LongDescription>方法 {1} calls size() on a sub collection of a Map</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls <code>size</code> on the keySet(), entrySet() or values() collections of a Map. These sub collections
            will have the same size as the base Map and so it is just simpler to call size on that Map. Calling size() on
            one of these sub collections will causes unnecessary allocations to occur.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUI_CONTAINSKEY_BEFORE_GET">
        <ShortDescription>方法 check a map with containsKey(), before using get()</ShortDescription>
        <LongDescription>方法 {1} checks a map with containsKey(), before using get()</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 checks for the presence of a key in a map using containsKey(), before attempting to fetch the value of the key
            using get(). This equates to doing two map lookups in a row. It is much simpler to just fetch the value with get, and checking
            for non null instead.</p>
            <p>As an example, instead of using
            <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                if (myMap.containsKey("foo")) {
                    String value = myMap.get("foo");
                    ....
                }
            </pre>
            </code>
            convert this to
            <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                String value = myMap.get("foo");
                if (value != null) {
                    ....
                }
            </pre>
            </code>
            </p>
            <p>The only caveat to this is that if you use a null value in a map to represent a third state for the key, then in this case
            using containsKey is 'correct'. This means an entry found in the map with a null value is taken differently than no entry
            at all. However, this is a very subtle programming paradigm, and likely to cause problems. If you wish to mark an entry as
            not being present, it is better to use a named 'sentinel' value to denote this, so instead of:
            <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                if (myMap.containsKey("foo")) {
                    String value = myMap.get("foo");
                    ....
                }
            </pre>
            </code>
            convert this to
            <code>
            <pre>
                 Map<String, String> myMap = getSomeMap();
                 String value = myMap.get("foo");
                if (NOT_FOUND.equals(value)) {
                    ....
                }
                where NOT_FOUND is some constant that denotes this special status. Of course you will need to find a special
                sentinel value for each type you are using that isn't possible to have normally.
            </pre>
            </code>
            </p>
            ]]>
        </Details>
    </BugPattern>

     <BugPattern type="MUI_GET_BEFORE_REMOVE">
        <ShortDescription>方法 gets an item from a map with get(), before using remove()</ShortDescription>
        <LongDescription>方法 {1} gets an item from a map with get(), before using remove()</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 fetches the value of an entry in a map using get(K k), and then follows it up with a remove(K k).
            Since a remove() also returns the value, there is no point for doing the get, and just causes two map lookups
            to occur when it can be done with just one.</p>
            <p>As an example, instead of using
            <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                String v = myMap.get("foo")) {
                myMap.remove("foo");
            </pre>
            </code>
            convert this to
            <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                String v = myMap.remove("foo");
            </pre>
            </code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LUI_USE_SINGLETON_LIST">
        <ShortDescription>方法 builds a list from one element using Arrays.asList</ShortDescription>
        <LongDescription>方法 {1} builds a list from one element using Arrays.asList rather than Collections.singletonList</LongDescription>
        <Details>
        <![CDATA[
        <p>这个方法 builds a list using Arrays.asList(foo), passing in a single element. Arrays.asList needs to first create an array from this one
        element, and then build a List that wraps this array. It is simpler to use Collections.singletonList(foo), which does not create the array, and
        produces a far simpler instance of List. Since both of these arrays are immutable (from the List's point of view) they are equivalent from a usage
        standpoint.
        </p>
        <p>There is one difference between Array.asList and Collections.singletonList that you should be mindful of. The rarely used set(index, value) method is
        allowed to be used with a List created by Array.asList, but not with Collections.singletonList. So if you do use the set(index, value) method
        continue using Arrays.asList.
        ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LUI_USE_GET0">
        <ShortDescription>方法 uses collection streaming to get first item in a List</ShortDescription>
        <LongDescription>方法 {1} uses collection streaming to get first item in a List</LongDescription>
        <Details>
        <![CDATA[
        <p>这个方法 fetches the first item in a List using collection streaming. As a list is already ordered
        there is no need to do that, just use the regular get(0) interface.<br/>
        Example:
        <code><pre>
        String s = myList.stream().findFirst().get();
        </pre></code>
        Can be more simply done using
        <code><pre>
        String s = myList.get(0);
        </pre></code>
        </p>
        ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LUI_USE_COLLECTION_ADD">
        <ShortDescription>方法 passes a temporary one item list to Collection.addAll()</ShortDescription>
        <LongDescription>方法 {1} passes a temporary one item list to Collection.addAll()</LongDescription>
        <Details>
        <![CDATA[
        <p>这个方法 creates a temporary list using Collections.singletonList, or Arrays.asList with one
        element in it, and then turns around and calls the addAll() method on another collection. Since you
        are only adding one element to the collection, it is simpler to just call the add(object) method on
        the collection you are using and by pass creating the intermediate List.</p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_AVOID_CONTAINS_ON_COLLECTED_STREAM">
        <ShortDescription>方法 calls contains() on a collected lambda expression</ShortDescription>
        <LongDescription>方法 {1} calls contains() on a collected lambda expresssion</LongDescription>
        <Details>
        <![CDATA[
        <p>这个方法 builds a collection using lambda expressions with a collect terminal operation. It then immediately
        calls the contains() method on it, to see if an item is present. This is sub optimal as the lambda still needs to 
        build the entire collection, iterating the entire source list. It is better to use anyMatch() to short
        circuit the building of the collection.
        </p>
        <p>
        Instead of
        <code><pre>
        baubles.stream().map(Bauble::getName).collect(Collectors.toSet()).contains(name)
        </pre></code>
        do
        <code></pre>
        baubles.stream().anyMatch(b -> name.equals(b.getName()))
        </pre></code>
        </p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_USE_METHOD_REFERENCE">
        <ShortDescription>方法 creates an anonymous lambda expression instead of specifying a method reference</ShortDescription>
        <LongDescription>方法 {1} creates an anonymous lamda expression instead of specifying a method reference</LongDescription>
        <Details>
        <![CDATA[
        <p>这个方法 defines an anonymous lambda function to be called to fetch a single value from the passed in value. While
        this will work, it is needlessly complex as this function merely calls a single getter method on the object, and thus
        the code can be simplied by just passing in a method reference instead.</p>
        <p>
        Instead of
        <code><pre>
        baubles.stream().map(b -> b.getName()).collect(Collectors.toSet())
        </pre></code>
        do
        <code></pre>
        baubles.stream().map(Bauble::getName).collect(Collectors.toSet())
        </pre></code>
        </p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_USE_ANY_MATCH">
        <ShortDescription>方法 suboptimally finds any match in a stream</ShortDescription>
        <LongDescription>方法 {1} suboptimally finds any match in a stream</LongDescription>
        <Details>
        <![CDATA[
        <p>这个方法 looks for one item in a stream using filter().findFirst.isPresent() when .anyMatch() will do the same thing more succintly</p>
        ]]></Details>
    </BugPattern>
    
    <BugPattern type="FII_USE_FIND_FIRST">
        <ShortDescription>方法 collects a List from a stream() just to get the first element</ShortDescription>
        <LongDescription>方法 {1} collects a List from a stream() just to get the first element</LongDescription>
        <Details>
        <![CDATA[
        <p>这个方法 streams data into a List just to call get(0) to get the first item. You can just use findFirst() to short circuit the
        processing of the stream.</p>
        <p>
        Instead of
        <code><pre>
        baubles.stream().collect(Collectors.toList()).get(0)
        </pre></code>
        do
        <code></pre>
        baubles.stream().findFirst().get())
        </pre></code>
        </p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_COMBINE_FILTERS">
        <ShortDescription>方法 implements a stream using back to back filters</ShortDescription>
        <LongDescription>方法 {1} implements a stream using back to back filters</LongDescription>
        <Details>
        <![CDATA[
        <p>这个方法 streams data using more than one filter back to back. These can just be combined into one filter</p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_USE_FUNCTION_IDENTITY">
        <ShortDescription>方法 declares an identity lambda function rather than using Function.identity()</ShortDescription>
        <LongDescription>方法 {1} declares an identity lambda function rather than using Function.identity()</LongDescription>
        <Details>
        <![CDATA[
            <p>这个方法 declares a no-op (identity) lambda method rather than just specifying Function.identity()</p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_AVOID_SIZE_ON_COLLECTED_STREAM">
        <ShortDescription>方法 calls size() on a collected lambda expression</ShortDescription>
        <LongDescription>方法 {1} calls size() on a collected lambda expresssion</LongDescription>
        <Details>
        <![CDATA[
        <p>这个方法 builds a collection using lambda expressions with a collect terminal operation. It then immediately
        calls the size() method on it, to get a count of items. This is sub optimal as the lambda still needs to 
        build the entire collection, iterating the entire source list. It is better to use count() predicate to short
        circuit the building of the collection. If you were using a Set, then also add the distinct() predicate.
        </p>
        <p>
        Instead of
        <code><pre>
        baubles.stream().filter(b -> b.getName("orb")).collect(Collectors.toList()).size())
        </pre></code>
        do
        <code></pre>
        baubles.stream().filter(b -> b.getName("orb")).count()
        </pre></code>
        or for sets you can use
        <code></pre>
        baubles.stream().filter(b -> b.getName("orb")).distinct().count()
        </pre></code>
        </p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="SUI_CONTAINS_BEFORE_ADD">
        <ShortDescription>方法 checks for an item in a set with contains, before using add()</ShortDescription>
        <LongDescription>方法 {1} checks for an item in a set with contains, before using add()</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 checks to see if an element is not in a set before adding it. This is unnecessary as you can just
            add the item, and if the item exists, it won't add it, otherwise it will.</p>
            <p>As an example, instead of using
            <code>
            <pre>
                Set<String> mySet = getSomeSet();
                if (!mySet.contains("foo")) {
                    mySet.add("foo");
                }
            </pre>
            </code>
            convert this to
            <code>
            <pre>
                Set<String> mySet = getSomeSet();
                if (mySet.add("foo")) {
                }
            </pre>
            </code>
            </p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="SUI_CONTAINS_BEFORE_REMOVE">
        <ShortDescription>方法 checks for an item in a set with contains, before using remove()</ShortDescription>
        <LongDescription>方法 {1} checks for an item in a set with contains, before using remove()</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 checks to see if an element is in a set before removing it. This is unnecessary as you can just
            remove the item, and if the item exists, it will return true.</p>
            <p>As an example, instead of using
            <code>
            <pre>
                Set<String> mySet = getSomeSet();
                if (mySet.contains("foo")) {
                    mySet.remove("foo");
                }
            </pre>
            </code>
            convert this to
            <code>
            <pre>
                Set<String> mySet = getSomeSet();
                if (mySet.remove("foo")) {
                }
            </pre>
            </code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SAT_SUSPICIOUS_ARGUMENT_TYPES">
        <ShortDescription>方法 invokes a method with parameters that seem incorrect for their intended use</ShortDescription>
        <LongDescription>方法 {1} invokes a method with parameters that seem incorrect for their intended use</LongDescription>
        <Details>
            <![CDATA[
            <p>这个方法 calls a method passing arguments that seem incorrect for the intended purpose of the method. Make sure that the argument types are valid</p>
            <ul>
            <li><p>For Match.hasEntry it seems unlikely you want to pass a Matcher and non-Matcher at the same time</p></li>
            </ul>
            ]]>
        </Details> 
    </BugPattern>

    <!-- BugCode -->

    <BugCode abbrev="ISB">Inefficient String Buffering</BugCode>
    <BugCode abbrev="SCI">Synchronized Collection Iterators</BugCode>
    <BugCode abbrev="CC">Cyclomatic Complexity</BugCode>
    <BugCode abbrev="OCP">Overly Concrete Parameters</BugCode>
    <BugCode abbrev="LII">List Indexed Iterating</BugCode>
    <BugCode abbrev="UCC">Unrelated Collection Contents</BugCode>
    <BugCode abbrev="DRE">Declared Runtime Exception</BugCode>
    <BugCode abbrev="CE">Class Envy</BugCode>
    <BugCode abbrev="LSC">Literal String Comparison</BugCode>
    <BugCode abbrev="PCOA">Partially Constructed Object Access</BugCode>
    <BugCode abbrev="DLC">Dubious List Collection</BugCode>
    <BugCode abbrev="PL">Parallel Lists</BugCode>
    <BugCode abbrev="FP">Final Parameters</BugCode>
    <BugCode abbrev="ACEM">Abstract Class Empty Methods</BugCode>
    <BugCode abbrev="MAC">Manual Array Copy</BugCode>
    <BugCode abbrev="FPL">Floating Point Loops</BugCode>
    <BugCode abbrev="NCMU">Non Collection Method Use</BugCode>
    <BugCode abbrev="CAO">Confusing Autoboxed Overloading</BugCode>
    <BugCode abbrev="AFBR">Abnormal Finally Block Return</BugCode>
    <BugCode abbrev="SMII">Static Method Instance Invocation</BugCode>
    <BugCode abbrev="STS">Spurious Thread States</BugCode>
    <BugCode abbrev="NAB">Needless Autoboxing</BugCode>
    <BugCode abbrev="USBR">Unnecessary Store Before Return</BugCode>
    <BugCode abbrev="COM">Copied Overridden Method</BugCode>
    <BugCode abbrev="ABC">Array Based Collection</BugCode>
    <BugCode abbrev="ODN">Orphaned DOM Node</BugCode>
    <BugCode abbrev="AOM">Abstract Overridden Method</BugCode>
    <BugCode abbrev="CBX">Custom Built XML</BugCode>
    <BugCode abbrev="BSB">Bloated Synchronized Block</BugCode>
    <BugCode abbrev="CLI">Constant List Index</BugCode>
    <BugCode abbrev="SCR">Sloppy Class Reflection</BugCode>
    <BugCode abbrev="AWCBR">Array Wrapped Call By Reference</BugCode>
    <BugCode abbrev="SG">Sluggish GUI</BugCode>
    <BugCode abbrev="NIR">Needless Instance Retrieval</BugCode>
    <BugCode abbrev="DDC">Double Date comparison</BugCode>
    <BugCode abbrev="SWCO">Suspicious Wait on Concurrent Object</BugCode>
    <BugCode abbrev="JVR">JDBC Vendor Reliance</BugCode>
    <BugCode abbrev="PMB">Possible Memory Bloat</BugCode>
    <BugCode abbrev="LSYC">Local Synchronized Collection</BugCode>
    <BugCode abbrev="FCBL">Field Could Be Local</BugCode>
    <BugCode abbrev="NOS">Non Owned Synchronization</BugCode>
    <BugCode abbrev="NRTL">Non Recycleable Taglib</BugCode>
    <BugCode abbrev="S508C">Section 508 Compliance Violations</BugCode>
    <BugCode abbrev="UEC">Use Enum Collections</BugCode>
    <BugCode abbrev="SIL">SQL In Loop</BugCode>
    <BugCode abbrev="NMCS">Needless Member Collection Synchronization</BugCode>
    <BugCode abbrev="ITC">Inheritance Type Checking</BugCode>
    <BugCode abbrev="SACM">Static Array Created in Method</BugCode>
    <BugCode abbrev="PRMC">Possibly Redundant Method Calls</BugCode>
    <BugCode abbrev="UTA">Use toArray</BugCode>
    <BugCode abbrev="LEST">Lost Exception Stack Trace</BugCode>
    <BugCode abbrev="UCPM">Use Character Parameterized Method</BugCode>
    <BugCode abbrev="TR">Tail Recursion</BugCode>
    <BugCode abbrev="URV">Unrelated Return Values</BugCode>
    <BugCode abbrev="PIS">Possible Incomplete Serialization</BugCode>
    <BugCode abbrev="SCRV">Suspicious Comparator Return Values</BugCode>
    <BugCode abbrev="SPP">Sillyness Pot Pourri</BugCode>
    <BugCode abbrev="BAS">Bloated Assignment Scope</BugCode>
    <BugCode abbrev="SCII">Spoiled Child Interface Implementor</BugCode>
    <BugCode abbrev="DWI">Deleting While Iterating</BugCode>
    <BugCode abbrev="USS">Use String Split</BugCode>
    <BugCode abbrev="SJVU">Suspicious JDK Version Use</BugCode>
    <BugCode abbrev="UAA">Use Add All</BugCode>
    <BugCode abbrev="MRC">Method Returns Constant</BugCode>
    <BugCode abbrev="NCS">Needless Custom Serialization</BugCode>
    <BugCode abbrev="MOM">Misleading Overload Model</BugCode>
    <BugCode abbrev="EXS">Exception Softening</BugCode>
    <BugCode abbrev="CFS">Confusing Function Semantics</BugCode>
    <BugCode abbrev="UTAO">Unit Test Assertion Oddities</BugCode>
    <BugCode abbrev="SCA">Suspicious Clone Algorithm</BugCode>
    <BugCode abbrev="WEM">Weak Exception Messaging</BugCode>
    <BugCode abbrev="SCSS">Suspicious Clustered Session Support</BugCode>
    <BugCode abbrev="LO">Logger Oddities</BugCode>
    <BugCode abbrev="IICU">Incorrect Internal Class use</BugCode>
    <BugCode abbrev="DSOC">Dubious Set of Collections</BugCode>
    <BugCode abbrev="BED">Bogus Exception Declaration</BugCode>
    <BugCode abbrev="UNNC">Unnecessary New Null Check</BugCode>
    <BugCode abbrev="DTEP">Deprecated Typesafe Enum Pattern</BugCode>
    <BugCode abbrev="TBP">Tristate Boolean Pattern</BugCode>
    <BugCode abbrev="SUA">Suspicious Uninitialized Array</BugCode>
    <BugCode abbrev="ITU">Inappropriate toString Use</BugCode>
    <BugCode abbrev="IKNC">Inconsistent Key Name Casing</BugCode>
    <BugCode abbrev="OC">Overzealous Casting</BugCode>
    <BugCode abbrev="PDP">Poorly Defined Parameter</BugCode>
    <BugCode abbrev="NSE">Non Symmetric Equals</BugCode>
    <BugCode abbrev="CVAA">Contravariant Array Assignment</BugCode>
    <BugCode abbrev="NFF">Non Functional Field</BugCode>
    <BugCode abbrev="SNG">Suspicious Null Guard</BugCode>
    <BugCode abbrev="MDM">More Dumb Methods</BugCode>
    <BugCode abbrev="ROOM">Reflection on Object Methods</BugCode>
    <BugCode abbrev="IPU">Improper Properties use</BugCode>
    <BugCode abbrev="PCAIL">Possible Constant Allocation In Loop</BugCode>
    <BugCode abbrev="WOC">Write Only Collection</BugCode>
    <BugCode abbrev="UVA">Use Var Args</BugCode>
    <BugCode abbrev="PUS">Possible Unsuspected Serialization</BugCode>
    <BugCode abbrev="SEC">Side Effect Constructor</BugCode>
    <BugCode abbrev="SGSU">Suspicious Getter Setter Use</BugCode>
    <BugCode abbrev="LGO">Lingering Graphics Object</BugCode>
    <BugCode abbrev="STB">Stacked Try Blocks</BugCode>
    <BugCode abbrev="CEBE">Commons EqualsBuilder To Equals</BugCode>
    <BugCode abbrev="CHTH">Commons HashCodeBuilder To hashCode</BugCode>
    <BugCode abbrev="CSBTS">Commons ToStringBuilder To String</BugCode>
    <BugCode abbrev="CCNE">Compare class name equals</BugCode>
    <BugCode abbrev="BRPI">Backport concurrent reuse of public identifiers</BugCode>
    <BugCode abbrev="CU">Clone Usability</BugCode>
    <BugCode abbrev="CAAL">Confusing Array asList</BugCode>
    <BugCode abbrev="PSC">Presize Collection</BugCode>
    <BugCode abbrev="UMTP">Unbound Method Template Parameter</BugCode>
    <BugCode abbrev="NPMC">Non Productive Method Call</BugCode>
    <BugCode abbrev="AIOB">Array Index Out of Bounds</BugCode>
    <BugCode abbrev="ICA">Invalid Constant Argument</BugCode>
    <BugCode abbrev="CNC">Collection Naming Confusion</BugCode>
    <BugCode abbrev="PME">Poor Mans Enum</BugCode>
    <BugCode abbrev="UP">Unused Parameter</BugCode>
    <BugCode abbrev="FCCD">Find Class Circular Dependencies</BugCode>
    <BugCode abbrev="MUC">Modifying Unmodifiable Collection</BugCode>
    <BugCode abbrev="UJM">Unjitable method</BugCode>
    <BugCode abbrev="HES">Hanging ExecutorService</BugCode>
    <BugCode abbrev="HCP">HttpClient Problems</BugCode>
    <BugCode abbrev="CTU">Conflicting Time Units</BugCode>
    <BugCode abbrev="CSI">Charset Issues</BugCode>
    <BugCode abbrev="CBC">Contains Based Conditional</BugCode>
    <BugCode abbrev="OPM">Overly Permissive Method</BugCode>
    <BugCode abbrev="STT">Stringified Types</BugCode>
    <BugCode abbrev="SLS">Suspicious Loop Search</BugCode>
    <BugCode abbrev="CRF">Conflating Resources And Files</BugCode>
    <BugCode abbrev="IMC">Immature Class</BugCode>
    <BugCode abbrev="JXI">JAX-RS Issues</BugCode>
    <BugCode abbrev="JPAI">JPA Issues</BugCode>
    <BugCode abbrev="SEO">Suboptimal Expression Order</BugCode>
    <BugCode abbrev="IOI">IO Issues</BugCode>
    <BugCode abbrev="DMC">Dubious Map Collection</BugCode>
    <BugCode abbrev="BL">Burying Logic</BugCode>
    <BugCode abbrev="WI">Wiring issues</BugCode>
    <BugCode abbrev="CCI">Concurrent Collection Issues</BugCode>
    <BugCode abbrev="UTWR">Use Try With Resources</BugCode>
    <BugCode abbrev="SSCU">Suspicious Shaded Class Use</BugCode>
    <BugCode abbrev="USFW">Unsynchronized Singleton Field Writes</BugCode>
    <BugCode abbrev="OI">Optional Issues</BugCode>
    <BugCode abbrev="UAC">Unnecessary Api Conversion</BugCode>
    <BugCode abbrev="RFI">Reflection Issues</BugCode>
    <BugCode abbrev="AI">Annotation Issues</BugCode>
    <BugCode abbrev="MUI">Map Usage Issues</BugCode>
    <BugCode abbrev="LUI">List Usage Issues</BugCode>
    <BugCode abbrev="FII">FunctionalInterface Issues</BugCode>
    <BugCode abbrev="SUI">Set Usage Issues</BugCode>
    <BugCode abbrev="SAT">Suspicious Argument Types</BugCode>
</MessageCollection>

<?xml version="1.0" encoding="UTF-8"?>

<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="messagecollection.xsd">

    <Plugin>
        <ShortDescription>fb-contrib plugin</ShortDescription>
        <Details>
            <![CDATA[
            <p>This plugin contains FindBugs detectors from the fb-contrib project</p>
            ]]>
        </Details>
        <BugsUrl>http://fb-contrib.sourceforge.net/bugdescriptions.html</BugsUrl>
        <AllBugsUrl>http://fb-contrib.sourceforge.net/bugdescriptions.html</AllBugsUrl>
    </Plugin>

    <!-- Detectors -->

    <Detector class="com.mebigfatguy.fbcontrib.collect.CollectStatistics">
        <Details>
            <![CDATA[
            <p>Collects statistics for other detectors</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.collect.CollectMethodsReturningImmutableCollections">
        <Details>
            <![CDATA[
            <p>Collects method calls that may return immutable collections</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.collect.CollectNullableMethodStatus">
        <Details>
            <![CDATA[
            <p>Collects method calls that can return null</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.InefficientStringBuffering">
        <Details>
            <![CDATA[
            <p>Looks for appending strings inside of calls to StringBuffer or StringBuilder append.</p>
            <pre>
                StringBuilder sb = new StringBuilder();
                sb.append(a + b);
                return sb.toString();
            </pre>
            You should use the .append method to append values
            <pre>
                sb.append(a).append(b);
            </pre>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SyncCollectionIterators">
        <Details>
            <![CDATA[
            <p>Looks for use of iterators on synchronized collections built from the java.util.Collections class.</p>
            <p>As the collection in question was built through Collections.synchronizedXXX, an assumption is made that this collection must be multithreading safe.
            However, iterator access is used, which is explicitly unsafe.
            When iterators are to be used, synchronization should be done manually.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CyclomaticComplexity">
        <Details>
            <![CDATA[
            <p>Calculates the McCabe Cyclomatic Complexity measure and reports methods that have an excessive value.
            This report value can be set with system property 'fb-contrib.cc.limit'.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.OverlyConcreteParameter">
        <Details>
            <![CDATA[
            <p>Looks for parameters that are defined by classes, but where the method only uses methods defined by an implemented interface or superclass of that class.
            Relying on concrete classes in public signatures causes cohesion, and makes low impact changes more difficult.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ListIndexedIterating">
        <Details>
            <![CDATA[
            <p>Looks for for loops that iterate over a java.util.List using an integer index, and get, rather than using an Iterator.
            An iterator may perform better depending on List implementation, but more importantly will allow the code to be converted to other collection types.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnrelatedCollectionContents">
        <Details>
            <![CDATA[
            <p>Looks for collections or arrays that hold objects that are unrelated through class or interface inheritance other than java.lang.Object.
            Doing so makes for brittle code, relying either on positional correspondence for type, or a reliance on instanceof to determine type.
            A better design usually can be had by creating a separate class, which defines the different types required, and adding an instance of that class to the collection, or array.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.RuntimeExceptionDeclared">
        <Details>
            <![CDATA[
            <p>Looks for methods that declare RuntimeExceptions in their throws clause.
            While doing so is not illegal, it may represent a misunderstanding as to the exception in question.
            If a RuntimeException is declared, it implies that this exception type is expected to happen, which if true should be handled in code, and not propagated. </p>
            <p>It is a fast detector.</p>
            <p>As an example, every method could be declared like this: 
            <code>
            public void foo() throws NullPointerException {
            }
            </code>
            But what does that tell you? 
	    Is this method very very likely to throw NullPointerExceptions?  
	    If it is, why isn't this method handling them so that exceptions aren't thrown? 
	    So don't do this.
            If an NPE is very likely, then check for it, and handle the situation.
            </p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ClassEnvy">
        <Details>
            <![CDATA[
            <p>Looks for methods that use a high percentage of methods from another class over their class' own methods.
            When this is the case, it is often better to implement this method in that other class, by refactoring the class to accept parameters it needs from the source class.
            The reporting percentage can be set with system property 'fb-contrib.ce.percent'.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.LiteralStringComparison">
        <Details>
            <![CDATA[
            <p>Looks for methods that compare strings against literal strings, where the literal string is passed as the parameter.
            If the .equals or .compareTo is called on the literal itself, passing the variable as the parameter, you avoid the possibility of a NullPointerException.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PartiallyConstructedObjectAccess">
        <Details>
            <![CDATA[
            <p>Looks for constructors of non-final classes that make method calls to non-final methods.
            As these methods could be overridden, the overridden method will be accessing an object that is only partially constructed, perhaps causing problems.
            Making these called methods final is an easy fix, where possible.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DubiousListCollection">
        <Details>
            <![CDATA[
            <p>Looks for fields that are implementations of java.util.List, but that are used in a set-like fashion.
            Since lookup type operations are performed using a linear search for Lists, the performance for large Lists will be poor.
            Consideration should be made as to whether these fields should be sets.
            In the case that order is important, consider using LinkedHashSet.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ParallelLists">
        <Details>
            <![CDATA[
            <p>Looks for classes that maintain two or more lists or arrays associated one-for-one through the same index to hold two or more pieces of related information.
            It would be better to create a new class that holds all of these pieces of information, and place instances of this class in one list.
            Or if the two lists are related in key/value fashion, then use a map instead.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.FinalParameters">
        <Details>
            <![CDATA[
            <p>Looks for methods that correctly do not write to a parameter.
            To help document this, you should consider defining these parameters as final.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.AbstractClassEmptyMethods">
        <Details>
            <![CDATA[
            <p>Looks for abstract classes that define empty methods or methods that simply throw an exception.
            Since this is an abstract class, it may be cleaner to simply define this method as abstract, so that correct subclass behavior is enforced.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ManualArrayCopy">
        <Details>
            <![CDATA[
            <p>Looks for methods that copy data from one array to another using a loop.
            It is better performing to use System.arraycopy to do such copying as this is a native method.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.FloatingPointLoops">
        <Details>
            <![CDATA[
            <p>Looks for methods that use floating point indexes for loops.
            Since floating point math is imprecise, rounding errors will occur each time through the loop causing hard-to-find problems.
            It is usually better to use integer indexing, and calculate the correct floating point value from the index.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonCollectionMethodUse">
        <Details>
            <![CDATA[
            <p>Looks for method calls to collection classes where the method is not defined by the Collections interface, and an equivalent method exists in the interface.
            Examples include:<br/>
            <table border="1">
                <tr><th>Old Method</th><th>New Method</th></tr>
                <tr><td>Hashtable.contains</td><td>Map.containsValue</td></tr>
                <tr><td>Hashtable.elements</td><td>Map.elements</td></tr>
                <tr><td>Hashtable.keys</td><td>Map.keySet</td></tr>
                <tr><td>Vector.addElement</td><td>List.add</td></tr>
                <tr><td>Vector.elementAt</td><td>List.get</td></tr>
                <tr><td>Vector.insertElementAt</td><td>List.add</td></tr>
                <tr><td>Vector.removeAllElements</td><td>List.clear</td></tr>
                <tr><td>Vector.removeElement</td><td>List.remove</td></tr>
                <tr><td>Vector.removeElementAt</td><td>List.remove</td></tr>
                <tr><td>Vector.setElementAt</td><td>List.set</td></tr>
            </table>
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingAutoboxedOverloading">
        <Details>
            <![CDATA[
            <p>Looks for methods that have the same signature, except where one uses a Character parameter, and the other uses an int, long, float, double parameter.
            Since autoboxing is available in 1.5 one might assume that 
<pre><code>
test('a')
</code></pre>
            would map to
<pre><code>
public void test(Character c)
</code></pre>
            but it instead maps to one that takes an int, long, float or double, such as
<pre><code>
public void test(int i)
</code></pre>
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.AbnormalFinallyBlockReturn">
        <Details>
            <![CDATA[
            <p>Looks for methods that have finally blocks that return values or throw exceptions.
            This code will swallow normal program flow and hide real program logic.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.StaticMethodInstanceInvocation">
        <Details>
            <![CDATA[
            <p>Looks for methods that make static method calls using an instance reference.
            For documentation purposes, it is better to call the method using the class name.
            This may represent a change in definition that should be noticed.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SpuriousThreadStates">
        <Details>
            <![CDATA[
            <p>Looks for methods that call wait, notify or notifyAll on an instance of a java.lang.Thread.
            Since the internal workings of the threads is to synchronize on the thread itself, introducing client calls will confuse the thread state of the object in question, and will cause spurious thread state changes, either waking threads up when not intended, or removing the thread from the runnable state.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessAutoboxing">
        <Details>
            <![CDATA[
            <p>Looks for methods that pass a primitive wrapper class object to the same class' Constructor.
            Patterns found are: 
            <ul>
                <li>new Boolean(Boolean)</li>
                <li>new Byte(Byte)</li>
                <li>new Character(Character)</li>
                <li>new Short(Short)</li>
                <li>new Integer(Integer)</li>
                <li>new Long(Long)</li>
                <li>new Float(Float)</li>
                <li>new Double(Double)</li>
            </ul>
            Since primitive wrapper classes are immutable this is needless garbage being created.
            Just use the original reference.
            </p>
            <p>It also looks for calls to BoxedClass.valueOf(x) where X is already a BoxedClass</p>
            <p>It also looks for calls to BoxedClass.valueOf(myString).boxedValue(), when instead it is simpler to use BoxedClass.parseBoxed(myString)</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryStoreBeforeReturn">
        <Details>
            <![CDATA[
            <p>Looks for methods that store the return result in a local variable and then immediately return that local variable.
            It is simpler to just return the method (or assignment) result directly.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CopiedOverriddenMethod">
        <Details>
            <![CDATA[
            <p>Looks for methods that are direct copies of the implementation in the superclass.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ArrayBasedCollections">
        <Details>
            <![CDATA[
            <p>Looks for methods that use arrays for items in the keySet of a map, or as an element of a set, or in a list when using the contains method.
            Since arrays do not, and cannot define an equals method, reference equality is used for these collections, which is probably not desired.
            If it is, consider using the IdentityHashMap class when using Maps in this case, to better document your intentions.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.OrphanedDOMNode">
        <Details>
            <![CDATA[
            <p>Looks for methods that create DOM nodes but do not add them to any DOM Document.
            Either the node needed to be added to the tree, or the node likely was created in error.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.AbstractOverriddenMethod">
        <Details>
            <![CDATA[
            <p>Looks for methods that are declared as abstract that override concrete methods in a superclass.
            Doing this casts away the implementation of the superclass, and breaks the contract as set forth by the parent class.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CustomBuiltXML">
        <Details>
            <![CDATA[
            <p>Looks for methods that build XML based strings by concatenating strings and custom values together.
            Doing so makes brittle code, that is difficult to modify, validate and understand.
            It is cleaner to create external XML files that are transformed at runtime, using parameters set through Transformer.setParameter.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.BloatedSynchronizedBlock">
        <Details>
            <![CDATA[
            <p>Looks for methods that are implemented using synchronized blocks, but are overly synchronized because the beginning of the block only accesses local variables, and not member variables, or this.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConstantListIndex">
        <Details>
            <![CDATA[
            <p>Looks for methods that access arrays or classes that implement java.util.List using a constant integer for the index.
            This is often a typo intended to be a loop variable, but if specific indices mean certain things, perhaps a first class object would be a better choice for a container, or even a map with informative key names would be better.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SloppyClassReflection">
        <Details>
            <![CDATA[
            <p>Looks for methods that use Class.forName("XXX") to load a class object for a class that is already referenced by this class.
            It is simpler to just use XXX.class, and doing so protects the integrity of this code from such transformations as obfuscation.
            Use of Class.forName should only be used when the class in question isn't already statically bound to this context.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ArrayWrappedCallByReference">
        <Details>
            <![CDATA[
            <p>Looks for methods that use an array of length one to pass a variable to achieve call by pointer ala C++.
            It is better to define a proper return class type that holds all the relevant information retrieved from the called method.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SluggishGui">
        <Details>
            <![CDATA[
            <p>Looks for methods that implement AWT or Swing listeners and perform time consuming operations.
            Doing these operations in the GUI thread will cause the interface to appear sluggish and non-responsive to the user.
            It is better to use a separate thread to do the time consuming work so that the user has a better experience.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessInstanceRetrieval">
        <Details>
            <![CDATA[
            <p>Looks for methods that call a method to retrieve a reference to an object, to use to load a constant.
            It is simpler and more performant to access the static variable directly from the class itself.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DateComparison">
        <Details>
            <![CDATA[
            <p>Looks for inefficient comparison of Date objects using two comparisons when one would do.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousWaitOnConcurrentObject">
        <Details>
            <![CDATA[
            <p>Looks for calls to the wait method on mutexes defined in the java.util.concurrent package where it is likely that await was intended.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.JDBCVendorReliance">
        <Details>
            <![CDATA[
            <p>Looks for uses of JDBC vendor specific classes and methods making the database access code non-portable.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PossibleMemoryBloat">
        <Details>
            <![CDATA[
            <p>Looks for classes that have usage patterns that may cause memory bloat to occur.
            This can occur with classes maintain collections or StringBuffer/StringBuilders in static member variables, and that do not appear to provide a way to clear or remove items from these members.
            Other cases are use of JAXBContexts stored recreated over and over again, instead of using a cached instance.
            Such class fields are likely causes of memory bloat.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.LocalSynchronizedCollection">
        <Details>
            <![CDATA[
            <p>Looks for allocations of synchronized collections that are stored in local variables, and never stored in fields or returned from methods.
            As local variables are by definition thread safe, using synchronized collections in this context makes no sense.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.FieldCouldBeLocal">
        <Details>
            <![CDATA[
            <p>Looks for classes that define fields that are used in a local-only fashion, specifically private fields that are accessed first in each method with a store vs. a load.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonOwnedSynchronization">
        <Details>
            <![CDATA[
            <p>Looks for methods that synchronize on variables that are not owned by the current class.
            Doing this causes confusion when two classes use the same variable for their own synchronization purposes.
            For cleanest separation of interests, only synchronize on private fields of the class.
            Note that 'this' is not owned by the current class and synchronization on 'this' should be avoided as well.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonRecycleableTaglibs">
        <Details>
            <![CDATA[
            <p>Looks for tag libraries that are not recycleable because backing members of taglib attributes are set in areas besides the setter method for the attribute.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.Section508Compliance">
        <Details>
            <![CDATA[
            <p>Looks for violation of Section 508, Accessibility for People with Disabilities Act.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseEnumCollections">
        <Details>
            <![CDATA[
            <p>Looks for use of sets and maps using enums.
            It is more efficient to use EnumSet or EnumMap.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SQLInLoop">
        <Details>
            <![CDATA[
            <p>Looks for the execution of SQL queries inside a loop.
            This pattern tends to be inefficient, and often can be improved upon, by collecting all the keys needed for the query and issuing just one query using an in clause with all the keys for all the queries previously needed in the loop.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessMemberCollectionSynchronization">
        <Details>
            <![CDATA[
            <p>Looks for classes that define private synchronized collections as static or instance members, that are only altered in a static initializer or constructor.
            Since the multithreaded use of this collection is read-only, the use of synchronization is unnecessary.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.InheritanceTypeChecking">
        <Details>
            <![CDATA[
            <p>Looks for if/else blocks where a series of them use instanceof on the same variable to determine what to do.
            If these classes are related by inheritance, this often is better handled through calling a single overridden method.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.StaticArrayCreatedInMethod">
        <Details>
            <![CDATA[
            <p>Looks for creation of arrays in methods using constant values.
            These arrays will need to be recreated each time the method is called.
            These arrays should probably be defined as static fields, instead.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PossiblyRedundantMethodCalls">
        <Details>
            <![CDATA[
            <p>Looks for calls of the same method on the same object when that object hasn't changed.
            This often is redundant, and the second call can be removed, or combined.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseToArray">
        <Details>
            <![CDATA[
            <p>Looks for code that builds an array of values from a collection, by manually looping over the elements of the collection, and adding them to the array.
            It is simpler and cleaner to use mycollection.toArray(new type[mycollection.size()]).</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.LostExceptionStackTrace">
        <Details>
            <![CDATA[
            <p>Looks for methods that catch exceptions, and then throw a different exception without embedding the original exception in the thrown one.
            Doing so, hides the real source of the exception, making debugging and fixing these problems difficult.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseCharacterParameterizedMethod">
        <Details>
            <![CDATA[
            <p>Looks for methods that pass single character string constants as parameters to methods that alternatively have an overridden method that accepts a character instead.
            It is easier for the method to handle a single character than a String.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.TailRecursion">
        <Details>
            <![CDATA[
            <p>Looks for methods that make recursive calls to themselves as the last statement in the method.
            This tail recursion could be converted into a simple loop which would improve the performance and stack requirements.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnrelatedReturnValues">
        <Details>
            <![CDATA[
            <p>Looks for methods that are defined to return Object, and return different types of objects based on different code paths.
            If this method is not based on an interface or superclass, it is suggested to change the return type to a type that would accommodate all kinds of return types.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PossibleIncompleteSerialization">
        <Details>
            <![CDATA[
            <p>Looks for classes that don't handle serialization of parent class member fields when the class in question is serializable but is derived from a non serializable class.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousComparatorReturnValues">
        <Details>
            <![CDATA[
            <p>Looks for classes that implement Comparator or Comparable, and whose compare or compareTo methods return constant values only, but that don't represent the three possible choices (a negative number, 0, and a positive number).</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SillynessPotPourri">
        <Details>
            <![CDATA[
            <p>Looks for a potpourri of small problems that do not fit into a common pattern.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.BloatedAssignmentScope">
        <Details>
            <![CDATA[
            <p><em>THIS DETECTOR IS HIGHLY EXPERIMENTAL AND IS LIKELY TO CREATE A LOT OF FUD</em></p>
            <p>Looks for assignments to variables in a scope larger than their use.
            As long as the evaluation of the assignment does not have side effects, the assignment can be moved into the inner scope where it is used.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SpoiledChildInterfaceImplementor">
        <Details>
            <![CDATA[
            <p>Looks for classes that implement interfaces by relying on methods being implemented in superclasses, even though the superclass knows nothing about the interface being implemented by the child.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DeletingWhileIterating">
        <Details>
            <![CDATA[
            <p>Looks for deletion of items from a collection using the remove method of the collection at the same time that the collection is being iterated on.
            If this occurs the iterator will become invalid and throw a ConcurrentModificationException.
            Instead, the remove should be called on the iterator itself.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseSplit">
        <Details>
            <![CDATA[
            <p>Looks for code that builds an array by using a StringTokenizer to break up a string and place individual elements into an array.
            It is simpler to use String.split instead.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousJDKVersionUse">
        <Details>
            <![CDATA[
            <p>Looks for calls to classes and methods that do not exist in the JDK for which this class is compiled.
            This can happen if you specify the <code>-source</code> and <code>-target</code> options of the javac compiler, and specify a target that is less than the JDK version of the javac compiler.</p>
            <p>It relies on the system property <code>-Dfb-contrib.sjvu.jdkhome=/path/to/older/jdk/to/check"</code> to specify what JDK to compare against.
            On linux, you may need to give file permissions to findbugs to read these directories.
            If this property is not set, this detector does nothing.</p>
            <p>It is a slow detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseAddAll">
        <Details>
            <![CDATA[
            <p>Looks for loops that transfer the contents of one collection to another.
            These collection sources might be local variables or member fields, including sets, maps key/values, lists, or arrays.
            It is simpler to just use the addAll method of the collection class.
            In the case where the source is an array, you can use Arrays.asList(array), and use that as the source to addAll.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.MethodReturnsConstant">
        <Details>
            <![CDATA[
            <p>Looks for private or static methods that only return one constant value.
            Since there is no chance for derived classes overriding this behavior, the return of a constant value seems dubious.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessCustomSerialization">
        <Details>
            <![CDATA[
            <p>Looks for classes that implement the Serializable interface and implement the standard readObject and writeObject methods by simply deferring to the Stream parameter's defaultReadObject or defaultWriteObject and nothing else.
            As this is the built in behavior, these methods are not needed.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.MisleadingOverloadModel">
        <Details>
            <![CDATA[
            <p>Looks for classes that define both static and instance methods with the same name.
            As each type represents a different use model, it doesn't make sense that this name would be overloaded, and will confuse users of the class.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ExceptionSoftening">
        <Details>
            <![CDATA[
            <p>Looks for methods that catch checked exceptions, and throw unchecked exceptions in their place.
            There are several levels of concern.
            Least concerning are methods constrained by interface or superclass contracts not to throw checked exceptions but appear owned by the same author.
            Next are methods constrained by interface or superclass contracts and throw other types of checked exceptions.
            Most egregious are methods not constrained by any interface or superclass contract.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingFunctionSemantics">
        <Details>
            <![CDATA[
            <p>Looks for methods that return a parameter after modifying that parameter.
            Doing this will confuse the user of this method, as it will be assumed that the passed in argument is different than the output, or at least won't be changed.
            If the purpose of this method is just to modify the parameter, this method should probably be changed to have a void return type.
            If you must return a variable, perhaps a clone of the parameter should be returned.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnitTestAssertionOddities">
        <Details>
            <![CDATA[
            <p>Looks for JUnit or TestNG test case methods that use assertions with odd parameters.
            Included in this is:
            <ul>
                <li>Passing a constant as the second (actual) parameter in a JUnit test</li>
                <li>Not using the three parameter version of asserts for doubles</li>
                <li>Passing true or false as the first parameter instead of using assertTrue, or assertFalse</li>
                <li>Using the assert keyword</li>
            </ul>
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousCloneAlgorithm">
        <Details>
            <![CDATA[
            <p>Looks for implementations of clone where an assignment is made to a field of the source object.
            It is likely that that store should have occurred on the cloned object, as the clone operation is almost always considered read only.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.WeakExceptionMessaging">
        <Details>
            <![CDATA[
            <p>Looks for exceptions that are thrown with static strings as messages.
            Using static strings doesn't differentiate one use of this method versus another, and so it may be difficult to determine how this exception occurred without showing context.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousClusteredSessionSupport">
        <Details>
            <![CDATA[
            <p>Looks for code that fetches a complex object from an HttpSession attribute, modifies the object, but does not call setAttribute again on this object.
            This will not inform the application server that this object has changed, and thus will not correctly replicate these changes across the cluster.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.LoggerOddities">
        <Details>
            <![CDATA[
            <p>Looks for odd patterns of use of Logger classes from either Log4j, Log4j2, SLF4J or Commons Logging.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.IncorrectInternalClassUse">
        <Details>
            <![CDATA[
            <p>Looks for classes that rely on internal classes in the various APIs or libraries.
            As these classes are not officially released from the API vendor, they are subject to change or removal, and thus, should not be counted on.</p>
            Packages that shouldn't be used are: 
            <ul>
                <li>sun.xxx</li>
                <li>org.apache.xerces.xxx</li>
                <li>org.apache.xalan.xxx</li>
            </ul>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DubiousSetOfCollections">
        <Details>
            <![CDATA[
            <p>Looks for sets or keySets of maps that contain other collections.
            As typically collections calculate their hashCode, equals and compareTo methods by iterating the collection and evaluating the same function on each item in the collection, this can be costly from a performance point of view.</p>
            <p>In addition, using a set, or keySet of a map, infers that you will be looking for items based on the value of a collection, which seems dubious at best.</p>
            <p>Finally, as collections are often modified, this may cause problems if the collection is modified, thus changing hashCodes, etc, while the collection is in the set.</p>
            <p>If you wish to keep a collection of collections, the outer collection should probably be a list to avoid these problems.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.BogusExceptionDeclaration">
        <Details>
            <![CDATA[
            <p>Looks for constructors, static methods and private methods that declare that they throw checked exceptions that the actual code never throws.
            Since these methods can't be overridden, there is no reason to add these exceptions to the method declaration.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryNewNullCheck">
        <Details>
            <![CDATA[
            <p>Looks for allocations of objects, and then immediately checking to see if the object is null, or non null.
            As the new operator is guaranteed to either succeed, or throw an exception, this null check is useless, and denotes a misunderstanding as to how the JVM works.
            You can remove this guard.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DeprecatedTypesafeEnumPattern">
        <Details>
            <![CDATA[
            <p>Looks for classes that appear to implement the old style type safe enum pattern that was used before Java added Enum support to the language.
            Since this class is compiled with Java 1.5 or later, it would be simpler to just use Java enums.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.TristateBooleanPattern">
        <Details>
            <![CDATA[
            <p>Looks for methods that are declared to return a Boolean, but return a null value.
            As this now allows the method to return three values, the use of Boolean is dubious.
            It would be better to just define a new enumeration with three values, and return that.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousUninitializedArray">
        <Details>
            <![CDATA[
            <p>Looks for methods that return arrays that are allocated but not initialized in this method.
            While it's possible that the calling method will do the work of initializing the array, it is not a usual pattern, and it is suspected that this array was just forgotten to be initialized.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.InappropriateToStringUse">
        <Details>
            <![CDATA[
            <p>Looks for methods that perform algorithmic operations on Strings that are returned from a toString() method.
            As toString should only be used for debug/trace purposes, it shouldn't be used for algorithm use.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.InconsistentKeyNameCasing">
        <Details>
            <![CDATA[
            <p>Looks for methods that use the same name with different casing to access objects in HttpRequest parameters and attributes.
            As these parameter names are case-sensitive this will lead to confusion.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.OverzealousCasting">
        <Details>
            <![CDATA[
            <p>Looks for manual casts of objects that are more specific than needed as the value is assigned to a class or interface higher up in the inheritance chain.
            You only need to cast to that class or interface.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PoorlyDefinedParameter">
        <Details>
            <![CDATA[
            <p>Looks for non derivable methods that declare parameters and then cast those parameters to more specific types in the method.
            This is misleading and dangerous as you are not documenting through parameter types what is necessary for these parameters to function correctly.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonSymmetricEquals">
        <Details>
            <![CDATA[
            <p>Looks for classes that break the fundamental rule of equivalence, which is symmetry.
            If a equals b, then b equals a.
            While it is usually wrong to allow equals to compare different types, at the very least you should make sure that each class knows about each other and is able to compare themselves with each other.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ContraVariantArrayAssignment">
        <Details>
            <![CDATA[
            <p>Finds contravariant array assignments.
            Since arrays are mutable data structures, their use must be restricted to covariant or invariant usage.</p>

<pre><code>
class A {}
class B extends A {}

B[] b = new B[2];
A[] a = b;
a[0] = new A(); // results in ArrayStoreException (Runtime)
</code></pre>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonFunctionalField">
        <Details>
            <![CDATA[
            <p>Looks for fields in serializable classes that are defined as both final and transient.
            As a transient field is not initialized when streamed, and is not initialized in a constructor, it will remain null because it is defined final.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousNullGuard">
        <Details>
            <![CDATA[
            <p>Looks for code that checks to see if a field or local variable is not null, before entering a code block - either an if, or while statement - and then reassigns that field or local variable.
            It is likely that guard should have been to see if that field or local variable is null, not, not null.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.MoreDumbMethods">
        <Details>
            <![CDATA[
            <p>This detector looks for calls to more pointless or deprecated methods.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ReflectionOnObjectMethods">
        <Details>
            <![CDATA[
            <p>This detector looks for reflective calls on methods that are found in the class java.lang.Object.
            As these methods are always available, there is no reason to use reflection to call them.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ImproperPropertiesUse">
        <Details>
            <![CDATA[
            <p>This detector looks for java.util.Properties use where values other than String are placed in the properties object.
            As the Properties object was intended to be a String to String only collection, putting other types in the Properties object is incorrect, and takes advantage of a poor design decision by the original Properties class designers to derive from Hashtable, rather than using aggregation.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PossibleConstantAllocationInLoop">
        <Details>
            <![CDATA[
            <p>This detector looks for allocations of objects using the default constructor in a loop, where the object allocated is never assigned to any object that is used outside the loop.
            It is possible that this allocation can be done outside the loop to avoid excessive garbage.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.WriteOnlyCollection">
        <Details>
            <![CDATA[
            <p>This detector looks for allocations and initializations of Java collections, but that are never read from or accessed to gain information.
            This represents a collection of no use, and most probably can be removed.
            It is similar to a dead local store.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseVarArgs">
        <Details>
            <![CDATA[
            <p>This detector looks for definitions of methods that have an array as the last parameter.
            Since this class is compiled with Java 1.5 or better, it would be more flexible for clients of this method to define this parameter as a vararg parameter.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PossibleUnsuspectedSerialization">
        <Details>
            <![CDATA[
            <p>This detector looks for code that serializes objects that are non-static inner classes of other classes.
            Since there is a reference to the containing class, this class will be serialized as well.
            It is often the case that this is not what is wanted, and will cause much more data to be serialized than is necessary.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SideEffectConstructor">
        <Details>
            <![CDATA[
            <p>This detector looks for object creation where the object isn't assigned to any variable or field.
            This implies that the class operates through side effects in the constructor, which makes for difficult-to-maintain code.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousGetterSetterUse">
        <Details>
            <![CDATA[
            <p>This detector looks for Java bean getter-setter use where the value of a property is set with the value retrieved from the same bean's corollary getter, like this:</p>
<pre><code>
    person.setAge(person.getAge());
</code></pre>
            <p>Typically this is a copy paste typo.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.LingeringGraphicsObjects">
        <Details>
            <![CDATA[
            <p>This detector looks for creation of java.awt.Graphics objects that do not have the <code>.dispose()</code> method called on them when finished.
            These objects will be cleaned up by the Garbage collector, bug given the likelihood that large numbers of these objects can be created in a short period of time, it is better to dispose them as soon as possible.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.StackedTryBlocks">
        <Details>
            <![CDATA[
            <p>This detector looks for two or more try-catch blocks that are consecutive and catch the same kind of exception, and each catch block mandatorily throws the same exception.
            These two catch blocks can and should be made into one catch block to simply the code.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CommonsEqualsBuilderToEquals">
        <Details>
            <![CDATA[
            <p>This detector looks for uses for commons-lang EqualsBuilder where the result of equals() is returned instead of calling the method isEquals().</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CommonsHashcodeBuilderToHashcode">
        <Details>
            <![CDATA[
            <p>This detector looks for uses for commons-lang <code>HashCodeBuilder</code> where the result of <code>hashCode()</code> is returned instead of calling the method <code>toHashCode()</code>.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CommonsStringBuilderToString">
        <Details>
            <![CDATA[
            <p>This detector looks for uses for commons-lang <code>ToStringBuilder</code> where the result of <code>toString()</code> is returned without an intermediate invocation of append().</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CompareClassNameEquals">
        <Details>
            <![CDATA[
            <p>In a JVM, two classes are the same class (and consequently the same type) if they are loaded by the same class loader, and they have the same fully qualified name [JVMSpec 1999].

            Comparing class name ignores the class loader.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.BackportReusePublicIdentifiers">
        <Details>
            <![CDATA[
            <p>Detects use of Backport Utils concurrent classes from Emory, or Time classes from ThreeTen.
            Updated/efficient versions of classes from emory are available in versions of the JDK 5.0 and higher, and in JDK 8.0 and higher for ThreeTen, and these classes should only be used if you are targeting a JDK lower than this.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CloneUsability">
        <Details>
            <![CDATA[
            <p>Looks for classes that implement clone() that do not specialize the return value, and do not swallow CloneNotSupportedException.
            Not doing so makes the clone method not as simple to use, and should be harmless to do so.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingArrayAsList">
        <Details>
            <![CDATA[
            <p>Looks for calls to Arrays.asList where the parameter is a primitive array.
            This does not produce a list that holds the primitive boxed values, but a list of one item, the array itself.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PresizeCollections">
        <Details>
            <![CDATA[
            <p>Looks for methods that create collections using the default constructor, even though the number of elements that will be placed in the collection is known a priori, and thus could be pre-allocated.
            Not doing so just causes more intermediate reallocations which is unnecessary.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnboundMethodTemplateParameter">
        <Details>
            <![CDATA[
            <p>Looks for methods that declare method level template parameter(s) that are not bound to any of the method's parameters, and thus is not adding any validation/type safety to the method, and is just confusing.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.NonProductiveMethodCall">
        <Details>
            <![CDATA[
            <p>Looks for common methods that are non mutating where the return value is ignored.
            As these methods do not change the object they are called on, calling these methods is pointless.
            They can be removed.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ArrayIndexOutOfBounds">
        <Details>
            <![CDATA[
            <p>Looks for questionable load/stores to array elements.
            <ul>
            <li>
            Looks for accesses to array elements using literal values that are known to be outside the bounds of the array.
            This mistake will cause an ArrayIndexOutOfBoundsException to occur at runtime.</li>
            <li>
            Looks for stores to array elements where the array itself appears to have not been allocated.
            </li>
            </ul>
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.InvalidConstantArgument">
        <Details>
            <![CDATA[
            <p>Looks for method calls that take a parameter value that does not match one of the expected values for that parameter.
            It is likely this parameter value should really be an enum, but predates the addition of enums to Java.
            Passing an invalid value will likely cause problems in the execution of the method.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CollectionNamingConfusion">
        <Details>
            <![CDATA[
            <p>Looks for fields or local variables that are collections but the names have a different type of collection in the name.
            This is confusing, and is probably a left over from a type change, such as </p>
            <p>List&lt;String&gt; mySet;</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.PoorMansEnum">
        <Details>
            <![CDATA[
            <p>Looks for fields defined with simple types, (int, String, etc) that are used like enums.
            Specifically fields that are only assigned a set of constant values.
            This variable probably should be redefined as an enum.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnusedParameter">
        <Details>
            <![CDATA[
            <p>Looks for private or static methods that have parameters that aren't used.
            These parameters can be removed, assuming the method isn't used through reflection.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.FindClassCircularDependencies">
        <Details>
            <![CDATA[
            <p>This detector looks for circular dependencies among classes. </p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ModifyingUnmodifiableCollection">
        <Details>
            <![CDATA[
            <p>This detector looks for code that attempts to modify a collection that is or may be defined as immutable.
            Doing so will cause exceptions at runtime.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.HangingExecutors">
        <Details>
            <![CDATA[
            <p>Three detectors for hanging ExecutorServices, that is, ExecutorServices that never get a call to shutdown, which can potentially cause the JVM to not exit.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.HttpClientProblems">
        <Details>
            <![CDATA[
            <p>The HttpRequests from the Apache HttpComponents have some little-known quirks about them.
            This is a set of detectors that helps guard against resource starvation.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.Unjitable">
        <Details>
            <![CDATA[
            <p>This detector looks for methods that are longer than 8000 bytes.
            Methods this long are automatically disqualified by the JIT for compilation and will always be emulated.
            Consider breaking this method up to avoid this, if performance is important.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConflictingTimeUnits">
        <Details>
            <![CDATA[
            <p>Looks for methods that perform arithmetic operations on values representing time where the time unit is incompatible, e.g. adding a millisecond value to a nanosecond value.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.CharsetIssues">
        <Details>
            <![CDATA[
            <p>Looks for manual specification of String encoding using String constants where either a StandardCharset could be used (JDK7) or where the encoding is not recognized with the current JDK.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ContainsBasedConditional">
        <Details>
            <![CDATA[
            <p>Looks for complex <code>if</code> expressions made up of multiple conditions joined by OR, where the same local variable is compared to a static value.
            When the number of conditions grows it is much cleaner to build a static set of the possible values, and use the <code>contains</code> method on that set.
            This will shorten the code, and make it more self documenting.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.OverlyPermissiveMethod">
        <Details>
            <![CDATA[
            <p>Looks for methods that are declared more permissively than the code is using.
            For instance, declaring a method public, when it could just be declared private.
            Giving methods more permissive access than they need to have limits your ability to make observations about these methods, like parameter usage, refactorability, and derivability.
            This detector will not report on methods that are never called, in case this method is an API-like method intended to be called by client code.
            If this method is also called through reflection, this detector may erroneously report it.</p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.StringifiedTypes">
        <Details>
            <![CDATA[
            <p>Looks for classes that store fields that are Strings that impersonate instances of classes, or collections that are fields that hold Strings that impersonate a class.
            Examples of String impersonation are storing: <ul>
                <li>The result of a toString call</li>
                <li>Strings built from parsing or building strings from other objects, such as "1,2,3,4" or "Project:3"</li>
            </ul>
            By using Strings you are throwing away type-safety, and making it difficult to reason about what the values of variables in use are.
            If a String has multiple parts to it, it probably belongs as a first-class Class.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousLoopSearch">
        <Details>
            <![CDATA[
            <p>Looks for methods that assign a value to a variable in an "if equals" conditional in a loop, but do not break after doing so.
            Since equality would seem to be a one time event, continuing with the loop seems pointless, and a break statement in the if statement seems like it should be added.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConflatingResourcesAndFiles">
        <Details>
            <![CDATA[
            <p>Looks for methods that use the File API on resources retrieved from URLs where the URL in question isn't from a file protocol.
            In the case of classpath resources, this will work if the code is executed from directories, but fail using JARs.
            If using resources, then use URL.openStream() method instead of File APIs.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ImmatureClass">
        <Details>
            <![CDATA[
            <p>Looks for classes that are not fully complete from a usability point of view, making them more difficult to use than they should be.
            Things such as <ul>
            <li>Using the default package</li>
            <li>Missing hashCode/equals</li>
            <li>Missing toString() method</li>
            <li>Using autogenerated parameter names</li>
            </ul>
            </p>
            <p>It is a moderately fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.JAXRSIssues">
        <Details>
            <![CDATA[
            <p>Looks for problems with the use of the JAX-RS specification.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.JPAIssues">
        <Details>
            <![CDATA[
            <p>Looks for problems with the use of the JPA specification, including Spring's support of JPA</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuboptimalExpressionOrder">
        <Details>
            <![CDATA[
            <p>Looks for conditional expressions that are a combination of simple local variable (in)equalities and tests on the results of method calls, where the method calls are done first.
            By placing the simple conditions first you may eliminate costly calls in certain cases.
            This assumes that the method calls do not have side effects that should happen always.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.IOIssues">
        <Details>
            <![CDATA[
            <p>Looks for various issues around doing I/O with streams and reader/writers, and compression of byte buffers.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.DubiousMapCollection">
        <Details>
            <![CDATA[
            <p>Looks for use of maps that are private fields in a List-only way, that is, maps that are created in constructors or static initializers, and are only iterated over.
            Often this is done because the Map allows for two values, as opposed to a List.
            The fix is to just create a List of some object that holds all the values.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.BuryingLogic">
        <Details>
            <![CDATA[
            <p>Looks for methods that needlessly push a large chunk of code to the right through indenting with braces.
            The code is basically an if/else-then-return structure.
            The "if true" test does the bulk of the logic, and the else just returns.
            It is more readable if the bulk of the logic is moved as far to the left in the method as is possible.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.WiringIssues">
        <Details>
            <![CDATA[
            <p>Looks for various issues around @Autowired/@Inject fields in DI classes</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ConcurrentCollectionIssues">
        <Details>
            <![CDATA[
            <p>Looks for problems with using concurrent collections.
            <ul>
                <li>Adding a collection as a value of a Concurrent map, without the use of putIfAbsent</li>
            </ul>
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UseTryWithResources">
        <Details>
            <![CDATA[
            <p>Looks for use of auto-closeable resources in JDK 7 or later that are not using the try-with-resources paradigm.
            To avoid problems, and ease the reader, use of try-with-resources is recommended</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousShadedClassUse">
        <Details>
            <![CDATA[
            <p>Looks for use of shaded methods from 3rd-party jars, created by tools such as the Maven shade plugin.
            These methods are from classes that have been included in a jar, for internal use, and are copies of real 3rd-party jars.
            It is likely you meant to use the real class from the real jar, but your IDE picked the wrong import to use.
            </p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnsynchronizedSingletonFieldWrites">
        <Details>
            <![CDATA[
            <p>Looks for writes to fields of classes that are believed to be classes used only as Singletons.
            These classes include Enums, as well as spring beans that are Singleton scoped.</p>
            <p>It is a fast detector.</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.OptionalIssues">
        <Details>
            <![CDATA[
            <p>Looks for various issues with the use of the java.util.Optional class.</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryApiConversion">
        <Details>
            <![CDATA[
            <p>Looks for code that appears to be using two forms of similar apis: an older one, and a new one.
            It finds code that creates newer api objects by first instantiating older api objects, and converting them into the new form.
            It is simpler just to create the new object directly.</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ReflectionIssues">
        <Details>
            <![CDATA[
            <p>Looks for issues around the use of java reflection.</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.AnnotationIssues">
        <Details>
            <![CDATA[
            <p>Looks for issues around use of standard annotations</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.MapUsageIssues">
        <Details>
            <![CDATA[
            <p>Looks for dubious usage patterns around the Map interface</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.ListUsageIssues">
        <Details>
            <![CDATA[
            <p>Looks for dubious usage patterns around the List interface</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
    <Detector class="com.mebigfatguy.fbcontrib.detect.FunctionalInterfaceIssues">
        <Details>
            <![CDATA[
            <p>Looks for various issues around the use of @FunctionalInterfaces.</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
    <Detector class="com.mebigfatguy.fbcontrib.detect.SetUsageIssues">
        <Details>
            <![CDATA[
            <p>Looks for various issues around the use of the Set interface</p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>

    <Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousArgumentTypes">
        <Details>
            <![CDATA[
            <p>Looks for method calls where the arguments passed seem oddly typed for the use they are intended for.
            </p>
            <p>It is a fast detector</p>
            ]]>
        </Details>
    </Detector>
    
    <Detector class="com.mebigfatguy.fbcontrib.debug.OCSDebugger">
        <Details></Details>
    </Detector>

    <!-- BugPattern -->

    <BugPattern type="ISB_INEFFICIENT_STRING_BUFFERING">
        <ShortDescription>方法在 StringBuffer 或 StringBuilder 的 append() 中使用加号拼接</ShortDescription>
        <LongDescription>方法 {1} 在 StringBuffer 或 StringBuilder 的 append() 中使用加号拼接</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用<code>StringBuffer</code>或<code>StringBuilder</code>的 append() 拼接字符串。
            然而，它将加号简易拼接的结果作为入参来调用 append()， 因此无法享受使用<code>StringBuffer</code>或<code>StringBuilder</code>带来的性能提升。</p>

            <p>
            Java 会隐式使用 StringBuilders，这令此很难被侦测修复。
            比如，<br/>
<pre><code>
StringBuilder sb = new StringBuilder();
for (Map.Entry<Integer, String> e : map.entrySet()) {
    sb.append(e.getKey() + e.getValue());        //在这里 bug 被侦测到
}
</code></pre><br/>

            会被自动转换为：<br/>
<pre><code>
StringBuilder sb = new StringBuilder();
for (Map.Entry<Integer, String> e : map.entrySet()) {
    StringBuilder tempBuilder = new StringBuilder();
    tempBuilder.append(e.getKey());
    tempBuilder.append(e.getValue());
    <b>sb.append(tempBuilder.toString());</b>        //低效
}
</code></pre><br/>

            这里多用了一个临时的<code>StringBuilder</code>，完全是没必要的。
            为防止这种情况发生，只需要：<br/>

<pre><code>
StringBuilder sb = new StringBuilder();
for (Map.Entry<Integer, String> e : map.entrySet()) {
    sb.append(e.getKey());
    sb.append(e.getValue());
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ISB_EMPTY_STRING_APPENDING">
        <ShortDescription>方法通过拼接空字符串激活类型转换</ShortDescription>
        <LongDescription>方法 {1} 通过拼接空字符串激活类型转换</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法拼接了一个空字符串，目的是将输入值转换为字符串。
            这更有效的方法是用 String.valueOf() 来实现，避免隐式创建并调用 StringBuffer/Builder 带来的成本。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ISB_TOSTRING_APPENDING">
        <ShortDescription>方法拼接字符串时主动调用对象的 toString()</ShortDescription>
        <LongDescription>方法 {1} 拼接字符串时主动调用对象的 toString()</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将<code>toString()</code>的结果放入一个<code>StringBuffer</code>或<code>StringBuilder</code>.
            更简单的做法是仅仅将你需要的对象作为 append() 的参数，
            这种形式不会导致潜在的<code>NullPointerException</code>，而且更易于阅读。</p>

            <p>
            顺带一提，Java 处理简易字符串拼接也会用到<code>StringBuilder</code>，
            所以就算你没有显式用到<code>StringBuilder</code>，你也有可能看到这个 Bug。
            </p>

            <p>
            为替换这类代码：<br/>
<pre><code>
StringBuilder builder = ...;
builder.append(someObj.toString());
...
System.out.println("Problem with the object :" + someObj.toString());
</code></pre>

只需要：<br/>

<pre><code>
StringBuilder builder = ...
builder.append(someObj);
...
System.out.println("Problem with the object :" + someObj);
</code></pre>
            来避免当一个对象确实 是空(<code>null</code>) 时报出<code>NullPointerException</code>的可能性<code>null</code>.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCI_SYNCHRONIZED_COLLECTION_ITERATORS">
        <ShortDescription>方法在同步集合上创建迭代器</ShortDescription>
        <LongDescription>方法 {1} 在同步集合上创建迭代器</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法用 Collections.synchronizedXXXX 创建了一个同步集合，但使用迭代器来读取它。
            因为迭代器在定义上是线程不安全的，所以这里有观念上的冲突。
            当使用迭代器时，你需要自己做同步控制。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CC_CYCLOMATIC_COMPLEXITY">
        <ShortDescription>方法过于复杂</ShortDescription>
        <LongDescription>方法 {1} 过于复杂，圈复杂度： {3}</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法的圈复杂度相当高，表现在分支的数量上。
            它很有可能难于测试，也不容易修改。
            考虑将此方法重构为几个来降低风险。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OCP_OVERLY_CONCRETE_PARAMETER">
        <ShortDescription>方法不需要用具体类作为入参</ShortDescription>
        <LongDescription>{1}: {3}</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在只实现接口或父类的方法的情况下，用具体的类作为入参。
            考虑增加接口的抽象性来降低未来变更带来的冲击。</p>

            <p>以下面为例：<br/>
<pre><code>
private void appendToList(ArrayList&lt;String&gt; list) {
    if (list.size() &lt; 100) {
        list.add("Foo");
    }
}
</code></pre>

                参数 list 被定义为<code>ArrayList</code>，一个<code>List</code>接口的具体实现。
                这里没必要特别指定<code>ArrayList</code>，因为我们没有用到任何<code>ArrayList</code>特定的方法(像<code>ensureCapacity()</code>或<code>trimToSize()</code>)。
                相比于使用具体类型，像这样做更好：<br/>
<pre><code>
private void appendToList(List&lt;String&gt; list) {
    ...
</code></pre>
                就算设计变了，比如用<code>LinkedList</code>代替，代码也不需要变动。

            </p>

            <p>IDE倾向于提供工具来帮助生成参数。
             比如，在 Eclipse里有重构工具：<a href="http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fref-menu-refactor.htm">Generalize Declared Type</a>帮助找到一个合适级别的</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LII_LIST_INDEXED_ITERATING">
        <ShortDescription>方法基于数值下标遍历 List</ShortDescription>
        <LongDescription>方法 {1} 基于数值下标遍历 List</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法通过<code>for</code>循环调用<code>List.get(i)</code>遍历<code>java.util.List</code>。
            这个下标除了作为循环下标没有其他作用。
            考虑到不同的 List 实现，更好的做法是使用迭代器代替，它的性能更好，而且这样做也允许后面不经修改切换到不同的实现。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UCC_UNRELATED_COLLECTION_CONTENTS">
        <ShortDescription>方法将一个不相关的类型放入集合或数组</ShortDescription>
        <LongDescription>方法 {1} 将一个不相关的类型放入集合或数组</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将一个不相关的类型放入集合或数组，这要求更小心地读取集合里的数据，也导致了程序更脆弱，容易出问题。
            如果有必要，创建一个单独的类，放入必要的信息，将该类的实例放入集合或数组里。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DRE_DECLARED_RUNTIME_EXCEPTION">
        <ShortDescription>方法声明抛出 RuntimeException</ShortDescription>
        <LongDescription>方法 {1} 声明抛出 RuntimeException</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法声明抛出 RuntimeException 或其派生异常。
            这会引起误会，因为非捕获异常无法被处理。
            如果发现一个 RuntimeException 经常抛出，以致需要声明，那更好的办法是在代码里避免出现。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CE_CLASS_ENVY">
        <ShortDescription>方法大量使用另一个类的方法</ShortDescription>
        <LongDescription>方法 {1} 大量使用另一个类的方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法大量使用另一个类中的方法，而不是其自身类的方法。
            一般而言，这意味着通过此方法完成的功能最有可能属于那个如此广泛使用的类。
            考虑将该方法重构到那个类，将需要的数据通过参数传入。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LSC_LITERAL_STRING_COMPARISON">
        <ShortDescription>方法比较字符串时以固定字符串为参数</ShortDescription>
        <LongDescription>方法 {1} 比较字符串时以固定字符串为参数</LongDescription>
        <Details>
            <![CDATA[
            <p>下面这种形式<br/>
<pre><code>String str = ...
str.equals("someOtherString");
//或
str.compareTo("someOtherString");</code></pre>
            </p>
            <p>如果<code>str</code>是<code>null</code>，就会抛出<code>NullPointerException</code> . 如果将代码重构为<br/>
<pre><code>String str = ...
"someOtherString".equals(str);
//或
"someOtherString".compareTo(str);</code></pre><br/>
            那么，在固定字符串上调用<code>equals()</code>或<code>compareTo()</code>，将变量作为参数，不会有异常发生。
            因为两个方法<code>equals()</code>和
            <code>compareTo()</code>都会检查<code>null</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PCOA_PARTIALLY_CONSTRUCTED_OBJECT_ACCESS">
        <ShortDescription>构造方法调用了可被覆盖(非final)的方法</ShortDescription>
        <LongDescription>构造方法 {1} 调用了可被覆盖(非final)的方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此构造方法调用了可被覆盖(非final)的方法。
            因为此方法会被覆盖，一个子类的实现会被调用，而当时子类实际还没有初始化。
            应将所有被构造方法调用的方法都标记为不可覆盖(final)来避免这个问题。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DLC_DUBIOUS_LIST_COLLECTION">
        <ShortDescription>类定义了List字段但当作Set用</ShortDescription>
        <LongDescription>类 {0} 定义了List字段但当作Set用</LongDescription>
        <Details>
            <![CDATA[
            <p>此类定义了一个<code>java.util.List</code>字段，但使用行为类似Set。
            因为查找操作在List中一般采用线性遍历，在有大量数据的List上性能很差。
            如果一个列表已知只有一点点数据(3,4个)，这个问题不大。
            如果不是，考虑将这个字段的数据类型换到Set。
            如果维持有序非常重要，可以考虑使用 LinkedHashSet。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PL_PARALLEL_LISTS">
        <ShortDescription>类定义了两个或多个有关联的列表或数组</ShortDescription>
        <LongDescription>类 {0} 定义了两个或多个有关联的列表或数组</LongDescription>
        <Details>
            <![CDATA[
            <p>此类有两个或多个列表或数组，它们的内容有关联。
            也就是说，像这样：<br/>
<pre><code>
List&lt;String&gt; words = new ArrayList&lt;String&gt;();
List&lt;Integer&gt; wordCounts = new ArrayList&lt;String&gt;();
</code></pre>
            在下标0的数据有关联，在下标1的数据也有关联，等等。
            </p>
            <p>
            考虑创建一个单独的类持有所有关联信息，将此类的实例放入一个列表或数组中使用。
            如果只有将各值，使用 Map 来绑定两者，就像：<br/>
<pre><code>
private class WordAndCount{public String word;  public int count}

List&lt;WordAndCount&gt; wordsAndCounts = new ArrayList&lt;WordAndCount&gt;();
//或者，只有两个要素
Map<String,Integer> wordCounts = new HashMap<String,Integer>();
</code></pre>

            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="FP_FINAL_PARAMETERS">
        <ShortDescription>方法可以将一个参数定义为不可变(final)</ShortDescription>
        <LongDescription>方法 {1} 可以将一个参数定义为不可变(final)</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法没有往参数写入。
            出于文档编写的目的，也出于帮助 JVM 优化该方法调用的目的，应该考虑将参数定义为不可变(final)。</p>

            <p>性能提升是存在疑问的："final 关键字不会出现在类文件用于局部变量和参数，因此不会影响运行时性能。
            唯一的用途是阐述程序员的意图，这个变量是不可变的(许多人对此用法存在疑问)，还有就是处理匿名内部类。
            " - http://stackoverflow.com/a/266981/1447621 </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ACEM_ABSTRACT_CLASS_EMPTY_METHODS">
        <ShortDescription>空方法可以被声明为抽象方法</ShortDescription>
        <LongDescription>空方法 {1} 可以被声明为抽象方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法是空的，或者仅仅是抛出一个异常。
            由于类被定义为抽象的，更正确的行为是将此方法定义为抽象方法，这样可以强制子类定义的行为。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MAC_MANUAL_ARRAY_COPY">
        <ShortDescription>方法手工拷贝数组</ShortDescription>
        <LongDescription>方法 {1} 手工拷贝数组</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法通过循环手工从一个数组往另一个拷贝数据。
            使用<code>System.arraycopy</code>性能更好，因为该方法直接调用底层系统实现。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="FPL_FLOATING_POINT_LOOPS">
        <ShortDescription>方法使用浮点型作为循环索引</ShortDescription>
        <LongDescription>方法 {1} 使用浮点型作为循环索引</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用浮点型变量作为循环索引。
            由于浮点运算不精确，因此每次执行循环时，舍入误差都会随着时间累积。
            一般更好的是使用整型来索引，然后在循环体最前面计算一个浮点型的新值。</p>
            <p>举例： <pre><code>
for (float f = 1.0f; f &lt;= 10.0f; f += 0.1f) {
    System.out.println(f);
}
</code></pre>
            最后一个值不一定是10.0，更有可能的是9.900001或其他。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NCMU_NON_COLLECTION_METHOD_USE">
        <ShortDescription>方法使用了旧的非集合接口方法</ShortDescription>
        <LongDescription>方法 {1} 使用了旧的非集合接口方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用了集合类中的非 Collection 接口定义的方法，但在 Collection 接口中存在等价方法。
            要使用新方法，可以将这个对象定义为 Collection，更好地去耦合。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CAO_CONFUSING_AUTOBOXED_OVERLOADING">
        <ShortDescription>类定义了可能导致字符串和数值混淆的方法</ShortDescription>
        <LongDescription>类 {0} 定义可能导致字符串和数值混淆的方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此类定义了两个方法，仅仅参数不同：字符(Character)或数值(int/long/float/double)。
            因为自动装箱的存在，可能假定参数 'a' 将映射到"字符"版本，但并非如此。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AFBR_ABNORMAL_FINALLY_BLOCK_RETURN">
        <ShortDescription>方法存在从 finally 段不正常退出的情况</ShortDescription>
        <LongDescription>方法 {1} 存在从 finally 段不正常退出的情况</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法从 finally 段返回或抛出异常。
            这会屏蔽 try 段内的代码逻辑，令正常方法返回被短路。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SMII_STATIC_METHOD_INSTANCE_INVOCATION">
        <ShortDescription>方法通过对象调用静态方法</ShortDescription>
        <LongDescription>方法 {1} 通过对象调用静态方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法通过对象实例调用静态方法。
            为了便于阅读代码，更好的做法是通过类名来调用而不是通过对象来调用。
            自编写此代码以来，此方法的静态性质可能已更改，应重新复查。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="STS_SPURIOUS_THREAD_STATES">
        <ShortDescription>方法在线程实例上调用wait, notify 或 notifyAll</ShortDescription>
        <LongDescription>方法 {1} 在线程实例上调用wait, notify 或 notifyAll</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在线程实例上调用<code>wait</code>,<code>notify</code>或<code>notifyAll</code>。
            这么做会混淆内部线程状态行为，导致虚假的唤醒/休眠，因为内部机制也是使用线程实例发出这类通知。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_AUTOBOXING_CTOR">
        <ShortDescription>方法将原生数据包装类传递给相同的原生包装类构造方法</ShortDescription>
        <LongDescription>方法 {1} 将原生数据包装类传递给相同的原生包装类构造方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将原生数据包装类对象作为参数传给同一个类的构造方法。
            因为包装类是不可变的，可以直接使用原始对象，比创建一个好多了。
            这个代码能运行是因为对自动拆装箱的滥用。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOXING_STRING_CTOR">
        <ShortDescription>方法将需解析的字符串传给原生包装类构造方法</ShortDescription>
        <LongDescription>方法 {1} 将需解析的字符串传给原生包装类构造方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将从<code>BoxedPrimitive.parseBoxedPrimitive("1")</code>得到的值作为参数传给同一个类的构造方法。
            这个可以简化为直接传字符串给原生包装类构造方法，或者，更好地，使用静态的<code>valueOf</code>。</p>
            <p>为替换这种代码：<br/>
<pre><code>
Boolean bo = new Boolean(Boolean.parseBoolean("true"));
Float f = new Float(Float.parseFloat("1.234"));
</code></pre>
            只需要：<br/>
<pre><code>
Boolean bo = new Boolean("true");
Float f = new Float("1.234");
</code></pre>
            或者，内存效率更高的办法：<br/>
<pre><code>
Boolean bo = Boolean.valueOf("true");
Float f = Float.valueOf("1.234");
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_AUTOBOXING_VALUEOF">
        <ShortDescription>方法将原生包装类对象传递给同一个类的 valueOf 方法</ShortDescription>
        <LongDescription>方法 {1} 将原生包装类对象传递给同一个类的 valueOf 方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将原生数据包装类对象作为参数传给同一个类的<code>valueOf</code>方法。
            因为包装类是不可变的，可以直接使用原始对象，比创建一个好多了。
            这个代码能运行是因为对自动拆装箱的滥用。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOXING_PARSE">
        <ShortDescription>方法通过多次拆装箱将字符串转化为原生数据</ShortDescription>
        <LongDescription>方法 {1} 通过多次拆装箱将字符串转化为原生数据</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将字符串传给原生包装类对象的 valueOf 方法，再调 boxedValue() 方法来转化为原生数据。
            如果想要的是原生数据，可以简单地使用<code>BoxedPrimitive.parseBoxedPrimitive(String)</code>方法。</p>

            <p>为替换这种代码：<br/>
<pre><code>
public int someMethod(String data) {
long l = Long.valueOf(data).longValue();
float f = Float.valueOf(data).floatValue();
return Integer.valueOf(data); // 这里有一个隐含的 .intValue() 调用
}
</code></pre>
            只需要：<br/>
<pre><code>
public int someMethod(String data) {
    long l = Long.parseLong(data);
    float f = Float.parseFloat(data);
    return Integer.parseInt(data);
}
</code></pre>
            </p>

            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOXING_VALUEOF">
        <ShortDescription>方法通过多次拆装箱将字符串转化为原生包装类</ShortDescription>
        <LongDescription>方法 {1} 通过多次拆装箱将字符串转化为原生包装类</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将字符串传给原生包装类对象的 valueOf 方法，再调 boxedValue() 方法来转化为原生数据。
            如果想要的是原生包装类对象，可以简单地使用<code>BoxedPrimitive.valueOf(String)</code>方法。</p>

            <p>为替换这种代码：<br/>
<pre><code>
Boolean bo = Boolean.valueOf(Boolean.parseBoolean("true"));
Float f = Float.valueOf(Float.parseFloat("1.234"));
</code></pre>
            只需要：<br/>
<pre><code>
Boolean bo = Boolean.valueOf("true");
Float f = Float.valueOf("1.234");
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOX_TO_UNBOX">
        <ShortDescription>方法从原生数据创建原生包装类对象只为获得原生数据</ShortDescription>
        <LongDescription>方法 {1} 从原生数据创建原生包装类对象只为获得原生数据</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法从原生数据创建了一个原生包装类对象，只为了调用<code>primitiveValue()</code>方法来得到原生数据。
            直接用原生数据代替就行了。</p>
            <p>为替换这种代码：<br/>
<pre><code>
boolean bo = new Boolean(true).booleanValue();
float f = new Float(1.234f).floatValue();
</code></pre>
            只需要：<br/>
<pre><code>
boolean bo = true;
float f = 1.234f;
</code></pre>
            </p>

            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOX_TO_CAST">
        <ShortDescription>方法从原生数据创建原生包装类对象只为强转到另一种原生数据</ShortDescription>
        <LongDescription>方法 {1} 从原生数据创建原生包装类对象只为强转到另一种原生数据</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法从原生数据创建了一个原生包装类对象，只为了调用<code>primitiveValue()</code>方法来强转到另一种原生数据。
            更简单的写法是直接强转。</p>
            <p>为替换这种代码：<br/>
<pre><code>
double someDouble = ...
float f = new Double(someDouble).floatValue();

int someInt = ...
byte b = new Integer(someInt).byteValue();
</code></pre>
            只需要：<br/>
<pre><code>
double someDouble = ...
float f = (float) someDouble;

int someInt = ...
byte b = (byte)someInt;
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NAB_NEEDLESS_BOOLEAN_CONSTANT_CONVERSION">
        <ShortDescription>方法对布尔量做了多余的装箱</ShortDescription>
        <LongDescription>方法 {1} 对布尔量做了多余的装箱</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将布尔包装类常量赋值给布尔型变量，或者将布尔型常量赋值给布尔包装类变量。
            应使用正确的常量为变量赋值。
            使用br/>
<pre><code>
boolean b = true;
boolean b = false;
</code></pre>
            或<br/>
<pre><code>
Boolean b = Boolean.TRUE;
Boolean b = Boolean.FALSE;
</code></pre>
            </p>

            <p>请注意，这会在你不期望的时候自动发生。
            比如，<br/>
<pre><code>
Map<String, Boolean> statusMap = ...

public Boolean someMethod() {
    statusMap.put("foo", true);  //值 "true" 会被自动装箱
    return false;  //值 "false" 会被自动装箱
}
</code></pre>
            有两中无意义的自动装箱。
            只需要简单替换为常量就可以提高效率: <br/>

<pre><code>
Map<String, Boolean> statusMap = ...

public Boolean someMethod() {
    statusMap.put("foo", Boolean.TRUE);
    return Boolean.FALSE;
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="USBR_UNNECESSARY_STORE_BEFORE_RETURN">
        <ShortDescription>方法用局部变量存储即将返回的值</ShortDescription>
        <LongDescription>方法 {1} 用局部变量存储即将返回的值</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将返回值存于一个局部变量，然后立即返回这个局部变量。
            这可以简化为直接返回赋给这个局部变量的值。</p>
            <p>
                为替代下面的代码：<br/>

<pre><code>
public float average(int[] arr) {
    float sum = 0;
    for (int i = 0; i &lt; arr.length; i++) {
        sum += arr[i];
    }
    float ave = sum / arr.length;
    return ave;
}
</code></pre>

                只需要简单修改方法返回除法的结果：<br/>

<pre><code>
public float average(int[] arr) {
    float sum = 0;
    for (int i = 0; i &lt; arr.length; i++) {
        sum += arr[i];
    }
    <b>return sum / arr.length;</b> //Change
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="COM_COPIED_OVERRIDDEN_METHOD">
        <ShortDescription>方法通过拷贝父类方法来实现</ShortDescription>
        <LongDescription>方法 {1} 通过拷贝父类方法来实现</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法通过拷贝父类方法来实现，一般来说这说明此方法可以删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="COM_PARENT_DELEGATED_CALL">
        <ShortDescription>方法委托给父类方法</ShortDescription>
        <LongDescription>方法 {1} 委托给父类方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法通过调用父类相同签名的方法来实现。
            此方法可以直接删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ABC_ARRAY_BASED_COLLECTIONS">
        <ShortDescription>方法使用数组作为集合的基础</ShortDescription>
        <LongDescription>方法 {1} 使用数组作为集合的基础</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将数组作为键传递给Map, 作为集合中的元素, 或作为列表中的项目且会用到 contains 方法.  由于数组没有<code>equals</code>方法中，包含里存的实际是引用的地址，这可能是不希望的。
            如果这是TreeMap或TreeSet，请考虑将Comparator传递到构造方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ODN_ORPHANED_DOM_NODE">
        <ShortDescription>方法创建了DOM节点但未将其附加到文档</ShortDescription>
        <LongDescription>方法 {1} 创建了DOM节点但未将其附加到文档</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法创建了DOM节点但未将其附加到文档。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AOM_ABSTRACT_OVERRIDDEN_METHOD">
        <ShortDescription>抽象方法覆盖了具体的实现</ShortDescription>
        <LongDescription>抽象方法 {1} 覆盖了具体的实现</LongDescription>
        <Details>
            <![CDATA[
            <p>此抽象方法是从具体的方法实现中派生的。
            高度怀疑父类方法的实现将被丢弃。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CBX_CUSTOM_BUILT_XML">
        <ShortDescription>方法通过临时连接构建XML字符串</ShortDescription>
        <LongDescription>方法 {1} 通过临时连接构建XML字符串</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法通过拼接XML片段、变量为字符串来生成XML。
            这样做会使代码难以阅读、修改并验证。
            在外部文件中构建XML结构要干净得多：通过Transformer.setParameter进行修改，读入并转换为最终产品。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BSB_BLOATED_SYNCHRONIZED_BLOCK">
        <ShortDescription>方法同步代码块过大</ShortDescription>
        <LongDescription>方法 {1} 同步代码块过大</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用同步，但是在同步块开头只读取局部变量，而不读取成员变量或<code>this</code>。
            为了获得更好的性能，请将仅读取局部变量的代码移到同步块外，仅将同步块留给读取成员变量或读取<code>this</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CLI_CONSTANT_LIST_INDEX">
        <ShortDescription>方法使用常量索引读取列表或数组</ShortDescription>
        <LongDescription>方法 {1} 使用常量索引读取列表或数组</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用常量索引读取数组或列表。
            一般，这是使用循环变量的笔误。
            但是，如果特定列表索引表示不同的意义，则可以将列表替换为有意义的类将使代码不那么脆弱。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCR_SLOPPY_CLASS_REFLECTION">
        <ShortDescription>方法使用Class.forName访问静态绑定的类</ShortDescription>
        <LongDescription>方法 {1} accesses statically bound class with Class.forName</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用Class.forName读取已经静态绑定入上下文的类的对象。
            使用Class.forName会使代码转换(例如混淆)的反射更加脆弱，并且在此不需要，因为相关的类已经链接到该类。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AWCBR_ARRAY_WRAPPED_CALL_BY_REFERENCE">
        <ShortDescription>方法使用单元素数组模拟按引用调用</ShortDescription>
        <LongDescription>方法 {1} 使用单元素数组模拟按引用调用</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用单元素数组来包装要作为参数传递给方法的对象，模拟C++的按引用调用。
            最好定义一个适当的返回类类型来容纳所有从被调用方法中检索到的相关信息。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SG_SLUGGISH_GUI">
        <ShortDescription>方法在GUI线程中执行耗时的操作</ShortDescription>
        <LongDescription>方法 {1} 在GUI线程中执行耗时的操作</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法实现了AWT或Swing侦听器，并执行高耗时操作。
            在GUI线程中执行这些操作将导致界面显得缓慢且对用户无响应。
            考虑使用单独的线程来完成耗时的工作，以便用户获得更好的体验。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NIR_NEEDLESS_INSTANCE_RETRIEVAL">
        <ShortDescription>方法通过实例加载静态成员</ShortDescription>
        <LongDescription>方法 {1} 通过实例加载静态成员</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用方法以加载对象，然后仅使用它来加载该实例的静态成员。
            从类本身加载静态字段会更简单，更高效。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DDC_DOUBLE_DATE_COMPARISON">
        <ShortDescription>方法使用两次日期比较来完成一次即可的工作</ShortDescription>
        <LongDescription>方法 {1} 使用两次日期比较来完成一次即可的工作</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法通过两次比较来比较日期，而不是使用反向比较。
            所以这个模式</p>

<pre><code>
if ((date1.equals( date2 )) || (date1.after( date2 )))
</code></pre>

            可成为：<br/>

<pre><code>
if (date1.compareTo( date2 ) >= 0)
</code></pre><br/>

            又比如<br/>

<pre><code>
if ((date1.equals( date2 )) || (date1.before( date2 )))
</code></pre>

            可成为：<br/>

<pre><code>
if (date1.compareTo( date2 ) <= 0)
</code></pre><br/>

            又比如<br/>

<pre><code>
if ((date1.before( date2 )) || (date1.after( date2 )))
</code></pre>

            可成为：<br/>

<pre><code>
if (!date1.equals( date2 ))
</code></pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SWCO_SUSPICIOUS_WAIT_ON_CONCURRENT_OBJECT">
        <ShortDescription>方法应使用await而不是wait</ShortDescription>
        <LongDescription>方法 {1} 应使用await而不是wait</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在java.util.concurrent包中定义的互斥体上调用wait().
            这些类定义了<code>await</code>，代替<code>wait</code>，并且很可能想调用的就是<code>await</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JVR_JDBC_VENDOR_RELIANCE">
        <ShortDescription>方法使用特定JDBC供应商的类和方法</ShortDescription>
        <LongDescription>方法 {1} 使用特定JDBC供应商的类和方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用JDBC供应商特定的类和方法来执行数据库工作。
            这使得该代码特定于该供应商，并且无法在其他数据库上运行。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PMB_POSSIBLE_MEMORY_BLOAT">
        <ShortDescription>静态字段中的潜在内存膨胀</ShortDescription>
        <LongDescription>类 {0} 定义的字段 "{1}" 存在内存膨胀</LongDescription>
        <Details>
            <![CDATA[
            <p>此类定义了<code>Collection</code>，<code>StringBuffer</code>或<code>StringBuilder</code>的静态字段。
            似乎没有任何办法清除或减小其大小。
            也就是说，定义了一个集合，并具有类似的方法调用{<code>add()</code>，<code>append()</code>，<code>offer()</code>，<code>put()</code>，...} <br/>
            没有方法调用类似<br/>的删除方法{<code>clear()</code>，<code>delete()</code>，<code>pop()</code>，<code>remove()</code>，...} <br/>
            这意味着相关集合的大小只能增加，即可能导致内存膨胀。</p>

            <p>
            如果此集合是List, set 或 其他静态的东西 (例如一个List&lt;String&gt; 存储月份名称), 考虑将所有元素添加到静态初始化器中，该初始化器只能调用一次：<br/>
<pre><code>
private static List&lt;String&gt; monthNames = new ArrayList&lt;String&gt;();
static {
    monthNames.add("January");
    monthNames.add("February");
    monthNames.add("March");
    ...
}
</code></pre>
            </p>

            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="PMB_INSTANCE_BASED_THREAD_LOCAL">
        <ShortDescription>字段是实例内的ThreadLocal变量</ShortDescription>
        <LongDescription>字段 {1} 是实例内的ThreadLocal变量</LongDescription>
        <Details>
            <![CDATA[
            <p>该ThreadLocal字段被定义为基于实例(不是静态的)。
            就垃圾回收器而言，由于所有ThreadLocal变量都描述了永久的可达性根，因此这些变量将永远不会被回收(只要Thread存活)。
            由于此ThreadLocal是实例化的，因此即使在拥有实例被回收后，您也可能会创建许多不可回收的变量。
            几乎可以肯定，应该使用基于静态的ThreadLocal变量。</p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="PMB_LOCAL_BASED_JAXB_CONTEXT">
        <ShortDescription>按需创建本地JAXBContext</ShortDescription>
        <LongDescription>方法 {1} 按需创建本地JAXBContext</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法创建一个JAXBContext并将其存储在本地变量中。
            这个表示此JAXBContext每次按需创建，这将导致内存膨胀问题。
            最好将此实例创建为静态字段，或使用ConcurrentHashMap等将其保留。
            
            参考： https://javaee.github.io/jaxb-v2/doc/user-guide/ch03.html#other-miscellaneous-topics-performance-and-thread-safety </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LSYC_LOCAL_SYNCHRONIZED_COLLECTION">
        <ShortDescription>方法创建用于局部变量的同步集合</ShortDescription>
        <LongDescription>方法 {1} 创建用于局部变量的同步集合</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法创建一个同步集合并存储在局部变量中。
            由于局部变量按照定义是线程安全的，因此使用同步集合是可疑的。</p>
            <p>
            <table>
                <tr><th>如果您正在使用</th><th>考虑使用</th></tr>
                <tr><td>java.util.Vector</td><td>java.util.ArrayList</td></tr>
                <tr><td>java.util.Hashtable</td><td>java.util.HashMap</td></tr>
                <tr><td>java.lang.StringBuffer</td><td>java.lang.StringBuilder</td></tr>
            </table>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="FCBL_FIELD_COULD_BE_LOCAL">
        <ShortDescription>类定义仅当作局部变量用的字段</ShortDescription>
        <LongDescription>类 {0} 定义仅当作局部变量用的字段</LongDescription>
        <Details>
            <![CDATA[
            此类定义了仅当作局部变量用的字段，特别是不可继承类中的私有字段或受保护字段，这些字段在每种方法中首先通过存储与加载进行访问。
            该字段可以用一个或多个局部变量代替。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NOS_NON_OWNED_SYNCHRONIZATION">
        <ShortDescription>类使用不是自己拥有的变量进行同步</ShortDescription>
        <LongDescription>类 {0} 使用不是自己拥有的变量进行同步</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用一个同步块，在该块上要同步的对象不属于当前实例。
            这意味着其他实例可能出于自己的目的使用同一对象进行同步，从而导致同步混乱。
            仅在此类的私有字段上进行同步总是更干净，更安全。
            请注意，"this"不属于当前实例，属于将其该对象分配给类内字段的任何人。
            在"this"上同步也不是一个好主意。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NRTL_NON_RECYCLEABLE_TAG_LIB">
        <ShortDescription>标签库不可回收</ShortDescription>
        <LongDescription>标签库 {0} 不可回收</LongDescription>
        <Details>
            <![CDATA[
            <p>此标签库实现了一个属性，其关联的存储用字段又在标签库另一个地方被修改。
            为了使标记库可回收，仅允许容器通过使用taglib的setXXX方法来更改此属性。
            以编程方式修改值，容器在重用标签库时将无法正确初始化属性。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_NULL_LAYOUT">
        <ShortDescription>GUI使用绝对布局</ShortDescription>
        <LongDescription>GUI {0} 使用绝对布局</LongDescription>
        <Details>
            <![CDATA[
            <p>此类将null传递给<code>setLayout</code>，代表指定要使用绝对坐标对组件进行布局。
            这使得难以更改字体大小等，因为控件将不会重新定位。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_NO_SETLABELFOR">
        <ShortDescription>JLabel 没有指定其标签</ShortDescription>
        <LongDescription>方法 {1} 中的 JLabel 没有指定其标签</LongDescription>
        <Details>
            <![CDATA[
            <p>此类使用不指定要标记哪些字段的JLabel。
            这阻碍了屏幕阅读器向用户提供适当的反馈。
            使用 JLabel.setLabelFor 方法可以完成此操作。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_NO_SETSIZE">
        <ShortDescription>窗口手动设置大小，不使用pack</ShortDescription>
        <LongDescription>窗口 {0} 手动设置大小，不使用pack</LongDescription>
        <Details>
            <![CDATA[
            <p>此类创建一个窗口，并使用setSize调整窗口大小。
            为了处理字体大小更改，最好使用pack方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_NON_ACCESSIBLE_JCOMPONENT">
        <ShortDescription>类 扩展JComponent但未实现Accessible接口</ShortDescription>
        <LongDescription>类 {0} 扩展JComponent但未实现Accessible接口</LongDescription>
        <Details>
            <![CDATA[
            <p>此类扩展了JComponent GUI控件，但未实现Accessibility接口。
            对于有阅读/视觉困难的人来说，这使得屏幕阅读器等无法处理此控件。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_SET_COMP_COLOR">
        <ShortDescription>方法显式设置组件的颜色</ShortDescription>
        <LongDescription>方法 {1} 显式设置组件的颜色</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法设置组件的显式前景色或背景色，可能会给使用此应用程序的视力障碍人士带来困难。
            应该允许从操作系统设置颜色。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_NON_TRANSLATABLE_STRING">
        <ShortDescription>方法将常量字符串传递给组件的标题/标签</ShortDescription>
        <LongDescription>方法 {1} 将常量字符串传递给组件的标题/标签</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法创建一个组件并将字符串传递给该组件的标题或标签。
            由于此字符串将显示给用户，因此应该通过使用资源包将其国际化。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="S508C_APPENDED_STRING">
        <ShortDescription>方法将拼接字符串传递给组件的标题/标签</ShortDescription>
        <LongDescription>方法 {1} 将拼接字符串传递给组件的标题/标签</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法创建一个组件，并通过将多个字符串拼接在一起作为字符串传递给组件的标题/标签。
            由于外语对短语的顺序可能有所不同，因此翻译会很困难。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UEC_USE_ENUM_COLLECTIONS">
        <ShortDescription>类使用枚举类作为普通Set或Map的键</ShortDescription>
        <LongDescription>类 {0} 使用枚举类作为普通Set或Map的键</LongDescription>
        <Details>
            <![CDATA[
            <p>此类使用普通的set或map集合，并使用enum类作为键类型。
            使用JDK 1.5 EnumSet或EnumMap类的性能更高。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SIL_SQL_IN_LOOP">
        <ShortDescription>方法在循环内执行SQL查询</ShortDescription>
        <LongDescription>方法 {1} 在循环内执行SQL查询</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在循环内执行SQL查询。
            这种模式通常效率低下，因为在循环中查询数量可能迅速增加。
            这样可能更有效：遍历输入并收集所有查询所需的关键数据， 
            然后使用in子句或类似的结构发出一个查询，
            然后遍历此结果集，
            并一次获取所有数据。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NMCS_NEEDLESS_MEMBER_COLLECTION_SYNCHRONIZATION">
        <ShortDescription>类在成员集合上定义不需要的同步</ShortDescription>
        <LongDescription>类 {0} 在成员集合上定义不需要的同步</LongDescription>
        <Details>
            <![CDATA[
            <p>此类将私有集合成员定义为需要同步。
            但是，似乎仅在静态初始化程序或构造函数中修改了此集合。
            这两个区域保证线程安全，因此不需要将此集合定义为需要同步，这是潜在的性能瓶颈。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ITC_INHERITANCE_TYPE_CHECKING">
        <ShortDescription>方法在多种类型上使用instanceof来路由逻辑</ShortDescription>
        <LongDescription>方法 {1} 在多种类型上使用instanceof来路由逻辑</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在一系列if/else语句中使用instanceof运算符根据类型调用不同代码块。
            如果这些类型通过继承相关联，则只需要基类中定义一个方法，然后在分支中使用这些类覆盖的方法就更干净了。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SACM_STATIC_ARRAY_CREATED_IN_METHOD">
        <ShortDescription>方法创建数组作为常量使用</ShortDescription>
        <LongDescription>方法 {1} 创建数组作为常量使用</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 初始化创建了一个数组，作为常量使用。
            每次调用此方法，该数组将被重新创建。
            最好将数组定义为类的静态字段。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS">
        <ShortDescription>方法似乎在同一对象上冗余地调用了相同的方法</ShortDescription>
        <LongDescription>方法 {1} 似乎在同一对象上冗余地调用了相同的方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在相同实例上使用相同的参数连续两次调用相同的方法，而没有对实例对象进行任何修改。
            如果此方法未对对象进行更改(看起来没有更改)，则进行两次调用将很浪费。
            通过将结果分配给一个临时变量，然后第二次使用该变量，可以减少这些方法调用。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTA_USE_TO_ARRAY">
        <ShortDescription>方法从集合手动创建数组</ShortDescription>
        <LongDescription>方法 {1} 从集合手动创建数组</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法手动遍历集合，将每个元素取出并存储在数组中以从集合构建数组。
            使用内置的Collection方法toArray更加轻松明了。
            给定类型T的集合"mycollection"，请使用<code>mycollection.toArray(new T[mycollection.size()]); </code></p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LEST_LOST_EXCEPTION_STACK_TRACE">
        <ShortDescription>方法从catch块抛出替代异常却没有带上历史信息</ShortDescription>
        <LongDescription>方法 {1} 从catch块抛出替代异常却没有带上历史信息</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法捕获异常，并引发其他异常，而没有合并原始异常。
            这样做隐藏了异常的原始来源，使调试和解决这些问题变得困难。
            最好使用这个带有原始异常的新异常的构造函数，以便将此详细信息传递给用户。
            如果此异常没有使用初始cause参数的构造函数，请使用initCause方法对其进行初始化。</p>
            <p>
<pre><code>
catch (IOException e) {
    throw new MySpecialException("Failed to open configuration", e);
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UCPM_USE_CHARACTER_PARAMETERIZED_METHOD">
        <ShortDescription>方法将长度为1的常量字符串传递给字符重写方法</ShortDescription>
        <LongDescription>方法 {1} 将长度为1的常量字符串传递给字符重写方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法存在以<char>char</code>为参数的类似方法，将长度为1的常量<code>String</code>作为参数传递给方法。
            处理一个字符而不是<code>String</code>更简单，更方便。</p>

            <p>
            不像这样调用：<br/>
<pre><code>
String myString = ...
if (myString.indexOf("e") != -1) {
    int i = myString.lastIndexOf("e");
    System.out.println(myString + ":" + i);  // Java编译器将在此处隐式使用StringBuilder [builder.append(":")]
    ...
    return myString.replace("m","z");
}
</code></pre>
            用等效的<code>char</code>替换单个字母<code>String</code>，如下所示：<br/>

<pre><code>
String myString = ...
if (myString.indexOf('e') != -1) {
    int i = myString.lastIndexOf('e');
    System.out.println(myString + ':' + i);  // Java编译器将在此处隐式使用StringBuilder [builder.append(':')]
    ...
    return myString.replace('m','z');
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="TR_TAIL_RECURSION">
        <ShortDescription>方法使用尾递归</ShortDescription>
        <LongDescription>方法 {1} 使用尾递归</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法递归地将自身作为本方法的最后一条语句(尾递归)。
            此方法可以轻松地重构为一个简单的循环，从而使其性能更高，并减少堆栈大小要求。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="URV_UNRELATED_RETURN_VALUES">
        <ShortDescription>方法返回不同类型的不相关对象</ShortDescription>
        <LongDescription>方法 {1} 返回不同类型的不相关对象</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法返回两种或两种以上不相关的对象类型(仅通过java.lang.Object相关)。
            这将对必须调用它的代码造成混乱。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="URV_CHANGE_RETURN_TYPE">
        <ShortDescription>方法返回比声明更具体的对象类型</ShortDescription>
        <LongDescription>方法 {1} 返回比声明更具体的对象类型</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法定义为返回java.lang.Object。
            但是，从此方法返回的返回类型可以由更特定的类或接口定义。
            由于此方法不是从父类或接口派生的，因此更改此方法的返回类型会更加清楚。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="URV_INHERITED_METHOD_WITH_RELATED_TYPES">
        <ShortDescription>继承的方法返回比声明更具体的对象类型</ShortDescription>
        <LongDescription>继承的方法 {1} 返回比声明更具体的对象类型</LongDescription>
        <Details>
            <![CDATA[
            <p>定义此继承方法以返回java.lang.Object。
            但是，从此方法返回的返回类型可以由更特定的类或接口定义。
            如果可能的话，请考虑在此方法的继承层次结构中更改返回类型，否则此方法的调用者将很难处理返回类型。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PIS_POSSIBLE_INCOMPLETE_SERIALIZATION">
        <ShortDescription>类未序列化父类字段</ShortDescription>
        <LongDescription>类 {0} 未序列化父类字段</LongDescription>
        <Details>
            <![CDATA[
            <p>此类实现Serializable，但从没有实现的类派生。
            父类具有未序列化的字段，因为此类不能承担使用Serializable的writeObject方法或Externalizable的writeExternal方法将这些字段写出的责任。
            因此，从流中读取此类时，父类字段将仅初始化为其默认构造函数中指定的值。
            如果可能，请更改父类以实现Serializable，或在子类中实现Serializable或Externalizable方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCRV_SUSPICIOUS_COMPARATOR_RETURN_VALUES">
        <ShortDescription>比较方法似乎没有返回有序值</ShortDescription>
        <LongDescription>比较方法 {1} 似乎没有返回有序值</LongDescription>
        <Details>
            <![CDATA[
            <p>此compareTo或compare方法返回表示小于，等于和大于的常量值。
            但是，它不会返回每种类型，或者会无条件地返回非零值。
            考虑到比较器是可传递的，这似乎是不正确的。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_NEGATIVE_BITSET_ITEM">
        <ShortDescription>方法将一个负数作为参数传递给不支持的BitSet</ShortDescription>
        <LongDescription>方法 {1} 将一个负数作为参数传递给不支持的BitSet</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将恒定的负值作为参数传递给java.util.BitSet。
            BitSet类不支持负值，因此此方法调用将无法按预期进行。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_INTERN_ON_CONSTANT">
        <ShortDescription>方法在字符串常量上调用intern</ShortDescription>
        <LongDescription>方法 {1} 在字符串常量上调用intern</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在常量字符串上调用<code>intern</code>。
            由于常量字符串已经被插入，因此此调用是多余的。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_NO_CHAR_SB_CTOR">
        <ShortDescription>方法似乎将字符传递给StringBuffer(int)或StringBuilder(int)</ShortDescription>
        <LongDescription>方法 {1} 似乎将字符传递给StringBuffer(int)或StringBuilder(int)</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用构造函数构造一个StringBuffer或StringBuilder，该构造函数接受一个整数参数，但似乎传入了一个字符。
            作者可能会假定该字符会附加到StringBuffer / Builder上，但是该字符的整数值将用作缓冲区的初始大小。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_MATH_CONSTANT">
        <ShortDescription>方法使用非标准数学常数</ShortDescription>
        <LongDescription>方法 {1} 使用非标准数学常数</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法定义自己的<em>PI</em>或<em>e</em>版本，其值没有在常量Math.PI或Math.E中定义的精确。
            请改用这些常量。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_STUTTERED_ASSIGNMENT">
        <ShortDescription>方法连续两次向本地分配值</ShortDescription>
        <LongDescription>方法 {1} 连续两次向本地分配值</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法以连续赋值方式连续两次分配一个值，例如<code>a = a = 5;</code>这很可能是剪切和粘贴错误，可以删除重复的作业。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_ISNAN">
        <ShortDescription>方法错误地将浮点数与NaN进行比较</ShortDescription>
        <LongDescription>方法 {1} 将一个 {3} 与 {4}.NaN 比较</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将double或float与常数<code>Double.NaN</code>或<code>Float.NaN</code>进行比较。
            如果变量是基本类型，则应使用<code>Double.isNaN(d)</code>或<code>Float.isNaN(f)</code>。
            如果使用包装类型，请使用<code>d.isNaN()</code>或<code>f.isNaN()</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_BIGDECIMAL_STRING_CTOR">
        <ShortDescription>方法将双精度值传递给BigDecimal构造函数</ShortDescription>
        <LongDescription>方法 {1} 将双精度值传递给BigDecimal构造函数</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用接受双精度数的BigDecimal构造函数，并传递一个固定双精度常数值。
            由于使用BigDecimal是为了获得比double更好的精度，但通过传递double值，您只会得到double级别的精度。
            要利用BigDecimal空间，请将数字作为字符串传递。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_STRINGBUFFER_WITH_EMPTY_STRING">
        <ShortDescription>方法将空字符串传递给StringBuilder构造函数</ShortDescription>
        <LongDescription>方法 {1} 将空字符串传递给StringBuilder构造函数</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用StringBuffer或StringBuilder构造函数，并传入一个恒定的空字符串("")。
            这与调用默认构造函数相同，但是使代码更难工作。
            考虑改用默认大小。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_EQUALS_ON_ENUM">
        <ShortDescription>方法在枚举实例上调用equals</ShortDescription>
        <LongDescription>方法 {1}在枚举实例上调用equals</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在枚举实例上调用equals(Object)方法。
            由于枚举值是单例，因此可以使用==安全比较两个枚举值。
            实际上，Enum.equals的实现就是这样做。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_INVALID_BOOLEAN_NULL_CHECK">
        <ShortDescription>方法对布尔使用无效的C++样式null检查</ShortDescription>
        <LongDescription>方法 {1} 对布尔使用无效的C++样式null检查</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法尝试仅通过引用变量名来检查是否为空，就像在C++中那样。
            通常，这将被视为编译错误，除了所涉及的变量是布尔值之外，它会自动拆箱为布尔值。
            <pre><code>
if (b && b.booleanValue())
</code></pre>
            应该<br/>
<pre><code>
if (Boolean.TRUE.equals(b))
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_CHARAT">
        <ShortDescription>方法提取字符数组只是为了执行与charAt方法等效的操作</ShortDescription>
        <LongDescription>方法 {1} 提取字符数组只是为了执行与charAt方法等效的操作</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在String上调用toCharArray方法以获取字符数组，仅按索引检索这些字符之一。
            仅使用charAt方法的性能更高。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USELESS_TERNARY">
        <ShortDescription>方法使用三元运算符将布尔值转换为true或false</ShortDescription>
        <LongDescription>方法 {1} 使用三元运算符将布尔值转换为true或false</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法测试布尔值，并使用三元运算符返回true或false。
            三元运算符完全没有必要，只需使用原始的布尔值即可。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_SUSPECT_STRING_TEST">
        <ShortDescription>方法可能在分支逻辑中混合了普通字符串和空字符串</ShortDescription>
        <LongDescription>方法 {1} 将null和正常字符串视为相同，应将null和空字符串视为相同</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法测试一个字符串，并将空值与实际字符串分组，而将空字符串保留为另一种情况。
            也就是说，FindBugs已检测到如下结构：<br/>
<pre><code>
String a = null, b = "", c = "someString";

String testStr = ...;  //a，b或c之一
if ({{FLAWED_TEST_LOGIC}}) {
    // 字符串a和c属于该分支...这不是典型的。
} else {
    // 字符串b落入该分支。
}
</code></pre>

            这可能是完全正确的，但是通常，逻辑上应以相同的方式处理空值和空字符串，因此此测试可能有缺陷。</p>
            <p>找到的模式是以下之一： <ul>
                <li><code>if ((s == null) || (s.length() &gt; 0))</code> --- 你的意图是
                <code>((s == null) || (s.length() == 0))</code>?</li>
                <li><code>if ((s == null) || (s.length() != 0))</code> -- 你的意图是
                <code>((s == null) || (s.length() == 0))</code>?</li>
                <li><code>if ((s != null) && (s.length() == 0))</code> -- 你的意图是
                <code>((s != null) && (s.length() &gt; 0))</code> 或
                <code>((s == null) || (s.length() == 0))</code>?</li>
            </ul>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_STRINGBUILDER_LENGTH">
        <ShortDescription>方法将StringBuffer或Builder转换为String只是为了获取其长度</ShortDescription>
        <LongDescription>方法 {1} 将StringBuffer或Builder转换为String只是为了获取其长度</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在StringBuffer或StringBuilder上调用toString方法，仅在结果字符串上调用length()。
            仅在StringBuffer或StringBuilder本身上直接调用length方法会更快，更省内存。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_INVALID_CALENDAR_COMPARE">
        <ShortDescription>方法将非日历对象传递给Calendar.before或Calendar.after</ShortDescription>
        <LongDescription>方法 {1} 将非日历对象传递给Calendar.before或Calendar.after</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将非日历对象传递给java.util.Calendar.after或java.util.Calendar.before方法。
            即使这些方法将Object作为参数类型，也仅支持Calendar类型的对象，否则返回false。</p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="SPP_USE_ZERO_WITH_COMPARATOR">
        <ShortDescription>方法将compareTo方法的结果与非零值进行比较</ShortDescription>
        <LongDescription>方法 {1} 将compareTo方法的结果与非零值进行比较</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在对象上调用compareTo方法，然后将结果值与非零值进行比较。
            实际上，只能将compareTo方法指定为返回0，正数或负数，因此您应该比较== 0，>0或<0，而不要与== 1这样的特定值进行比较。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUI_USE_CONTAINSKEY">
        <ShortDescription>方法 仅通过keySet()来调用contains，请改用containsKey</ShortDescription>
        <LongDescription>方法 {1} 仅通过keySet()来调用contains，请改用containsKey</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用mySet.keySet().contains("foo")，而mySet.containsKey("foo")更简单。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_ISEMPTY">
        <ShortDescription>方法通过检查集合的大小是否为零判断是否为空，而没有使用isEmpty()</ShortDescription>
        <LongDescription>方法 {1} 通过检查集合的大小是否为零判断是否为空，而没有使用isEmpty()</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在集合上调用size()方法，并将结果与​​零进行比较，以查看集合是否为空。
            为了使代码更清晰，最好只使用col.isEmpty()或！col.isEmpty()。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_GETPROPERTY">
        <ShortDescription>方法调用getProperties只是为了获得一个属性，应改用getProperty</ShortDescription>
        <LongDescription>方法 {1} 调用getProperties只是为了获得一个属性，应改用getProperty</LongDescription>
        <Details>
            <![CDATA[
            <p>该方法使用
            <code>String prop = System.getProperties().getProperty("foo");</code>
            而不是简单地使用
            <code>String prop = System.getProperty("foo");</code>
			</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_SERIALVER_SHOULD_BE_PRIVATE">
        <ShortDescription>类将serialVersionUID定义为非私有</ShortDescription>
        <LongDescription>类 {0} 将serialVersionUID定义为非私有</LongDescription>
        <Details>
            <![CDATA[
            <p>此类定义一个静态字段'serialVersionUID'来定义此类的序列化版本。
            该字段被标记为非私有。
            由于serialVersionUID仅控制当前类，并且不影响任何派生类，因此将其定义为非私有会造成混淆。
            建议您将此变量更改为私有。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USELESS_CASING">
        <ShortDescription>方法强制执行大小写后比较没有大小写的字符串</ShortDescription>
        <LongDescription>方法 {1} 强制执行大小写后比较没有大小写的字符串</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在字符串上调用toUpperCase或toLowerCase之后用compareToIgnoreCase或equalsIgnoreCase比较两个字符串.
			当您进行比较而不必担心大小写时，toUpperCase或toLowerCase调用是没有意义的，可以删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_NON_ARRAY_PARM">
        <ShortDescription>方法将非数组对象传递给需要数组的参数</ShortDescription>
        <LongDescription>方法 {1} 将非数组对象传递给需要数组的参数</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法期望将数组作为其参数之一传递，但不幸的是将参数定义为Object。
            此方法的调用放如果不传递数组，在运行时将引发异常。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_EMPTY_CASING">
        <ShortDescription>方法将空字符串传递给equalsIgnoreCase或compareToIgnoreCase</ShortDescription>
        <LongDescription>方法 {1} 将空字符串传递给equalsIgnoreCase或compareToIgnoreCase</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将空字符串""传递给equalsIgnoreCase或compareToIgnoreCase。
            由于空字符串不区分大小写，因此使用equals更简单。
            进行length()== 0测试甚至更简单。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_TEMPORARY_TRIM">
        <ShortDescription>方法临时修剪字符串</ShortDescription>
        <LongDescription>方法 {1} 临时修剪字符串</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在String上调用trim()，而不将新字符串分配给另一个变量。
            然后，它在此修剪后的字符串上调用length()或equals()。
            如果修整字符串对于确定其长度或相等性很重要，则在实际使用时可能应修整它。
            首先修剪字符串，将修剪后的值存储在变量中，然后继续测试并使用修剪后的字符串，这样会更有意义。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_STRINGBUILDER_IS_MUTABLE">
        <ShortDescription>方法因为它是可变的，所以不需要为其本身分配StringBuilder</ShortDescription>
        <LongDescription>方法 {1} 因为它是可变的，所以不需要为其本身分配StringBuilder</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用StringBuilder.append并将结果分配给相同的StringBuilder，例如：</p>
            <code>sb = sb.append("foo")</code>
            <p>StringBuilder是可变的，因此这不是必需的。
            StringBuffer也是如此。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_USE_GET0">
        <ShortDescription>方法 在List上使用iterator().next()获取第一项</ShortDescription>
        <LongDescription>方法 {1} 在List上使用iterator().next()获取第一项</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在List上调用myList.iterator().next()以获取第一项。
            仅使用myList.get(0)会更高效。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_DOUBLE_APPENDED_LITERALS">
        <ShortDescription>方法将两个固定字符串拼接到StringBuilder</ShortDescription>
        <LongDescription>方法 {1} 将两个固定字符串拼接到StringBuilder</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将两个文字字符串背对背附加到<code>StringBuilder</code>。
            现代编译器将优化以下内容：<br/>
<pre><code>
public static final string CONST_VAL = "there";
...
String str = "Hello" + " "+ CONST_VAL + " " +"world!";
</code></pre>
            至: <br/>
<pre><code>
public static final string CONST_VAL = "there";
...
String str = "Hello there world!";
</code></pre>
            这意味着连接是在编译时完成的，而不是在运行时完成的，因此<b>不需要</b>进行操作：<br/>
<pre><code>
public static final string CONST_VAL = "there";
...
StringBuilder sb = new StringBuilder("Hello").append(" ").append(CONST_VAL).append(" ").append("world!");
String str = sb.toString();
</code></pre>
            这更难阅读，并且会导致更复杂的字节码。
            </p>

            <p>
            只需在常量上加上"+"符号，就不要在它们之间加上<code>StringBuilder.append()</code>。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_NULL_BEFORE_INSTANCEOF">
        <ShortDescription>方法在调用instanceof之前检查引用是否为null</ShortDescription>
        <LongDescription>方法 {1} 在调用instanceof之前检查引用是否为null</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在查看引用是否是某个类的实例之前，检查该引用是否为null。
            由于instanceof对于空引用将返回false，因此不需要空检查。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_NON_USEFUL_TOSTRING">
        <ShortDescription>方法在尚未重写toString()的类的实例上调用toString()</ShortDescription>
        <LongDescription>方法 {1} 在尚未重写toString()的类的实例上调用toString()</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在尚未覆盖toString()方法的对象上调用<code>toString</code>，因此依赖于java.lang.Object中的实现。
            该字符串只是该对象的类和位置的原始显示，不提供有关使用信息的信息。
            您应该在此类中实现toString。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_TOSTRING_ON_STRING">
        <ShortDescription>方法在字符串上调用toString()</ShortDescription>
        <LongDescription>方法 {1} 在字符串上调用toString()</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在字符串上调用<code>toString</code>。
            如果需要字符串，只需使用对象本身。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_CONVERSION_OF_STRING_LITERAL">
        <ShortDescription>方法转换一个固定字符串</ShortDescription>
        <LongDescription>方法 {1} 在固定字符串上调用 {3}</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在<code>String</code>常量上调用诸如<code>toLowerCase</code>或<code>trim</code>的转换方法。
            您应该自己进行转换并使用转换后的文字。</p>

            <p>
            例如，为代替：<br/>
<pre><code>
return "ThisIsAConstantString".toLowerCase().trim();
</code></pre>
            只需要 <br/>
<pre><code>
return "thisisaconstantstring";
</code></pre>
			以便更短，更容易阅读代码。
			而且当需要进行特定于语言环境的转换时(在<code>toUpperCase()</code>和<code>toLowerCase()</code>的情况下，可能会发生异常)。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_EQUALS_ON_STRING_BUILDER">
        <ShortDescription>方法在StringBuilder或StringBuffer上调用equals(Object o)</ShortDescription>
        <LongDescription>方法 {1} 在StringBuilder或StringBuffer上调用equals(Object o)</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在StringBuilder或StringBuffer上调用equals。
            令人惊讶的是，这些类没有覆盖Object中的equals方法，因此equals仅定义为==(或相同的引用)。
            这很可能不是您想要的。
			如果要检查字符串是否具有相同的字符，则需要在这些对象上调用toString()并将它们与字符串进行比较。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_STATIC_FORMAT_STRING">
        <ShortDescription>方法在静态(非参数化)格式字符串上调用String.format</ShortDescription>
        <LongDescription>方法 {1} 在静态(非参数化)格式字符串上调用String.format</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用String.format，并传递没有替换标记(以％开头)的静态字符串作为格式字符串。
            因此不会发生替换，并且format方法是多余的。
            如果需要参数，请根据需要添加适当的格式标记； 否则，只需删除对String.format的调用并按原样使用静态字符串即可。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SPP_WRONG_COMMONS_TO_STRING_OBJECT">
        <ShortDescription>方法没有将对象传递给commons-lang的ToStringBuilder</ShortDescription>
        <LongDescription>方法 {1} 没有将对象传递给commons-lang的ToStringBuilder</LongDescription>
        <Details>
            <![CDATA[
            此方法使用commons-lang或commons-lang3的ToStringBuilder尝试输出对象。
            但是，没有传递任何对象，仅传递了样式说明符，因此输出将为ToStringStyle对象本身。
            不要忘记将您希望输出的对象作为第一个参数，例如
            <pre>
            ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE); </pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUI_NULL_CHECK_ON_MAP_SUBSET_ACCESSOR">
        <ShortDescription>方法检查Map的keySet()，entrySet()或values()集合是否为null</ShortDescription>
        <LongDescription>方法 {1} 检查Map的keySet()，entrySet()或values()集合是否为null</LongDescription>
        <Details>
            <![CDATA[
            此方法检查Map上的keySet()，entrySet()或values()方法调用的返回值是否为null。
			对于任何有效的运行Map，这些集合将始终为非null，因此该调用是多余的。
			也许您打算检查这些集合是否为空。
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BAS_BLOATED_ASSIGNMENT_SCOPE">
        <ShortDescription>方法在超出所需范围的范围内分配变量</ShortDescription>
        <LongDescription>方法 {1} 在超出所需范围的范围内分配变量</LongDescription>
        <Details>
            <![CDATA[
            <p><em>该探测器具有很高的实验性，很可能会引起很多恐慌、不确定性和怀疑</em></p>
            <p>此方法在外部作用域中为变量分配一个值，而不是实际使用变量的位置。
            假设经检查没有边际效应等副作用，则可以将分配移入内部范围(如果是块)，以便在<code>if</code>判断为false时不执行。
            但是，应注意，赋值的右侧不包含必须发生的副作用，并且不要进行更深的更改，以免稍后执行时会影响赋值的执行。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCII_SPOILED_CHILD_INTERFACE_IMPLEMENTOR">
        <ShortDescription>类通过父类方法来实现父类不知道的接口</ShortDescription>
        <LongDescription>类 {0} 通过父类方法来实现父类不知道的接口</LongDescription>
        <Details>
            <![CDATA[
            <p>此类声明它实现了一个接口，但是通过依赖父类提供的方法来实现该接口，即使这些父类对所讨论的接口一无所知。
            如果您希望孩子不实现该接口的所有方法，则最好将父类声明为实现接口，并且如果该类未提供所有方法，则声明该父类抽象。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DWI_DELETING_WHILE_ITERATING">
        <ShortDescription>方法迭代时删除collection元素</ShortDescription>
        <LongDescription>方法 {1} 迭代时删除collection元素</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法一边在整个集合中进行迭代，一边使用集合的remove方法从集合中删除元素。
            这样做将使迭代器无效，并且进一步使用它将导致引发ConcurrentModificationException。
            为避免这种情况，应使用迭代器的remove方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DWI_MODIFYING_WHILE_ITERATING">
        <ShortDescription>方法在迭代时修改collection元素</ShortDescription>
        <LongDescription>方法 {1} 在迭代时修改collection元素</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法一边在集合中进行迭代，一边使用集合API方法修改集合的内容。
            这样做将使迭代器无效，并且进一步使用它将导致引发ConcurrentModificationException。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="USS_USE_STRING_SPLIT">
        <ShortDescription>方法使用String Tokenizing构建String数组</ShortDescription>
        <LongDescription>方法 {1} 使用String Tokenizing构建String数组</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用StringTokenizer拆分一个String，然后遍历分离的元素并根据这些枚举值构建一个数组。
            使用String.split方法更加简单容易。</p>
            <p>请注意：String.split在传递空字符串时将返回一个1元素的数组，这与使用StringTokenizer相反，后者在第一次hasMoreElements/hasMoreTokens调用中返回false。
            因此，您可能需要使用：</p>
<pre><code>
if (s.length() &gt; 0) <br/>
    return s.split(";");<br/>
return new String[0];<br/>
</code></pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SJVU_SUSPICIOUS_JDK_VERSION_USE">
        <ShortDescription>方法使用rt.jar中不存在的类或方法</ShortDescription>
        <LongDescription>方法 {1} 使用rt.jar中不存在的类或方法，该类或方法在特定版本不存在</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用为该类编译的JDK中不存在的类，调用不存在的方法。
            如果您在编译类时指定-source和-target选项，并且使用的版本早于编译器JDK的版本，则可能会发生这种情况。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UAA_USE_ADD_ALL">
        <ShortDescription>方法使用简单循环将一个集合的内容复制到另一个</ShortDescription>
        <LongDescription>方法 {1} 使用简单循环将一个集合的内容复制到另一个</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用简单的<code>for</code>循环将集合，列表，映射键/值，数组或其他集合的内容复制到另一个集合。
            仅调用传递到源集合中的目标集合的addAll方法更加简单明了。
            如果源是数组，则可以使用Arrays.asList方法将数组包装到集合中。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MRC_METHOD_RETURNS_CONSTANT">
        <ShortDescription>私有方法或静态方法只返回一个常数</ShortDescription>
        <LongDescription>私有方法或静态方法 {1} 只返回一个常数</LongDescription>
        <Details>
            <![CDATA[
            <p>此私有或静态方法仅返回一个常数。
            由于此方法是私有的或静态的，因此无法覆盖其行为，因此返回常量值似乎是可疑的。
            要么应将方法更改为不返回任何值，否则可能希望此方法的另一个代码路径中返回另一个返回值。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NCS_NEEDLESS_CUSTOM_SERIALIZATION">
        <ShortDescription>方法不必要实现，这是默认流行为</ShortDescription>
        <LongDescription>方法 {1} 不必要实现，这是默认流行为</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法通过执行与该方法不存在时相同的操作来实现Serializable接口。
            这种情况下不需要此方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MOM_MISLEADING_OVERLOAD_MODEL">
        <ShortDescription>类同时实现了实例方法和静态方法来"重载"</ShortDescription>
        <LongDescription>类 {0} 同时实现了实例方法和静态方法来"重载"</LongDescription>
        <Details>
            <![CDATA[
            <p>此类使用实例版本和静态版本"重载"相同的方法。
            由于这两种模型的用法不同，这会使这些方法的用户感到困惑。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS">
        <ShortDescription>不受限制的方法将检查的异常转换为未检查的</ShortDescription>
        <LongDescription>不受限制的方法 {1} 将检查的异常转换为未检查的</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法不受接口或超类的约束，但是将捕获的已检查异常转换为未检查异常并抛出该异常。
            仅抛出已检查的异常，将异常添加到方法的throws子句中会更合适。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="EXS_EXCEPTION_SOFTENING_HAS_CHECKED">
        <ShortDescription>受限制方法将已检查的异常转换为未检查的，而不是另一个允许的已检查异常</ShortDescription>
        <LongDescription>受限制方法 {1} 将已检查的异常转换为未检查的，而不是另一个允许的已检查异常</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法的异常签名受超类的接口约束，不要抛出已捕获的检查异常。
            因此，此异常已转换为未经检查的异常并抛出。
            最好抛出允许的最接近的检查异常，并使用初始原因字段用原始异常注释新异常。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="EXS_EXCEPTION_SOFTENING_NO_CHECKED">
        <ShortDescription>受限制方法将检查的异常转换为未检查的</ShortDescription>
        <LongDescription>受限制方法 {1} 将检查的异常转换为未检查的</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法的异常签名受接口或超类的约束，不要抛出任何检查的异常。
            因此，捕获的已检查异常被转换为未检查异常并抛出。
            但是，似乎该类与约束接口或超类由同一作者拥有。
			考虑更改此方法的签名以包括已检查的异常。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="EXS_EXCEPTION_SOFTENING_RETURN_FALSE">
        <ShortDescription>方法将异常转换为布尔"错误代码"值</ShortDescription>
        <LongDescription>方法 {1} 将异常转换为布尔"错误代码"值</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法捕获异常并返回一个布尔值，该布尔值表示是否发生异常。
            这将丢弃异常处理的值，并使代码忽略生成的"错误代码"返回值。
            您应该只将异常抛出给调用方。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CFS_CONFUSING_FUNCTION_SEMANTICS">
        <ShortDescription>方法返回修改后的参数</ShortDescription>
        <LongDescription>方法 {1} 返回修改后的参数</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法似乎是在修改参数，然后将此参数作为方法的返回值返回。
            这将使此方法的调用者感到困惑，因为显然不会更改"原始"传入的参数。
            如果此方法的目的是更改参数，则将方法更改为具有无效返回值将更加清楚。
			如果由于接口或超类协定而需要返回类型，则应该克隆该参数。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_ACTUAL_CONSTANT">
        <ShortDescription>JUnit测试方法将常量传递给第二个(实际)断言参数</ShortDescription>
        <LongDescription>JUnit测试方法 {1} 将常量传递给第二个(实际)断言参数</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用<code>assertXXX</code>传递一个常量值作为两个值中的第二个。
            assert方法假定期望值是第一个参数，因此似乎在这里交换了值的顺序。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_INEXACT_DOUBLE">
        <ShortDescription>JUnit测试方法断言两个double完全相等</ShortDescription>
        <LongDescription>JUnit测试方法 {1} 断言两个double完全相等</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法对两个double或Double调用<code>assertXXX</code>。
            由于双精度不精确，因此您应该使用通过范围参数会给出一定误差范围的assert方法。
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_BOOLEAN_ASSERT">
        <ShortDescription>JUnit测试方法断言一个值等于true或false</ShortDescription>
        <LongDescription>JUnit测试方法 {1} 断言一个值等于true或false</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法断言一个值等于true或false。
            仅使用assertTrue或assertFalse代替会更简单。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_IMPOSSIBLE_NULL">
        <ShortDescription>JUnit测试方法断言自动装箱的值不为null</ShortDescription>
        <LongDescription>JUnit测试方法 {1} 断言自动装箱的值不为null</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法断言一个原始类型自动装箱后的类型不为null。
            这将永远不会发生，因为基本类型绝不会为null，因此自动装箱的值也不是。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_ASSERT_USED">
        <ShortDescription>JUnit测试方法使用Java断言而不是JUnit断言</ShortDescription>
        <LongDescription>JUnit测试方法 {1} 使用Java断言而不是JUnit断言</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用Java断言来确保某个状态有效。
            由于这是JUnit测试，因此更有意义的是使用JUnit断言检查此条件，其允许抛出可被JUnit跟进的异常。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_USE_ASSERT_NULL">
        <ShortDescription>JUnit测试方法传递null给Assert.assertEquals</ShortDescription>
        <LongDescription>JUnit测试方法 {1} 传递null给Assert.assertEquals</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法比较一个对象是否与null相等。
            最好使用Assert.assertNull方法，以便JUnit故障处理方法可以更好地描述预期的测试。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_USE_ASSERT_NOT_NULL">
        <ShortDescription>JUnit测试方法传递null给Assert.assertNotEquals</ShortDescription>
        <LongDescription>JUnit测试方法 {1} 传递null给Assert.assertNotEquals</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法比较一个对象是否与null相等。
            最好使用Assert.assertNotNull方法，以便JUnit故障处理方法可以更好地描述预期的测试。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_USE_ASSERT_EQUALS">
        <ShortDescription>JUnit测试方法将布尔表达式传递给Assert.assertFalse / Assert.assertTrue</ShortDescription>
        <LongDescription>JUnit测试方法 {1} 将布尔表达式传递给Assert.assertFalse / Assert.assertTrue</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法计算一个布尔表达式并将其传递给Assert.assertFalse / Assert.assertTrue。
            最好传递两个值以调用Assert.assertEquals，以便JUnit故障处理方法可以更好地描述预期的测试。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_USE_ASSERT_NOT_EQUALS">
        <ShortDescription>JUnit测试方法将布尔表达式传递给Assert.assertFalse / Assert.assertTrue</ShortDescription>
        <LongDescription>JUnit测试方法 {1} 将布尔表达式传递给Assert.assertFalse / Assert.assertTrue</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法计算一个布尔表达式并将其传递给Assert.assertFalse / Assert.assertTrue。
            最好传递两个值以调用Assert.assertNotEquals，以便JUnit故障处理方法可以更好地描述预期的测试。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_NO_ASSERT">
        <ShortDescription>JUnit测试方法似乎没有断言</ShortDescription>
        <LongDescription>JUnit测试方法 {1} 似乎没有断言</LongDescription>
        <Details>
            <![CDATA[
            <p>此JUnit测试方法没有断言.
            虽然单元测试依赖于是否引发异常，但仍然有效，但如果没有断言，通常表明测试很弱。
            考虑在出现异常后调用<code>fail</code>。
            断言也有可能在此检测器无法看到的调用方法中发生，但这使该测试的逻辑更加难以推理。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_JUNIT_ASSERTION_ODDITIES_USING_DEPRECATED">
        <ShortDescription>在JUnit 4测试中使用不推荐使用的junit.framework.*类</ShortDescription>
        <LongDescription>在JUnit 4测试 {1} 中使用不推荐使用的junit.framework.*类</LongDescription>
        <Details>
            <![CDATA[
            <p>此JUnit 4测试仍在使用junit.framework。*包中的类。
            您应该将它们切换到相应的org.junit。*类集。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_ACTUAL_CONSTANT">
        <ShortDescription>TestNG测试方法将常量传递给第一个(实际)断言参数</ShortDescription>
        <LongDescription>TestNG测试方法 {1} 将常量传递给第一个(实际)断言参数</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用<code>assertXXX</code>传递一个常量值作为两个值中的第一个。
            assert方法假定期望值是第二个参数，因此似乎在这里交换了值的顺序。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_INEXACT_DOUBLE">
        <ShortDescription>TestNG测试方法断言两个double完全相等</ShortDescription>
        <LongDescription>TestNG测试方法 {1} 断言两个double完全相等</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 calls <code>assertXXX</code> with two doubles or Doubles.
            Due to the imprecision of doubles, you should be using the assert method that takes a range parameter that gives a range of error.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_BOOLEAN_ASSERT">
        <ShortDescription>TestNG测试方法断言一个值等于true或false</ShortDescription>
        <LongDescription>TestNG测试方法 {1} 断言一个值等于true或false</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法断言一个值等于true或false。
            仅使用assertTrue或assertFalse代替会更简单。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_IMPOSSIBLE_NULL">
        <ShortDescription>TestNG测试方法自动装箱的值不为null</ShortDescription>
        <LongDescription>TestNG测试方法 {1} 自动装箱的值不为null</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法断言一个原始类型自动装箱后的类型不为null。
            这将永远不会发生，因为基本类型绝不会为null，因此自动装箱的值也不是。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_ASSERT_USED">
            <ShortDescription>TestNG测试方法使用Java断言而不是TestNG断言</ShortDescription>
            <LongDescription>TestNG测试方法 {1} 使用Java断言而不是TestNG断言</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用Java断言来确保某个状态有效。
            由于这是TestNG测试，因此更有意义的是使用TestNG断言检查此条件，其允许抛出可被TestNG跟进的异常。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_USE_ASSERT_NULL">
        <ShortDescription>TestNG测试方法传递null给Assert.assertEquals</ShortDescription>
        <LongDescription>TestNG测试方法 {1} 传递null给Assert.assertEquals</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法比较一个对象是否与null相等。
            最好使用Assert.assertNull方法，以便TestNG故障处理方法可以更好地描述预期的测试。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_USE_ASSERT_NOT_NULL">
        <ShortDescription>TestNG测试方法传递null给Assert.assertNotEquals</ShortDescription>
        <LongDescription>TestNG测试方法 {1} 传递null给Assert.assertNotEquals</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法比较一个对象是否与null相等。
            最好使用Assert.assertNotNull方法，以便TestNG故障处理方法可以更好地描述预期的测试。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_USE_ASSERT_EQUALS">
        <ShortDescription>TestNG测试方法将布尔表达式传递给Assert.assertFalse / Assert.assertTrue</ShortDescription>
        <LongDescription>TestNG测试方法 {1} 将布尔表达式传递给Assert.assertFalse / Assert.assertTrue</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法计算一个布尔表达式并将其传递给Assert.assertFalse / Assert.assertTrue。
            最好传递两个值以调用Assert.assertEquals，以便TestNG故障处理方法可以更好地描述预期的测试。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_USE_ASSERT_NOT_EQUALS">
        <ShortDescription>TestNG测试方法将布尔表达式传递给Assert.assertFalse / Assert.assertTrue</ShortDescription>
        <LongDescription>TestNG测试方法 {1} 将布尔表达式传递给Assert.assertFalse / Assert.assertTrue</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法计算一个布尔表达式并将其传递给Assert.assertFalse / Assert.assertTrue。
            最好传递两个值以调用Assert.assertNotEquals，以便TestNG故障处理方法可以更好地描述预期的测试。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTAO_TESTNG_ASSERTION_ODDITIES_NO_ASSERT">
        <ShortDescription>TestNG测试方法似乎没有断言</ShortDescription>
        <LongDescription>TestNG测试方法 {1} 似乎没有断言</LongDescription>
        <Details>
            <![CDATA[
            <p>此TestNG测试方法没有断言.
            虽然单元测试依赖于是否引发异常，但仍然有效，但如果没有断言，通常表明测试很弱。
            考虑在出现异常后调用<code>fail</code>。
            断言也有可能在此检测器无法看到的调用方法中发生，但这使该测试的逻辑更加难以推理。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCA_SUSPICIOUS_CLONE_ALGORITHM">
        <ShortDescription>克隆方法将新值存储到源对象的成员字段</ShortDescription>
        <LongDescription>克隆方法 {1} 将新值存储到源对象的成员字段</LongDescription>
        <Details>
            <![CDATA[
            <p>clone方法将值存储到源对象的成员字段。
            通常，对克隆对象进行所有更改，并且鉴于几乎总是将克隆视为只读操作，因此这似乎是不正确的。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WEM_WEAK_EXCEPTION_MESSAGING">
        <ShortDescription>方法引发带有静态消息字符串的异常</ShortDescription>
        <LongDescription>方法 {1} 引发带有静态消息字符串的异常</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用静态字符串作为异常消息创建并抛出异常。
            如果没有此特定异常调用的任何特定上下文(例如参数，键成员变量或局部变量的值)，则可能很难推断出此异常是如何发生的。
            考虑将上下文添加到异常消息中。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WEM_OBSCURING_EXCEPTION">
        <ShortDescription>方法抛出一个将特定异常重新包装的java.lang.Exception</ShortDescription>
        <LongDescription>方法 {1} 抛出一个将特定异常重新包装的java.lang.Exception</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法捕获异常并生成类型为java.lang.Exception的新异常，并将原始异常作为新Exception的原因进行传递。
            如果原始Exception实际上是一个java.lang.Error，这是可疑的，因为您不应该处理错误。
            如果原始异常是更特定的异常，则没有理由将其包装在java.lang.Exception中；这只会掩盖正在发生的错误的类型。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SCSS_SUSPICIOUS_CLUSTERED_SESSION_SUPPORT">
        <ShortDescription>方法修改http会话属性而不调用setAttribute</ShortDescription>
        <LongDescription>方法 {1} 修改http会话属性而不调用setAttribute</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法从HttpSession对象获取复杂的对象，修改此对象，但不调用setAttribute来通知应用程序服务器此属性已更改。
            这将导致此属性不会在集群环境中的其他服务器中更新，因为仅复制对setAttribute的调用标记的更改。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_LOGGER_LOST_EXCEPTION_STACK_TRACE">
        <ShortDescription>方法错误地将异常作为第一个参数传递给logger方法</ShortDescription>
        <LongDescription>方法 {1} 错误地将异常作为第一个参数传递给logger方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将异常作为第一个参数传递给logger方法。
            由于记录器使用toString()发出异常，因此可能会丢失堆栈跟踪。
            最好构造一个具有足够上下文的日志消息，并将异常作为第二个参数传递以捕获堆栈跟踪。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_SUSPECT_LOG_CLASS">
        <ShortDescription>方法在分配Logger时指定一个不相关的类</ShortDescription>
        <LongDescription>方法 {1} 在分配Logger时指定一个不相关的类。 见到的是 "{3}", 实际期望的是 "{4}".</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法通过传入与将要使用记录器的类无关的类的规范来创建记录器。
            这可能是由于复制/粘贴代码引起的。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_SUSPECT_LOG_PARAMETER">
        <ShortDescription>构造方法声明一个Logger参数</ShortDescription>
        <LongDescription>构造方法 {1} 声明一个Logger参数</LongDescription>
        <Details>
            <![CDATA[
            <p>该构造函数声明一个参数，即Logger。
            由于记录器是按类静态创建的，因此将Logger从一个类传递到另一类是没有意义的。
            在每个类中声明静态Logger。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_STUTTERED_MESSAGE">
        <ShortDescription>方法记录器中出现口吃异常消息</ShortDescription>
        <LongDescription>方法 {1} 记录器中出现口吃异常消息</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用采用异常的logger方法，并将异常的getMessage()方法的结果作为日志消息传递。
            由于您已经传递了异常，因此该消息已经存在于日志中，并且通过将其作为消息传递而已，这只是在阻塞信息。
            提供描述此方法中的错误的手写消息(可能包括关键变量的值)会更有帮助。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_INVALID_FORMATTING_ANCHOR">
        <ShortDescription>方法尝试使用编号格​​式的锚点记录</ShortDescription>
        <LongDescription>方法 {1} 尝试使用编号格​​式的锚点记录</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法尝试使用SLF4J或Log4j2记录器来记录格式化格式锚点的参数化表达式。
            但是，SLF4J和Log4j2使用简单的未编号锚点(例如{})，而不是代码所使用的其中带有数字的锚点。
            因此，不会发生参数替换。</p>
            <p>此模式无效：<code>LOGGER.error("{0}已损坏", theThing);</code>
            改用<code>LOGGER.error("{}已损坏", theThing);</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

        <BugPattern type="LO_INVALID_STRING_FORMAT_NOTATION">
        <ShortDescription>方法尝试使用String.format表示法进行记录</ShortDescription>
        <LongDescription>方法 {1} 尝试使用String.format表示法进行记录</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法尝试使用SLF4J或Log4j2记录器记录使用String.format表示法的参数化表达式。
            但是，SLF4J和Log4j2使用简单的未编号锚点(例如{})，而不是使用代码时在其中带有百分号的锚点。
            因此，不会发生参数替换。</p>
            <p>此模式无效：<code>LOGGER.error("%s is broken", theThing);</code>
            改用<code>LOGGER.error("{} is broken", theThing);</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_INCORRECT_NUMBER_OF_ANCHOR_PARAMETERS">
        <ShortDescription>方法将错误数量的参数传递给SLF4J或Log4j2记录语句</ShortDescription>
        <LongDescription>方法 {1} 将错误数量的参数传递给SLF4J或Log4j2记录语句</LongDescription>
        <Details>
            <![CDATA[
            <p>根据格式字符串中锚点{}的数量推测，此方法将错误数量的参数传递给SLF4J或Log4j2日志记录方法(错误，警告，信息，调试)。
            如果找到，则允许使用其他异常参数。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_EXCEPTION_WITH_LOGGER_PARMS">
        <ShortDescription>方法在消息中使用记录器参数标记创建异常</ShortDescription>
        <LongDescription>方法 {1} 在消息中使用记录器参数标记创建异常</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法传递一个标准异常作为记录器参数，并希望将此异常替换为SLF4J或Log4j样式参数标记" {}"。
            该标记不会被翻译，因为SLF4J和Log4j2不会处理标记的Exception类。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_APPENDED_STRING_IN_FORMAT_STRING">
        <ShortDescription>方法将串联的字符串传递到SLF4J或Log4j2的格式字符串</ShortDescription>
        <LongDescription>方法 {1} 将串联的字符串传递到SLF4J或Log4j2的格式字符串</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用SLF4J或Log4j2记录器记录一个字符串，其中第一个(格式)字符串是使用串联创建的。
            您应该使用{}标记将动态内容注入到字符串中，以便延迟String的构建，直到需要实际的日志字符串为止。
            如果日志级别足够高，以致不使用此日志语句，则将永远不会执行附加操作。</p>
            ]]>
        </Details>
    </BugPattern>


    <BugPattern type="LO_EMBEDDED_SIMPLE_STRING_FORMAT_IN_FORMAT_STRING">
        <ShortDescription>方法将简单的String.format结果传递给SLF4J或Log4j2的格式字符串</ShortDescription>
        <LongDescription>方法 {1} 将简单的String.format结果传递给SLF4J或Log4j2的格式字符串</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用SLF4J或Log4J2记录器记录通过调用String.format生成的字符串，其中传递的格式字符串是一个常量字符串，仅包含可以由SLF4J或Log4J直接处理的简单格式标记。
            与其这么
            <pre>
                logger.error(String.format("This %s is an error", s));
            <pre>
            不如
            <pre>
                logger.error("This {} is an error", s);
            </pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_TOSTRING_PARAMETER">
        <ShortDescription>方法在记录器参数上显式调用toString()</ShortDescription>
        <LongDescription>方法 {1} 在记录器参数上显式调用toString()</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在日志级别未达到所需级别的情况下，使用参数化日志记录来避免字符串连接的开销。
            但是，传递给日志记录方法的一个或多个参数使用.toString()来表示该参数的String表示形式。
            这是不必要的，因为记录器将为您执行此操作，并且由于已明确完成，因此即使未实际写入log语句，也将始终调用该方法。
            另外，通过删除'.toString()'，可以避免不必要的NPE。
            只需将变量作为参数传递即可。
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LO_NON_PRIVATE_STATIC_LOGGER">
        <ShortDescription>类使用静态类上下文定义非私有记录器</ShortDescription>
        <LongDescription>类 {0} 使用静态类上下文定义非私有记录器</LongDescription>
        <Details>
            <![CDATA[
                <p>此类将静态记录器定义为非私有。
                它通过传递诸如以下类的名称来实现
                <code><pre>
                    public static final Logger LOG = LoggerFactory.getLogger(Foo.class);
                </pre></code>
                由于该类是公共的，因此可以在其他类中使用，但是这样做会提供错误的类引用，因为该类是硬编码的。
                </p>
                <p>
                建议将静态记录器定义为私有记录器，并仅在需要完成记录的任何类中重新定义新记录器。
                <p>
                <p>如果希望让基类定义记录器，并且派生类使用该记录器，则可以潜在地使用基于实例的记录，例如
                <code><pre>
                    protected final Logger LOG = LoggerFactory.getLogger(getClass());
                </pre></code>
                但是，这样做有一个缺点，即成为基于实例的记录器，并在使用它的类的每个实例中创建一个记录器对象。
                </p>
                ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IICU_INCORRECT_INTERNAL_CLASS_USE">
        <ShortDescription>类依靠内部API类</ShortDescription>
        <LongDescription>类 {0} 依靠内部API类</LongDescription>
        <Details>
            <![CDATA[
            <p>此类使用内部API类。
            由于这些类没有记录在案，也没有作为API的一部分对外发布，因此它们可能会更改或删除。
            您不应该使用这些类。</p>
            不应使用的软件包是：
            <ul>
                <li>sun.xxx</li>
                <li>org.apache.xerces.xxx</li>
                <li>org.apache.xalan.xxx</li>
            </ul>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DSOC_DUBIOUS_SET_OF_COLLECTIONS">
        <ShortDescription>方法使用一组数据集合的Set</ShortDescription>
        <LongDescription>方法 {1} 使用一组数据集合的Set</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法创建一个包含其他集合的Set, 或一个Map其keySet是另一个集合。
            由于集合倾向于通过迭代集合的内容来计算hashCode，equals和compareTo，因此执行效果可能会很差。</p>
            <p>此外，使用集合时，通常会使用它来执行"包含"或"查找"类型的功能，当对集合进行处理时，这似乎是可疑的。</p>
            <p>最后，由于通常会修改集合，因此如果集合中包含该集合，则会出现问题，因为当集合在集合中时，hashCode，equals或compareTo值将​​发生变化。</p>
            <p>如果您希望维护一个集合的集合，最好使用List作为外部集合。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BED_BOGUS_EXCEPTION_DECLARATION">
        <ShortDescription>非派生方法声明抛出其不会抛出的异常</ShortDescription>
        <LongDescription>非派生方法 {1} 声明抛出其不会抛出的异常</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法声明它抛出一个其不会抛出的检查异常。
            由于此方法是构造函数，静态方法或私有方法，因此没有必要为此方法在其throws子句中声明异常，而只会导致调用方法不必要地处理永远不会引发的异常。
            有问题的异常应该从throws子句中删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BED_HIERARCHICAL_EXCEPTION_DECLARATION">
        <ShortDescription>方法声明抛出两个或多个有继承关系的异常</ShortDescription>
        <LongDescription>方法 {1} 声明抛出两个或多个有继承关系的异常</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法声明它抛出一个异常，该异常是另一个也声明要抛出的异常的子代。
            假设已声明父异常，则无需也声明子异常；它只会增加混乱。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UNNC_UNNECESSARY_NEW_NULL_CHECK">
        <ShortDescription>方法检查新分配的结果</ShortDescription>
        <LongDescription>方法 {1} 检查新分配的结果</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用<code>new</code>分配一个对象，然后检查该对象为null还是非null。
            由于可以保证新运算符将成功执行或引发异常，因此不需要此null检查，可以将其删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DTEP_DEPRECATED_TYPESAFE_ENUM_PATTERN">
        <ShortDescription>类似乎实现了旧样式类型的安全枚举模式</ShortDescription>
        <LongDescription>类 {0} 似乎实现了旧样式类型的安全枚举模式</LongDescription>
        <Details>
            <![CDATA[
            <p>此类似乎实现了代替实际枚举使用的旧式类型安全枚举模式。
            由于此类是使用Java 1.5或更高版本编译的，因此，如果将其切换到<code>enum</code>，它将更加简单易懂。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="TBP_TRISTATE_BOOLEAN_PATTERN">
        <ShortDescription>方法对于布尔包装类型返回null</ShortDescription>
        <LongDescription>方法 {1} 对于布尔包装类型返回null</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法声明它返回一个布尔包装值。
            但是，代码可以返回空值。
            由于现在可以返回三个值-Boolean.TRUE，Boolean.FALSE，null-您已更改了Boolean的含义。
            仅创建具有所需三个值的新Enum并定义该方法返回该类型将更加清楚。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SUA_SUSPICIOUS_UNINITIALIZED_ARRAY">
        <ShortDescription>方法返回一个似乎未初始化的数组</ShortDescription>
        <LongDescription>方法 {1} 返回一个似乎未初始化的数组</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法返回已分配但显然未初始化的数组。
            此方法的调用者可能会完成初始化此数组的工作，但这不是常见的模式，并且假定刚忘记此数组进行了初始化。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ITU_INAPPROPRIATE_TOSTRING_USE">
        <ShortDescription>方法对toString()调用的结果执行算法运算</ShortDescription>
        <LongDescription>方法 {1} 对toString()调用的结果执行算法运算</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法对toString()调用的结果执行算法运算。
            由于这些方法仅用于调试/记录目的，因此不应作为代码中核心逻辑的基础。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IKNC_INCONSISTENT_HTTP_ATTRIBUTE_CASING">
        <ShortDescription>方法使用相同的HttpSession属性名称，但大小写不同</ShortDescription>
        <LongDescription>方法 {1} 使用相同的HttpSession属性名称，但大小写不同</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法设置或获取一个HttpSession属性，其在其他位置使用过但大小写不同。
            由于HttpSession属性区分大小写，因此这将非常令人困惑。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IKNC_INCONSISTENT_HTTP_PARAM_CASING">
        <ShortDescription>方法使用相同的HttpRequest参数名称，但大小写不同</ShortDescription>
        <LongDescription>方法 {1} 使用相同的HttpRequest参数名称，但大小写不同</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法获取一个HttpServletRequest参数，其在其他位置使用过但大小写不同。
            由于HttpServletRequest参数区分大小写，因此这将非常令人困惑。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OC_OVERZEALOUS_CASTING">
        <ShortDescription>方法通过强制类型转换将右侧表达式转换到比预期更具体的类型</ShortDescription>
        <LongDescription>方法 {1} 通过强制类型转换将右侧表达式转换到比预期更具体的类型</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将表达式的右侧强制转换为比赋值左侧的变量更具体的类。
            强制转换仅必须与左侧的变量一样具体。
            在右侧使用更具体的类型只会增加耦合度。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PDP_POORLY_DEFINED_PARAMETER">
        <ShortDescription>方法定义参数比正常运行所需的抽象级别高</ShortDescription>
        <LongDescription>方法 {1} 定义参数比正常运行所需的抽象级别高</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在代码将这些参数转换为更具体的类型时，它定义得比正常运行所需的抽象级别更抽象。
            由于此方法不可派生，因此您只需定义所需类型的参数即可。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NSE_NON_SYMMETRIC_EQUALS">
        <ShortDescription>Equals 方法 以非对称方式将此对象与其他类型进行比较</ShortDescription>
        <LongDescription>Equals 方法 {1} 以非对称方式将此对象与其他类型进行比较</LongDescription>
        <Details>
            <![CDATA[
            <p>此类实现了equals方法，该方法将该对象与另一类型的对象进行比较。
            这几乎总是一件坏事，但是如果要这样做，则必须确保保持等价的基本对称规则，即如果a等于b，则b等于a。
            似乎与该类进行比较的类并不了解该类，也没有将自身与该类进行比较。</p>
            <p>
            这是一个不好的equals方法示例，请不要这样做： 
<pre><code>
class Person {
    public boolean equals(Object o) {
        if (o instanceof Person) {
            return name.equals(((Person) o).name);
        } else if (o instanceof String) {
            return name.equals(o);
        }
        return false;
    }
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CVAA_CONTRAVARIANT_ARRAY_ASSIGNMENT">
        <ShortDescription>方法执行逆向数组分配</ShortDescription>
        <LongDescription>方法 {1} 执行逆向数组分配</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法包含一个逆向数组分配。
            由于数组是可变数据结构，因此必须将它们的使用限制为协变或不变。</p>

<pre><code>
class A {}
class B extends A {}

B[] b = new B[2];
A[] a = b;
</code></pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CVAA_CONTRAVARIANT_ELEMENT_ASSIGNMENT">
        <ShortDescription>方法执行逆向数组元素分配</ShortDescription>
        <LongDescription>方法 {1} 执行逆向数组元素分配</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法包含一个逆向数组元素分配。
                由于数组是可变数据结构，因此必须将它们的使用限制为协变或不变。</p>

<pre><code>
class A {}
class B extends A {}

B[] b = new B[2];
A[] a = b;
a[0] = new A(); // 导致ArrayStoreException(运行时)
</code></pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NFF_NON_FUNCTIONAL_FIELD">
        <ShortDescription>可序列化类定义了一个不可变瞬态字段</ShortDescription>
        <LongDescription>可序列化类 {0} 定义了一个不可变瞬态字段</LongDescription>
        <Details>
            <![CDATA[
            <p>此可序列化的类将字段定义为瞬态字段和最终字段。
            由于瞬态字段未在流中序列化，因此在反序列化该字段时，需要一些代码重新初始化该字段。
            但是，由于反序列化时不会调用构造函数，因此不会初始化该字段。
            并且由于该字段是最终字段，因此其他方法也无法对其进行初始化。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SNG_SUSPICIOUS_NULL_FIELD_GUARD">
        <ShortDescription>方法测试字段是否为非null作为条件并重新分配它</ShortDescription>
        <LongDescription>方法 {1} 测试字段是否为非null作为条件并重新分配它</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在执行条件代码块之前，测试字段以确保其不为null。
            但是，在条件块中会重新分配该字段。
            很有可能应该检查一下条件代码，以查看该字段是否为空，而不是该字段不为空。</p>
            <p>例：<pre><code>
if (name != null) {
    name = person.getName();
}
</code></pre>
            这可能是正确的，但条件似乎应该是<code>if (name == null)</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SNG_SUSPICIOUS_NULL_LOCAL_GUARD">
        <ShortDescription>方法测试局部变量的值是否不为null作为条件并重新分配它</ShortDescription>
        <LongDescription>方法 {1} 测试局部变量的值是否不为null作为条件并重新分配它</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在执行条件代码块之前，测试局部变量以确保其不为null。
            但是，在条件块中它会重新分配该局部变量。
            很有可能应该检查一下条件代码，以查看局部变量是否为null，而不是局部变量不为null。</p>
            <p>例：<pre><code>
if (name != null) {
    name = person.getName();
}
</code></pre>
            这可能是正确的，但条件似乎应该是<code>if (name == null)</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_RUNTIME_EXIT_OR_HALT">
        <ShortDescription>方法调用Runtime.exit()或Runtime.halt()</ShortDescription>
        <LongDescription>方法 {1} 调用 {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>调用<code>Runtime.exit()</code>或<code>Runtime.halt()</code>将关闭整个Java虚拟机。
            仅应在极少数情况下执行此操作。
            这样的调用使您的代码很难或不可能被其他代码调用。
            考虑改为抛出RuntimeException。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_RUNFINALIZATION">
        <ShortDescription>方法调用finalize</ShortDescription>
        <LongDescription>方法 {1} 调用 {2} 中调用finalize</LongDescription>
        <Details>
            <![CDATA[
            <p>手动调用finalize()可能会导致严重的性能问题，并且可能掩盖了资源清理错误。
            只有垃圾收集器，而不是应用程序代码，才需要考虑finalize()。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_BIGDECIMAL_EQUALS">
        <ShortDescription>方法调用BigDecimal.equals()</ShortDescription>
        <LongDescription>方法 {1} 调用BigDecimal.equals()，这通常是一个错误</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用<code>equals()</code>来比较两个<code>java.math.BigDecimal</code>数字。
            这通常是一个错误，因为两个<code>BigDecimal</code>对象仅在值和小数位数相等时才相等，因此<i>2.0</i>不等于<i>2.00</i>。
            要比较<code>BigDecimal</code>对象的数学相等性，请改用<code>compareTo()</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_INETADDRESS_GETLOCALHOST">
        <ShortDescription>方法调用InetAddress.getLocalHost()</ShortDescription>
        <LongDescription>方法 {1} 调用InetAddress.getLocalHost(), 这可能是安全隐患</LongDescription>
        <Details>
            <![CDATA[
            <p>不要在多网卡服务器上调用<code>InetAddress.getLocalHost()</code>。
            在多网卡服务器上，<code>InetAddress.getLocalHost()</code>仅返回与服务器内部主机名关联的IP地址。
            这可能是任何网络接口，可能会使计算机面临安全风险。
            需要侦听套接字的服务器应用程序应添加可配置的属性，以定义服务器应绑定的网络接口。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_PROMISCUOUS_SERVERSOCKET">
        <ShortDescription>方法创建混杂的ServerSocket对象</ShortDescription>
        <LongDescription>方法 {1} 创建一个混杂的ServerSocket，这可能会带来安全风险</LongDescription>
        <Details>
            <![CDATA[
            <p>不要使用接受任何网络接口上的连接的<code>ServerSocket</code>构造函数或<code>ServerSocketFactory.createServerSocket()</code>工厂方法。
            默认情况下，侦听套接字的应用程序将侦听任何网络接口上的连接尝试，这可能会带来安全风险。
            仅使用<code>ServerSocket</code>构造函数或<code>ServerSocketFactory.createServerSocket()</code>工厂方法的长格式指定特定的本地地址来定义套接字应绑定的网络接口。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_RANDOM_SEED">
        <ShortDescription>方法创建不安全的随机对象</ShortDescription>
        <LongDescription>方法 {1} 创建一个不安全的随机对象，这可能会带来安全风险</LongDescription>
        <Details>
            <![CDATA[
            <p><code>Random()</code>没有种子的构造函数是不安全的，因为它默认为易于猜测的种子：<code>System.currentTimeMillis()</code>.
            初始化<code>new Random(SecureRandom.getInstance("SHA1PRNG").nextLong())</code>之类的种子，或将<code>Random()</code>替换为<code>SecureRandom.getInstance("SHA1PRNG")</code>。
            "SHA1PRNG"是所有平台上支持的随机算法。
            </p>

            <p>
            从Java 6开始，您可以使用<code>new Random(new SecureRandom().nextLong())</code>或<code>new SecureRandom()</code>代替.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_SECURERANDOM">
        <ShortDescription>方法调用不推荐使用的SecureRandom方法</ShortDescription>
        <LongDescription>方法 {1} 调用不推荐使用的SecureRandom方法 {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>在JDK 1.5或更低版本中，建议不要使用<code>SecureRandom()</code>构造函数和<code>SecureRandom.getSeed()</code>方法。
            而是调用<code>SecureRandom.getInstance()</code>和<code>SecureRandom.getInstance().generateSeed()</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_THREAD_PRIORITIES">
        <ShortDescription>方法使用可疑的线程优先级</ShortDescription>
        <LongDescription>方法 {1} 通过调用方法使用可疑的线程优先级 {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>获取或设置线程优先级不是可移植的，并且可能导致或掩盖竞争状况。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_THREAD_YIELD">
        <ShortDescription>方法尝试手动调度线程</ShortDescription>
        <LongDescription>方法 {1} 尝试通过调用方法手动调度线程 {2}</LongDescription>
        <Details>
            <![CDATA[
            <p>使用<code>Thread.sleep()</code>或<code>Thread.yield()</code>进行的手动线程调度没有保证的语义，通常用于掩盖竞争条件。
            存在这些方法以支持Java首次发布时的早期处理器，但不建议用于现代处理器。
            操作系统将为您小心地调度线程。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_WAIT_WITHOUT_TIMEOUT">
        <ShortDescription>方法休眠没有设置超时限制</ShortDescription>
        <LongDescription>当方法 {1} 调用 {2} 休眠时没有设置超时限制</LongDescription>
        <Details>
            <![CDATA[
            <p>调用以下方法之一而没有超时可能会永远阻塞。
            考虑使用超时来检测死锁或性能问题。
            方法：<ul>
            <li>Thread.join()</li>
            <li>Object.wait()</li>
            <li>Condition.await()</li>
            <li>Lock.lock()</li>
            <li>Lock.lockInterruptibly()</li>
            <li>ReentrantLock.lock()</li>
            <li>ReentrantLock.lockInterruptibly()</li>
            </ul>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_THREAD_FAIRNESS">
        <ShortDescription>方法通过调用tryLock()忽略Lock的公平设置。</ShortDescription>
        <LongDescription>方法 {1} 通过调用 {2} 忽略Lock的公平设置</LongDescription>
        <Details>
            <![CDATA[
            <p>在没有超时的情况下调用<code>Lock.tryLock()</code>或<code>ReentrantLock.tryLock()</code>并不遵守锁的公平性设置。
            如果要遵守此锁的公平性设置，请使用几乎等效的<code>tryLock(0, TimeUnit.SECONDS)</code>(它还会检测到中断)。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_SIGNAL_NOT_SIGNALALL">
        <ShortDescription>方法调用Condition.signal()而不是Condition.signalAll()</ShortDescription>
        <LongDescription>方法 {1} 调用Condition.signal()而不是Condition.signalAll()</LongDescription>
        <Details>
            <![CDATA[
            <p><code>Condition.signalAll()</code>优先于<code>Condition.signal()</code>.
            调用<code>signal()</code>只会唤醒一个线程，这意味着唤醒的线程可能不是等待调用者刚刚满足的条件的那个线程。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_LOCK_ISLOCKED">
        <ShortDescription>方法测试锁是否被锁定</ShortDescription>
        <LongDescription>方法 {1} 通过调用 {2} 测试锁是否被锁定</LongDescription>
        <Details>
            <![CDATA[
            <p>调用<code>ReentrantLock.isLocked()</code>或<code>ReentrantLock.isHeldByCurrentThread()</code>可能引起竞争情况或错误的锁定。
            这些方法设计用于调试代码或监视系统状态，而不用于同步控制。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_STRING_BYTES_ENCODING">
        <ShortDescription>方法编码字符串字节而不指定字符编码</ShortDescription>
        <LongDescription>方法 {1} 编码字符串字节而不指定字符编码</LongDescription>
        <Details>
            <![CDATA[
            <p>如果无法在平台的默认字符集中对字符串进行编码，则未定义<code>String(byte[] bytes)</code>和<code>String.getBytes()</code>的行为。
            而是使用<code>String(byte[] bytes，String encoding)</code>或<code>String.getBytes(String encoding)</code>构造函数，该构造函数接受字符串的编码作为参数。
            确保指定用于用户语言环境的编码。</p>

            <p>按照Java规范, "UTF-8", "US-ASCII", "UTF-16" 和 "ISO-8859-1" 将全部有效 <a href = "http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#standard">编码字符集</a>.  
            如果不确定，请尝试 "UTF-8".</p>

            <p><b>Java 1.7的新功能</b>, 您可以从<code>StandardCharsets</code>指定编码, 比如<code>StandardCharsets.UTF_8</code>.
            这些通常是可取的，因为您不必处理<code>UnsupportedEncodingException</code>.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MDM_SETDEFAULTLOCALE">
        <ShortDescription>方法调用Locale.setDefault()</ShortDescription>
        <LongDescription>方法 {1} 调用Locale.setDefault(), 更改所有线程的语言环境</LongDescription>
        <Details>
            <![CDATA[
            <p>不要使用<code>Locale.setDefault()</code>方法更改默认语言环境。
            它将更改所有线程的JVM默认语言环境，并使您的应用程序对线程不安全。
            它不影响主机的语言环境。
            由于更改JVM的默认语言环境可能会影响许多不同的功能区域，因此仅当调用者准备重新初始化在同一Java虚拟机(例如用户界面)中运行的对语言环境敏感的代码时，才应使用此方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ROOM_REFLECTION_ON_OBJECT_METHODS">
        <ShortDescription>方法使用反射来调用java.lang.Object上可用的方法</ShortDescription>
        <LongDescription>方法 {1} 使用反射来调用java.lang.Object上可用的方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用反射来调用java.lang.Object中定义的方法。
            由于这些方法始终可用，因此无需通过反射调用这些方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IPU_IMPROPER_PROPERTIES_USE">
        <ShortDescription>方法将非String值放入Properties对象</ShortDescription>
        <LongDescription>方法 {1} 将非String值放入Properties对象</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将非String对象放入Properties对象。
            由于"Properties"对象旨在成为"String到String"映射，因此放置非String对象是错误的，而且这里其实是利用了Properties没有使用聚合模式而使用了继承的设计缺陷。
            如果您想要一个包含其他类型对象的集合，请使用Hashtable或更好的新集合类型，例如HashMap或TreeMap。</p>
            <p>
            不要使用<code>properties.put("foo", bar);</code>
            </p>
            <p>
            使用<code>properties.setProperty("foo", "bar");</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IPU_IMPROPER_PROPERTIES_USE_SETPROPERTY">
        <ShortDescription>方法使用Properties.put而不是Properties.setProperty</ShortDescription>
        <LongDescription>方法 {1} 使用Properties.put而不是Properties.setProperty</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在Properties对象中使用从Hashtable继承的put(String key，Object value)方法。
            由于Properties对象只是一个String到String映射，因此不建议使用派生的put方法。
            请改用Properties.setProperty方法。</p>
            <p>
            不要使用<code>properties.put("foo", "bar");</code>
            </p>
            <p>
            使用<code>properties.setProperty("foo", "bar");</code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PCAIL_POSSIBLE_CONSTANT_ALLOCATION_IN_LOOP">
        <ShortDescription>方法分配循环中以恒定方式使用的对象</ShortDescription>
        <LongDescription>方法 {1} 分配循环中以恒定方式使用的对象</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在循环中使用默认构造函数分配对象，然后仅以准静态方式使用它。
            它永远不会分配给循环外的任何东西，有可能可以只在循环外分配一次。
            通常，这可以通过在循环中调用类似clear()的方法来重置循环中对象的状态来实现。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WOC_WRITE_ONLY_COLLECTION_LOCAL">
        <ShortDescription>方法创建并初始化一个集合，但是从不读取或获取它的信息</ShortDescription>
        <LongDescription>方法 {1} 创建并初始化一个集合，但是从不读取或获取它的信息</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法创建并初始化一个集合，但是从不访问该集合以获取集合信息或从该集合中获取元素。
            该集合很可能是过去的工作遗留下来的，可以删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WOC_WRITE_ONLY_COLLECTION_FIELD">
        <ShortDescription>类创建并初始化一个集合，但是从不读取或获取它的信息</ShortDescription>
        <LongDescription>类 {0} 创建并初始化一个集合，但是从不读取或获取它的信息</LongDescription>
        <Details>
            <![CDATA[
            <p>此类创建并初始化一个集合作为字段，但是从不访问该集合以获取集合信息或从该集合中获取元素。
            该集合很可能是过去的工作遗留下来的，可以删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UVA_USE_VAR_ARGS">
        <ShortDescription>方法使用数组作为最后一个参数而不是vararg定义参数列表</ShortDescription>
        <LongDescription>方法 {1} 使用数组作为最后一个参数而不是vararg定义参数列表</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法定义一个以数组结尾的参数列表。
            由于此类是使用Java 1.5或更高版本进行编译的，因此可以将该参数定义为vararg参数，这对于客户端开发人员来说更方便使用。
            从本质上讲，这不是一个错误，只是一种改进。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PUS_POSSIBLE_UNSUSPECTED_SERIALIZATION">
        <ShortDescription>方法序列化一个非静态内部类的实例</ShortDescription>
        <LongDescription>方法 {1} 序列化一个非静态内部类的实例</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法序列化一个非静态内部类的实例。
            由于此类引用了包含类，因此该外部类也将被序列化。
            这通常不是故意的，它将使序列化的数据量远远超过所需的数量。
            如果不希望将外部类序列化，则可以将内部类设为静态，或者将其拉到单独的"一等"类中。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SEC_SIDE_EFFECT_CONSTRUCTOR">
        <ShortDescription>方法使用有副作用的构造器</ShortDescription>
        <LongDescription>方法 {1} 使用有副作用的构造器</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法创建一个对象，但不将此对象分配给任何变量或字段。
            这意味着该类借助构造函数中的副作用进行操作，这是一个不好的模式，因为它增加了不必要的耦合。
            考虑将副作用从构造函数中拉出，移至单独的方法或调用方法中。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SGSU_SUSPICIOUS_GETTER_SETTER_USE">
        <ShortDescription>方法 对setter使用相同bean的getter值</ShortDescription>
        <LongDescription>方法 {1} 对setter使用相同bean的getter值</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法检索Java Bean的属性，仅在setter中将其用于同一Bean的相同属性。
            这通常是复制/粘贴错字。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LGO_LINGERING_GRAPHICS_OBJECT">
        <ShortDescription>方法分配一个java.awt.Graphics对象而不处置它</ShortDescription>
        <LongDescription>方法 {1} 分配一个java.awt.Graphics对象而不处置它</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法分配一个java.awt.Graphics对象，但分配并使用完成后没有处置它。
            尽管垃圾收集器会清理掉它，但鉴于可以在短时间内创建大量Graphics对象，建议您显式地丢弃它们。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="STB_STACKED_TRY_BLOCKS">
        <ShortDescription>方法堆叠相似的try / catch块</ShortDescription>
        <LongDescription>方法 {1} 堆叠相似的try / catch块</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法依次声明两个try-catch块，其中每个catch块捕获相同类型的异常。
            他们还统一抛出相同类型的异常。
            这两个捕获块可以组合为一个以简化方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CEBE_COMMONS_EQUALS_BUILDER_ISEQUALS">
        <ShortDescription>方法返回在EqualsBuilder上调用equals()的结果</ShortDescription>
        <LongDescription>方法 {1} 返回在EqualsBuilder中调用equals()的结果</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法返回EqualsBuilder类型上的<code>equals()</code>的结果，而不是调用isEqual()方法。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CHTH_COMMONS_HASHCODE_BUILDER_TOHASHCODE">
        <ShortDescription>方法返回在HashCodeBuilder上调用hashCode()的结果</ShortDescription>
        <LongDescription>方法 {1} 返回在HashCodeBuilder上调用hashCode()的结果</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在HashCodeBuilder类型上返回<code>hashCode()</code>的结果，而不是调用方法toHashCode()。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CSBTS_COMMONS_STRING_BUILDER_TOSTRING">
        <ShortDescription>方法返回调用toString()的结果，而无需在ToStringBuilder中对append()进行中间调用 </ShortDescription>
        <LongDescription>方法 {1} 返回调用toString()的结果，而无需在ToStringBuilder中对append()进行中间调用 </LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在ToStringBuilder上返回<code>toString()</code>的结果，而无需中间调用append()。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CCNE_COMPARE_CLASS_EQUALS_NAME">
        <ShortDescription>方法比较类名而不是比较类</ShortDescription>
        <LongDescription>方法 {1} 比较类名而不是比较类</LongDescription>
        <Details>
            <![CDATA[
            <p>在JVM中，如果两个类由相同的类加载器加载，则它们是相同的类(因此是相同的类型)，并且它们具有相同的完全限定名称[JVMSpec 1999]。
            比较类名将忽略类加载器。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BRPI_BACKPORT_REUSE_PUBLIC_IDENTIFIERS">
        <ShortDescription>方法使用现在已内置的向后移植库</ShortDescription>
        <LongDescription>方法 {1} 使用现在已内置的向后移植库</LongDescription>
        <Details>
            <![CDATA[
            <p>此类使用Emory中的Backport Utils并发类或ThreeTen Backport中的Time类。
            这些类的更新/有效版本可在针对该代码进行编译的JDK版本中找到-并发类已在JDK 1.5内置，时间类已在JDK 1.8内置-这些类仅应在针对JDK低于此版本的情况下使用。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CU_CLONE_USABILITY_OBJECT_RETURN">
        <ShortDescription>克隆方法声明它返回一个对象</ShortDescription>
        <LongDescription>克隆方法 {1} 声明它返回一个对象</LongDescription>
        <Details>
            <![CDATA[
            <p>此类实现Cloneable接口，但定义其克隆方法以返回Object。
            由于此方法的最有可能的用户将需要将其转换为实型，因此这将比需要的更加痛苦。
            只需将返回值声明为此类的类型即可。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CU_CLONE_USABILITY_MISMATCHED_RETURN">
        <ShortDescription>克隆方法声明其返回的类型与所属类不同</ShortDescription>
        <LongDescription>克隆方法 {1} 声明其返回的类型与所属类不同</LongDescription>
        <Details>
            <![CDATA[
            <p>此类实现Cloneable接口，但定义其clone方法以返回与类本身或该类实现的任何接口不同的类型。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CU_CLONE_USABILITY_THROWS">
        <ShortDescription>克隆方法声明它抛出CloneNotSupportedException</ShortDescription>
        <LongDescription>克隆方法 {1} 声明它抛出CloneNotSupportedException</LongDescription>
        <Details>
            <![CDATA[
            <p>此类实现Cloneable接口，但定义其克隆方法仍然抛出CloneNotSupportedException。
            既然您正在实现clone()，那么有问题的方法将不会抛出该异常就很有意义，因此用它对方法进行注释只会使客户端对类的使用更加痛苦，因为它们必须处理永远不会发生的异常。
            只需从您的方法中删除throws子句即可。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CAAL_CONFUSING_ARRAY_AS_LIST">
        <ShortDescription>方法在原始值数组上调用Array.asList</ShortDescription>
        <LongDescription>方法 {1} 在原始值数组上调用Array.asList</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将原始值数组传递给Arrays.asList调用。
            由于数组中的基元值不会自动提升为数组中的盒装图元，因此asList调用无法将此数组转换为盒装图元的列表。
            因此，它只创建一个数组，其中包含一项，即数组本身。
            这很少是所需要的。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PSC_PRESIZE_COLLECTIONS">
        <ShortDescription>方法不会预分配集合的大小</ShortDescription>
        <LongDescription>方法 {1} 不会预分配集合的大小</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法即使使用先验方法(或至少可以合理地猜测)将在集合中放置多少个项目，也使用默认构造函数分配一个集合，从而不必要地导致该集合的中间重新分配。</p>
            <p>您可以使用具有初始大小的构造函数，该构造函数会更好一些，但是由于Maps和Sets的loadFactor，即使这也不是正确的估计。</p>
            <p>如果使用的是Guava，请使用其方法以预定大小分配地图和集合，以最大程度地获得无重新分配的机会，例如： 
            <ul>
                <li>Sets.newHashSetWithExpectedSize(int)</li>
                <li>Maps.newHashMapWithExpectedSize(int)</li>
            </ul>
            如果不是，那么一个很好的估计将是 ExpectedSize / {LOADING_FACTOR}，默认为0.75</p>
            ]]>
        </Details>
    </BugPattern>

        <BugPattern type="PSC_SUBOPTIMAL_COLLECTION_SIZING">
        <ShortDescription>方法使用次优大小来分配集合</ShortDescription>
        <LongDescription>方法 {1} 使用次优大小来分配集合</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用带有size参数的构造函数分配集合。
            但是，由于"地图和集"有一个加载因子，因此传递所需的确切大小是对集合进行预大小的一种错误方法，并且可能仍会导致重新分配。
            由于您使用的是Guava，因此最好使用
            <code><pre>
                Maps.newHashMapWithExpectedSize(c.size());
            </pre></code>
            或
            <code><pre>
                Sets.newHashSetWithExpectedsize(c.size());
            </pre></code>
            因为此方法会在考虑到加载因子的情况下计算出正确的尺寸。

            或者，如果您知道集合不会增长到超出初始大小，则可以在构造函数中指定1.0F的加载因子。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UMTP_UNBOUND_METHOD_TEMPLATE_PARAMETER">
        <ShortDescription>方法声明未绑定的方法模板参数</ShortDescription>
        <LongDescription>方法 {1} 声明未绑定的方法模板参数</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法声明一个不受此方法任何参数约束的方法级别模板参数。
            因此，模板参数不会增加验证或类型安全性，并且可以删除，因为这只会使读者感到困惑。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="NPMC_NON_PRODUCTIVE_METHOD_CALL">
        <ShortDescription>方法忽略非变异方法的返回值</ShortDescription>
        <LongDescription>方法 {1} 忽略非变异方法的返回值</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法忽略假定为不变的通用方法的返回值。
            如果此方法实际上并未修改调用它的对象，则没有理由调用此方法，并且可以将其删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AIOB_ARRAY_INDEX_OUT_OF_BOUNDS">
        <ShortDescription>方法尝试访问超出数组大小的数组元素</ShortDescription>
        <LongDescription>方法 {1} 尝试访问超出数组大小的数组元素</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用已知超出指定数组大小的文字索引访问数组元素。
            这将在运行时导致ArrayIndexOutOfBoundsException。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AIOB_ARRAY_STORE_TO_NULL_REFERENCE">
        <ShortDescription>方法尝试将数组元素存储到未分配的数组中</ShortDescription>
        <LongDescription>方法 {1} 尝试将数组元素存储到未分配的数组中</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法尝试将数组元素存储到似乎尚未分配的数组中。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="ICA_INVALID_CONSTANT_ARGUMENT">
        <ShortDescription>方法传递无效值作为方法参数</ShortDescription>
        <LongDescription>方法 {1} 传递无效值作为方法参数</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将无效的常量值传递给仅需要选择数量可能值的方法参数。
            这可能会导致此方法无法正确运行。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CNC_COLLECTION_NAMING_CONFUSION">
        <ShortDescription>集合变量在名称中以不同的集合类型命名</ShortDescription>
        <LongDescription>集合变量 {1} 在名称中以不同的集合类型命名</LongDescription>
        <Details>
            <![CDATA[
            <p>此类定义一个字段或本地集合变量，其名称中包含不同类型的集合。
            一个示例是名为userList的Set&lt;User&gt;。
            这会使读者感到困惑，并且很可能是由先前的类型重构(未更改名称)引起的。
            该检测器显然仅在检查英文名称。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="PME_POOR_MANS_ENUM">
        <ShortDescription>像枚举一样使用简单字段</ShortDescription>
        <LongDescription>像枚举一样使用简单字段 {1}</LongDescription>
        <Details>
            <![CDATA[
            <p>尽管此字段定义为简单变量(int，String等)，但仅为其分配了一组常量值。
            因此，它似乎像枚举值一样使用，可能应该这样定义。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UP_UNUSED_PARAMETER">
        <ShortDescription>私有方法或静态方法有未使用的参数</ShortDescription>
        <LongDescription>私有方法或静态方法 {1} 有未使用的参数</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法定义从未使用过的参数。
            由于此方法是静态的或私有的，并且不能从其派生，因此可以安全地删除这些参数并简化您的方法。
            您应该考虑(虽然不太可能)可以反射地使用此方法，因此您也将希望更改该调用。
            在这种情况下，很可能一旦删除该参数，就会有一系列方法调用，这些调用花费了一些时间来创建此参数并将其传递给下一行。
            所有这些都可以删除。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="FCCD_FIND_CLASS_CIRCULAR_DEPENDENCY">
        <ShortDescription>类与其他类有循环依赖</ShortDescription>
        <LongDescription>类 {0} 与其他类有循环依赖</LongDescription>
        <Details>
            <![CDATA[
            <p>
            该类与其他类具有循环依赖关系。
            这使得构建这些类很困难，因为每个类都依赖于另一个来正确构建。
            考虑使用接口来打破硬依赖性。
            依赖关系链可以在FindBugs的GUI版本中看到。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUC_MODIFYING_UNMODIFIABLE_COLLECTION">
        <ShortDescription>方法尝试修改似乎是不可变的集合</ShortDescription>
        <LongDescription>方法 {1} 尝试修改似乎是不可变的集合</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法尝试通过Arrays.asList，Collections.unmodifiableXXX或Guava的一种方法来修改从可能已创建不可变集合的来源获取的集合。
            这样做将导致异常，因为这些集合是不可变的。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="HES_EXECUTOR_NEVER_SHUTDOWN">
        <ShortDescription>ExecutorService实例永远不会关闭</ShortDescription>
        <LongDescription>ExecutorService {2} 被实例化，但从不关闭，可能会阻止整个JVM关闭</LongDescription>
        <Details>
            <![CDATA[
            <p>大多数<code>ExecutorService</code>对象必须显式关闭，否则即使其他所有内容都已停止，它们的内部线程也可以延长JVM的运行时间。</p>

            <p>FindBugs已检测到没有对<code>shutdown()</code>或<code>shutdownNow()</code>方法的调用，因此，不能保证<code>ExecutorService</code>可以执行以下操作：永远终止。
            对于<code>Executors.newFixedThreadPool()</code>和<code>Executors</code>类中的大多数其他便捷方法而言，这尤其成问题。</p>

            <p>即使有一些例外情况，特别是在提供自定义<code>ThreadFactory</code>或将<code>allowsCoreThreadTimeOut()</code>设置为true的<code>ThreadPoolExecutor</code>的情况下，在实用程序完成后，最好显式关闭<code>ExecutorService</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="HES_LOCAL_EXECUTOR_SERVICE">
        <ShortDescription>可疑的本地执行器服务</ShortDescription>
        <LongDescription>ExecutorService被创建为局部变量，这是不常见的</LongDescription>
        <Details>
            <![CDATA[
            <p>通常将<code>ExecutorService</code>实例化为字段，以便可以在许多方法调用中在受控数量的<code>Thread</code>上执行许多任务。
            因此，<code>ExecutorService</code>是一个局部变量是不寻常的，在该方法中，只能将任务一次添加一次。</p>

            <p>此外，当本地<code>ExecutorService</code>到达作用域的末端并进行垃圾收集时，内部的<code>Thread</code>不一定会终止，并且可以防止JVM关闭。</p>

            <p>考虑使此局部变量成为一个字段，并创建一个方法来显式关闭<code>ExecutorService</code></p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="HES_EXECUTOR_OVERWRITTEN_WITHOUT_SHUTDOWN">
        <ShortDescription>ExecutorService在引用丢失之前不会关闭</ShortDescription>
        <LongDescription>ExecutorService {1} 被另一个ExecutorService替换而没有关闭，可能会阻止整个JVM关闭</LongDescription>
        <Details>
            <![CDATA[
            <p>大多数<code>ExecutorService</code>对象必须显式关闭，否则，即使其他所有内容都已停止，它们的内部线程也可以阻止JVM关闭。</p>

            <p>FindBugs检测到正在发生以下情况：<br/>
<pre><code>
ExecutorService executor = ... //例如
            Executors.newCachedThreadPool(); ...
public void reset() {
    this.executor = Executors.newCachedThreadPool();
    this.executor.execute(new SampleExecutable());
}
</code></pre><br/>
            对于普通对象，像这样丢失对它们的最后一个引用将触发该对象在垃圾回收中被清除。
            对于<code>ExecutorService</code>，这不足以终止线程池中的内部线程，并且不能保证<code>ExecutorService</code>关闭，从而导致JVM从不停止。<br/>
            要解决此问题，只需添加对<code></code>shutdown()</code>的调用，如下所示：<br/>
<pre><code>
ExecutorService executor = ... //例如
            Executors.newCachedThreadPool(); ...
public void reset() {
    this.executor.shutDown(); //改为
    this.executor = Executors.newCachedThreadPool();
    this.executor.execute(new SampleExecutable());
}
</code></pre>
            </p>

            <p>即使有一些例外情况，特别是在提供自定义<code>ThreadFactory</code>或将<code>allowsCoreThreadTimeOut()</code>设置为true的<code>ThreadPoolExecutor</code>的情况下，优良作法是在执行结束时或替换它时显式关闭<code>ExecutorService</code>。</p>

            <p><b>注意：</b><code>ExecutorService</code>通常在程序的生命周期中创建一次。
            如果您发现自己替换了<code>ExecutorService</code>，也许您可​​以考虑重组代码以使用诸如<code>awaitTermination()</code>或<code>Future</code>/<code>Callable</code>以避免重新创建<code>ExecutorService</code>。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="HCP_HTTP_REQUEST_RESOURCES_NOT_FREED_FIELD">
        <ShortDescription>未释放的HttpRequest网络资源(字段)</ShortDescription>
        <LongDescription>HttpRequest字段 {1} 没有释放其网络资源，这可能会阻塞正在运行的代码</LongDescription>
        <Details>
            <![CDATA[
            <p>FindBugs已检测到未释放关联的<code>org.apache.http.HttpRequest</code>(例如<code>HttpGet</code>，<code>HttpPost</code>等)资源。
            代码如下：<br/>
<pre>code>
private HttpGet httpGet;

public String requestInfo(URI u) {
    this.httpGet = new HttpGet(u);
    try(CloseableHttpResponse response = client.execute(httpGet);) {
        return getResponseAsString(response);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>
                会在几次请求后阻塞，通常不会说明原因。</p>

            <p>
                此代码冻结的原因是因为<code> org.apache.http.HttpRequest</code>需要通过调用<code> reset()</code>或<code> releaseConnection()显式释放其连接。</code>。
                上面的示例很容易解决：<br/>
<pre><code>
private HttpGet httpGet;
...
public String requestInfo(URI u) {
    this.httpGet = new HttpGet(u);
    try(CloseableHttpResponse response = client.execute(httpGet);) {
        return getResponseAsString(response);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
    <b>finally {
        this.httpGet.reset();
    }</b>
    return null;
}<br/>
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="HCP_HTTP_REQUEST_RESOURCES_NOT_FREED_LOCAL">
        <ShortDescription>未释放的HttpRequest网络资源(局部变量)</ShortDescription>
        <LongDescription>本地HttpRequest {1}不会在被垃圾回收之前释放其网络资源，这可能会冻结正在运行的代码</LongDescription>
        <Details>
            <![CDATA[
            <p>FindBugs已检测到未释放其关联资源的<code> org.apache.http.HttpRequest</code>(例如<code> HttpGet</code>，<code> HttpPost</code>等)。
            代码如下：<br/>
<pre><code>
public String requestInfo(URI u) {
    HttpGet httpGet = new HttpGet(u);
    try(CloseableHttpResponse response = client.execute(httpGet);) {
        return getResponseAsString(response);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>
                会在几次请求后冻结，通常不会说明原因。 </p>

            <p>
                此代码冻结的原因是因为<code> org.apache.http.HttpRequest</code>需要通过调用<code> reset()</code>或<code> releaseConnection()显式释放其连接。</code>，<b>即使请求是本地的</ b>。
                垃圾收集器不会释放这些资源，从而导致上述令人沮丧的冻结方案。<br/>
                
                上面的示例很容易解决：<br/>
<pre><code>
public String requestInfo(URI u) {
    HttpGet httpGet = new HttpGet(u);
    try(CloseableHttpResponse response = client.execute(httpGet);) {
        return getResponseAsString(response);
    }
    catch (IOException e) {
        e.printStackTrace();
    }
    <b>finally {
        httpGet.reset();
    }</b>
    return null;
}
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UJM_UNJITABLE_METHOD">
        <ShortDescription>方法太长了以至于JIT无法动态编译</ShortDescription>
        <LongDescription>方法 {1} 太长了以至于JIT无法动态编译</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法长度超过8000个字节。
            默认情况下，无论JIT多么热，JIT都不会尝试对其进行编译，因此将始终对该方法进行解释。
            如果性能很重要，则应考虑将此方法分解为较小的块。 (这对于可读性也是个好主意！)</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CTU_CONFLICTING_TIME_UNITS">
        <ShortDescription>方法对具有不同单位的时间值执行算术运算</ShortDescription>
        <LongDescription>方法 {1} 对具有不同单位的时间值执行算术运算</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法接受看起来似乎代表时间的两个值，并直接对这两个值执行算术运算，即使这两个值似乎代表不同的时间单位，例如将毫秒值添加到纳秒值也是如此。
            为了使它有意义，您应该在执行此计算之前将两个值转换为相同的时间单位。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CSI_CHAR_SET_ISSUES_USE_STANDARD_CHARSET">
        <ShortDescription>方法不必要地使用字符串作为Charset编码</ShortDescription>
        <LongDescription>方法"{3}"不必要地使用字符串来定义编码。可以使用内置字符集代替，例如：{4}</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用字符串来指定<code> Charset</code>编码。
            但是，所调用的方法具有使用<code> Charset</code>对象的替代签名。
            您应该使用此签名，因为此类是使用JDK 7(或更高版本)编译的，并且有问题的<code> Charset</code>可从<code> java.nio.charset.StandardCharsets </ const>获取作为常量。代码>类。</p>
            <p>例如，使用<code> StandardCharsets.UTF_8</code>而不是指定"UTF-8"。
            这样做的另一个好处是您无需捕获<code> UnsupportedEncodingException</code>。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CSI_CHAR_SET_ISSUES_USE_STANDARD_CHARSET_NAME">
        <ShortDescription>方法应该使用StandardCharsets.XXX.name()来指定编码</ShortDescription>
        <LongDescription>方法 {3} 应该使用StandardCharsets.XXX.name()来指定编码</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用手工输入的<code> String</code>文字来指定<code> Charset</code>编码。
            由于此类是使用JDK 7(或更高版本)编译的，并且有问题的字符集可从<code> java.nio.charset.StandardCharsets</code>类中作为常量使用，因此最好使用.name( )的相应<code> StandardCharsets</code>常量的方法。</ p>

            <p>有问题的方法不直接将<code> Charset</code>作为参数，仅支持<code> String</code>。
            不过，请使用<code> StandardCharsets.UTF_8.name()</code>，而不是指定"UTF-8"之类的内容(并可能会混淆)。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CSI_CHAR_SET_ISSUES_UNKNOWN_ENCODING">
        <ShortDescription>方法使用未知的编码字符串</ShortDescription>
        <LongDescription>方法 {3} 使用未知的编码字符串 "{4}"</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用当前JDK无法识别的String文字指定<code> Charset</code>编码。
            该应用程序可能仅会部署在能够识别这种编码的JVM上，但是这种情况似乎令人怀疑。</ p>
            <p>
            标准的JDK编码(对于Java 8)是"UTF-8"，"US-ASCII"，"ISO-8859-1"，"UTF-16BE"，"UTF-16LE"，"UTF-16"。这些都是区分大小写的。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CBC_CONTAINS_BASED_CONDITIONAL">
        <ShortDescription>方法使用可以用Set.contains替换的过于复杂的条件</ShortDescription>
        <LongDescription>方法 {1} 使用可以用Set.contains替换的过于复杂的条件</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用一个过于复杂的<code> if</code>表达式，该表达式由多个条件组成，这些条件由OR连接在一起，其中将相同的局部变量与静态值进行比较。
            当条件数量增加时，构建可能值的静态集合并在该集合上使用contains方法要干净得多。
            这将缩短代码，并使其更具自记录性。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OPM_OVERLY_PERMISSIVE_METHOD">
        <ShortDescription>方法被声明为比代码库中使用的宽松</ShortDescription>
        <LongDescription>方法 {1} 被声明为比代码库中使用的宽松</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法声明比代码使用的宽松。
            使此方法比需要的更宽松，限制了您对此方法进行观察的能力，例如参数用法，可重构性和可派生性。
            在以下情况下，此检测器可能会错误报告：
            <ul>
                <li>从未扫描的代码(例如单元测试)中调用该方法</li>
                <li>该方法是一种API方法，预计将由未知的客户端代码使用</li>
                <li>通过反射调用该方法</li>
            </ul>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="STT_TOSTRING_STORED_IN_FIELD">
        <ShortDescription>方法将toString()调用的值存储到字段中</ShortDescription>
        <LongDescription>方法{0}将toString()调用的值存储到字段中</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在对象上调用toString()方法，并将值存储在字段中。
            这样做会浪费由Class定义对象的类型安全性。
            使用String可以很容易地使用错误的值类型，并且编译器不会捕获这些错误。
            您应尽可能延迟将值转换为字符串的时间，因此不要将其存储为字段。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="STT_STRING_PARSING_A_FIELD">
        <ShortDescription>方法解析一个字符串，它是一个字段</ShortDescription>
        <LongDescription>方法 {1} 解析一个字符串，它是一个字段</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在作为字段或来自字段的集合的String上调用解析方法(indexOf，lastIndexOf，startsWith，endsWith，substring，indexOf)。
            这意味着所讨论的字符串在字符串内部包含信息的多个部分，如果该值是一个真正的集合或带有字段的第一类对象而不是一个字符串，则该字符串将更易于维护且类型安全。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="STT_TOSTRING_MAP_KEYING">
        <ShortDescription>方法使用串联的String作为映射键</ShortDescription>
        <LongDescription>方法 {1} 使用串联的String作为映射键</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法使用StringBuilder隐式或显式构建地图的键。
            这意味着键的类型不仅仅是字符串常量，它是格式正确的字符串。
            但是，没有基于类型的验证，表明此密钥的所有使用都将遵循此格式。
            最好使用一个适当的，简单的，包含两个（或更多）字段的Bean类，以便清楚地知道对键使用的期望。
            </p>
            <p>
            例<br/>
            为代替
            <pre><code>
                V v = myMap.get(tableName + "-" + columnName);
            </code></pre>
            采用
            <pre><code>
                V v = myMap.get(new ColumnSpec(tableName, columnName));
            </code></pre>
            其中ColumnSpec是您创建的一个简单的类似于bean的类。
            优点是
            <ul>
                <li>ColumnSpec完全描述了预期的情况，您需要tableName和columnName </ li>
                <li>程序员没有猜测格式是什么，是tableName +“ _” + columnName吗？</ li>
            </ul>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SLS_SUSPICIOUS_LOOP_SEARCH">
        <ShortDescription>方法找到相等条件后继续循环</ShortDescription>
        <LongDescription>方法 {1} 找到相等条件后继续循环</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在根据相等性在<code>if</code>条件下找到并设置变量后，继续循环，没有中断。
            由于继续执行循环似乎不太可能再次找到该项目，因此在这一点上中断似乎是适当的操作。</p>
            <p>例：
<pre><code>
int age = 0;
for (Person p : people) {
    if (p.getName().equals("Dave")) {
        age = p.getAge();
    }
}
</code></pre>
            在获得“Dave”的年龄后，您可能想休息一下。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="CRF_CONFLATING_RESOURCES_AND_FILES">
        <ShortDescription>方法使用File API访问URL资源</ShortDescription>
        <LongDescription>方法 {1} 使用File API访问URL资源</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法从URL获取资源，并使用File API对其进行操作。
            如果此资源是类路径资源，则在该资源是目录中的文件时它将起作用。
            但是，如果文件位于JAR文件中，则此操作将失败。
            为避免这种混乱的不一致，请改用URL.openStream API来访问类路径资源的数据。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_NO_EQUALS">
        <ShortDescription>类没有实现equals方法</ShortDescription>
        <LongDescription>类 {0} 没有实现equals方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此类具有实例字段，没有equals（Object o）方法。
            可能此类永远不会在一个需要用equals方法的上下文中使用。但是，通常使用此类的使用者假定它是存在的，因此在创建此类方法时最好添加此类方法。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_NO_HASHCODE">
        <ShortDescription>类没有实现hashCode方法</ShortDescription>
        <LongDescription>类 {0} 没有实现hashCode方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此类具有实例字段，没有hashCode（）方法。
            可能此类永远不会在一个需要用hashCode方法的上下文中使用。但是，通常使用此类的使用者假定它是存在的，因此在创建此类方法时最好添加此类方法。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_NO_PACKAGE">
        <ShortDescription>类在默认包中定义</ShortDescription>
        <LongDescription>类 {0} 在默认包中定义</LongDescription>
        <Details>
            <![CDATA[
            <p>此类在默认包中创建。
            应该在适当的包结构中定义类，通常通过代码库所有者的域名的反向定义。
            将代码放入默认（没有）包会限制其用途，包括：
            <ol>
                <li>无法将此类导入带有包的类中</li>
                <li>保留它以命名与其他软件包的冲突。</li>
            </ol>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_NO_TOSTRING">
        <ShortDescription>类没有实现toString方法</ShortDescription>
        <LongDescription>类 {0} 没有实现toString方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此类具有实例字段，没有toString（）方法，这会使使用该类进行调试的难度大大增加。
            考虑添加toString（）方法。
            使用commons-lang3 ToStringBuilder之类的库使此过程变得容易。
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_IDE_GENERATED_PARAMETER_NAMES">
        <ShortDescription>方法使用IDE生成的参数名称</ShortDescription>
        <LongDescription>方法 {1} 使用IDE生成的参数名称</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法似乎是使用IDE从接口或超类生成的。
            因此，IDE为该方法的参数生成了通用名称（arg0，arg1，arg2），并且该方法的作者并未将其更改为有意义的。
            为了更好地理解，建议您根据功能命名这些参数。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_PRINTSTACKTRACE">
        <ShortDescription>方法将堆栈跟踪信息打印到控制台</ShortDescription>
        <LongDescription>方法 {1} 将堆栈跟踪信息打印到控制台</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法将堆栈跟踪信息打印到控制台。
            这是不可配置的，并导致应用程序看起来不专业。
            切换到使用日志记录器，以便用户可以控制记录的内容和位置。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_WRONG_FIELD_ORDER">
        <ShortDescription>类中实例字段排在静态字段之前</ShortDescription>
        <LongDescription>类 {0} 中实例字段排在静态字段之前</LongDescription>
        <Details>
            <![CDATA[
            <p>此类以混乱的顺序定义字段，而其他开发人员则不希望这样做。
            该标准是首先列出静态字段，然后列出实例字段。
            如果字段顺序混乱，则开发人员可能会对其行为做出不正确的假设，并导致错误。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_UPPER_PACKAGE">
        <ShortDescription>类在包中使用大写字符定义</ShortDescription>
        <LongDescription>类 {0} 在包中使用大写字符定义</LongDescription>
        <Details>
            <![CDATA[
            <p>此类在使用大写字母的包中定义。
            程序包名称应采用小写形式。</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IMC_IMMATURE_CLASS_LOWER_CLASS">
        <ShortDescription>类不以大写字母开头</ShortDescription>
        <LongDescription>类 {0} 不以大写字母开头</LongDescription>
        <Details>
            <![CDATA[
            <p>此类的名称不以大写字母开头。
            类应遵循每个单词的第一个字母大写的模式，AsAnExample</p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="IMC_IMMATURE_CLASS_BAD_SERIALVERSIONUID">
        <ShortDescription>类定义一个不等于计算值的计算的serialVersionUID</ShortDescription>
        <LongDescription>类 {0} 定义一个不等于计算值的计算的serialVersionUID</LongDescription>
        <Details>
            <![CDATA[
            <p>此可序列化的类定义了似乎是计算值的serialVersionUID，但是该值与计算值不匹配，因此失去了其作为版本指示符的值。
            创建自定义值（例如1、2、3、4等），或使用IDE重新计算serialVersionUID。</ p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="IMC_IMMATURE_CLASS_VAR_NAME">
        <ShortDescription>类定义一个名为“var”的字段或局部变量</ShortDescription>
        <LongDescription>类 {0} 定义一个名为“var”的字段或局部变量</LongDescription>
        <Details>
            <![CDATA[
            <p>字段或变量名为“var”，它将与使用“var”作为关键字的Java 10内置功能冲突。</p>
            ]]>
        </Details>
    </BugPattern>      

    <BugPattern type="JXI_GET_ENDPOINT_CONSUMES_CONTENT">
        <ShortDescription>JAX-RS方法实现GET请求，但消耗输入</ShortDescription>
        <LongDescription>JAX-RS方法 {1} 实现GET请求，但消耗输入</LongDescription>
        <Details>
            <![CDATA[
            <p>该JAX-RS端点被注释为与@GET请求一起使用，但也记录了它使用JSON或XML数据的文档。
            由于GET请求从URL中提取参数，而不是请求的主体，因此此模式存在问题。
            如果您希望使用JSON或XML数据，则此请求应使用@POST注释。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JXI_INVALID_CONTEXT_PARAMETER_TYPE">
        <ShortDescription>JAX-RS方法指定了无效的@Context参数类型</ShortDescription>
        <LongDescription>JAX-RS方法 {1} 指定了无效的@Context参数类型</LongDescription>
        <Details>
            <![CDATA[
            <p>此JAX-RS端点使用@Context注释对参数进行注释。
            该注释可以提供以下类型的值：
            <ul>
                <li>javax.ws.rs.core.UriInfo</li>
                <li>javax.ws.rs.core.HttpHeaders</li>
                <li>javax.ws.rs.core.Request</li>
                <li>javax.ws.rs.core.SecurityContext</li>
                <li>javax.ws.rs.ext.Providers</li>
                <li>javax.servlet.ServletConfig</li>
                <li>javax.servlet.ServletContext</li>
                <li>javax.servlet.HttpServletRequest</li>
                <li>javax.servlet.HttpServletResponse</li>
            </ul>
            您的容器可能可以提供其他类型，但是这些类型不是标准的，其他应用程序服务器可能不支持。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JXI_PARM_PARAM_NOT_FOUND_IN_PATH">
        <ShortDescription>JAX-RS方法指定不可解析的@PathParam</ShortDescription>
        <LongDescription>JAX-RS方法 {1} 指定不可解析的@PathParam</LongDescription>
        <Details>
            <![CDATA[
            <p>此JAX-RS端点指定了@PathParam，该@PathParam在@Path批注中找不到，因此无法确定从何处填充该参数。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JXI_UNDEFINED_PARAMETER_SOURCE_IN_ENDPOINT">
        <ShortDescription>JAX-RS方法定义没有@*Param或@Context注释或@Consumes方法注释的参数</ShortDescription>
        <LongDescription>JAX-RS方法 {1} 定义没有@*Param或@Context注释或@Consumes方法注释的参数</LongDescription>
        <Details>
            <![CDATA[
            <p>此JAX-RS端点声明一个参数时未指定此参数的值来自何处。
            您可以使用以下几种“Param”注释（@PathParam，@CookieParam，@FormParam @HeaderParam @MatrixParam @QueryParam）之一来指定，也可以添加@Context参数注释，或者可以声明方法@Consumes为XML或JSON流。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_TRANSACTION_ON_NON_PUBLIC_METHOD">
        <ShortDescription>方法上面有一个Spring @Transactional注释，但该方法不公开</ShortDescription>
        <LongDescription>方法 {1} 上面有一个Spring @Transactional注释，但该方法不公开</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法指定一个Spring @Transactional批注，但该方法被定义为非公开。
            Spring仅在公共方法上创建事务边界，因此此注释不对该方法做任何事情。
            将方法公开，或将注释放在更合适的方法上。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_HC_EQUALS_ON_MANAGED_ENTITY">
        <ShortDescription>JPA实体具有生成的@Id，定义了hashCode/equals</ShortDescription>
        <LongDescription>JPA实体 {0} 具有生成的@Id，定义了hashCode/equals</LongDescription>
        <Details>
            <![CDATA[
            <p>此类定义为JPA实体，并具有由JPA提供程序生成的@Id字段。
            由于您不控制直接创建该Id的时间，因此为此类（尤其是与Collections一起使用）实现hashCode / equals是有风险的，因为算法背后的数据将不会保持不变，从而在这些字段更改时会引起问题，并且对象在集合中。
            通常，不定义实体对象的hashCode和equals，而是将其视为IdentityHashSet / Maps的对象，通常更安全。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_NON_PROXIED_TRANSACTION_CALL">
        <ShortDescription>方法带有@Transactional注释，被非Spring代理调用</ShortDescription>
        <LongDescription>方法 {1} 带有@Transactional注释，被非Spring代理调用</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法是带有@Transactional批注的。
            但是，由于此调用来自同一类，因此它不会通过任何Spring代理，因此该方法的事务质量完全丧失了。
            必须始终通过自动装配的Spring bean调用@Transactional方法。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_INEFFICIENT_EAGER_FETCH">
        <ShortDescription>OneToMany联接指定 1+n EAGER 联接</ShortDescription>
        <LongDescription>OneToMany联接指定 1+n EAGER 联接</LongDescription>
        <Details>
        <![CDATA[
        <p>该JPA实体指定了@OneToMany联接，并具有EAGER的提取类型。
        默认情况下，EAGER联接对从原始查询返回的每个元素依次执行选择操作，从而产生 1+n 个查询。
        例如，如果要使用EAGER联接，明智的做法是使用Hibernate中的@Fetch注释或EclipseLink中的@JoinFetch/@BatchFetch注释（或提示）来指定Join类型。
        即使这样，这些注释也可能仅在有限的情况下适用，例如在使用find的情况下。</ p>
        ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_IGNORED_MERGE_RESULT">
        <ShortDescription>方法忽略EntityManager.merge的返回值</ShortDescription>
        <LongDescription>方法 {1} 忽略EntityManager.merge的返回值</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用EntityManager.merge，并丢弃结果值。
            此结果是传递给合并的潜在非托管对象的托管实体版本。
            您应该将返回的管理实体用于任何其他用途。</ p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_NON_SPECIFIED_TRANSACTION_EXCEPTION_HANDLING">
        <ShortDescription>方法 does not specify how to handle transaction when exception is thrown</ShortDescription>
        <LongDescription>方法 {1} does not specify how to handle transaction when exception is thrown</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 declares that it throws one or more non-runtime exceptions.
            It also is annotated with a @Transactional annotation but fails to describe whether to rollback the transaction or not based on this thrown exception.
            Use 'rollbackFor' or 'noRollbackFor' attributes of the Transactional annotation to document this.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="JPAI_UNNECESSARY_TRANSACTION_EXCEPTION_HANDLING">
        <ShortDescription>方法 declares handling a transactional exception that won't be thrown</ShortDescription>
        <LongDescription>方法 {1} declares handling a transactional exception that won't be thrown</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 declares that it either rolls back or does not rollback a transaction based on an expected exception being thrown.
            However, neither this exception, nor any derived exceptions can be thrown from this method, and so the annotation is useless.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SEO_SUBOPTIMAL_EXPRESSION_ORDER">
        <ShortDescription>方法 orders expressions in a conditional in a sub optimal way</ShortDescription>
        <LongDescription>方法 {1} orders expressions in a conditional in a sub optimal way</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 builds a conditional expression, for example, in an <code>if</code> or <code>while</code> statement, where the expressions contain both simple local variable comparisons and comparisons on method calls.
            The expression orders these so that the method calls come before the simple local variable comparisons.
            This causes method calls to be executed in conditions when they do not need to be, and thus potentially causes a lot of code to be executed for nothing.
            By ordering the expressions so that the simple conditions containing local variable conditions are first, you eliminate this waste.
            This assumes that the method calls do not have side effects.
            If the methods do have side effects, it is probably a better idea to pull these calls out of the condition and execute them first, assigning a value to a local variable.
            In this way you give a hint that the call may have side effects.</p>
        <p>Example:
<pre><code>
if ((calculateHaltingProbability() &gt; 0) && shouldCalcHalting) { }
</code></pre>
            would be better as
<pre><code>
if (shouldCalcHalting && (calculateHaltingProbability() &gt; 0) { }
</code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IOI_DOUBLE_BUFFER_COPY">
        <ShortDescription>方法 passes a Buffered Stream/Reader/Writer to a already buffering copy method</ShortDescription>
        <LongDescription>方法 {1} passes a Buffered Stream/Reader/Writer to a already buffering copy method</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 copies data from input to output using streams or reader/writers using a well known copy method, from java.nio, commons-io, springframework, guava or poi.
            These methods are efficient in that they copy these files using buffers.
            However, this method is also buffering the streams, causing a double buffering to occur.
            So data first goes to one buffer, then is copied to another buffer, before making it to the destination (or vice-versa).
            This just causes the copy operation to be inefficient both from a time perspective and a memory allocation one.
            When using these copy methods, do not pass buffered streams/readers/writers.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IOI_COPY_WITH_READER">
        <ShortDescription>方法 performs bulk stream copy with a java.io.Reader derived input</ShortDescription>
        <LongDescription>方法 {1} performs bulk stream copy with a java.io.Reader derived input</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 copies data from a java.io.Reader derived class to an output class, using a bulk copy method supplied by java.nio, commons-io, springframework, guava or poi.
            Since you are copying the entire stream, you don't care about its contents, and thus using a Reader is wasteful, as a reader has to do the hard work of converting byte data to characters, when there is no need to do this.
            Use stream based inputs for better performance.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="IOI_USE_OF_FILE_STREAM_CONSTRUCTORS">
        <ShortDescription>方法 uses a FileInputStream or FileOutputStream constructor</ShortDescription>
        <LongDescription>方法 {1} uses a FileInputStream or FileOutputStream constructor</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 creates and uses a java.io.FileInputStream or java.io.FileOutputStream object.
            Unfortunately both of these classes implement a finalize method, which means that objects created will likely hang around until a full garbage collection occurs, which will leave excessive garbage on the heap for longer, and potentially much longer than expected.
            Java 7 introduced two ways to create streams for reading and writing files that do not have this concern.
            You should consider switching from these above classes to
            <code>
            InputStream is = java.nio.file.Files.newInputStream(myfile.toPath());
            OutputStream os = java.nio.file.Files.newOutputStream(myfile.toPath()); 
            </code>
            </p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="IOI_UNENDED_ZLIB_OBJECT">
        <ShortDescription>方法 creates a ZLIB Inflater or Deflater and doesn't appear to end() it</ShortDescription>
        <LongDescription>方法 {1} creates a ZLIB Inflater or Deflater and doesn't appear to end() it</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 constructs a java.util.zip.Inflater or java.util.zip.Deflater and does not appear to call end() on it.
            This will cause a potentially large amount of memory to hang around inside the object until the object gets garbage collected.
            To avoid this unnecessary bloat, put a call to end() in a finally block of the code where you are using this instance.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="DMC_DUBIOUS_MAP_COLLECTION">
        <ShortDescription>类 holds a map-type field, but uses it as only a List</ShortDescription>
        <LongDescription>类 {0} holds a map-type field {1}, but uses it as only a List</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 instantiates a map-type field in a static initializer or constructor, but then only uses it through iteration.
            This means that this data structure should really just be a List&lt;SomeObject&gt;, where the class held by the list contains the two fields held by the key and value of the Map.
            It was likely done this way to avoid having to create a class, but this just obfuscates the purpose of the field.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="BL_BURYING_LOGIC">
        <ShortDescription>方法 buries logic to the right (indented) more than it needs to be</ShortDescription>
        <LongDescription>方法 {1} buries logic to the right (indented) more than it needs to be</LongDescription>
        <Details>
            <![CDATA[
            <p>Looks for relatively large <code>if</code> blocks of code, where you unconditionally return from them, and then follow that with an unconditional return of a small block.
            This places the bulk of the logic to the right indentation-wise, making it more difficult to read than needed.
            It would be better to invert the logic of the if block, and immediately return, allowing the bulk of the logic to be move to the left for easier reading.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WI_DUPLICATE_WIRED_TYPES">
        <ShortDescription>类 auto wires the same object into two separate fields in a class hierarchy</ShortDescription>
        <LongDescription>类 {0} auto wires the same object into two separate fields in a class hierarchy</LongDescription>
        <Details>
            <![CDATA[
            <p>This class has two fields in either itself or a parent class, which autowire (without specialization) the same object for both fields.
            This is likely caused by a developer just not being aware that the field already is available for your use, and just causes wasted space, and confuses code access to the same object through two different pathways.</p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="WI_MANUALLY_ALLOCATING_AN_AUTOWIRED_BEAN">
        <ShortDescription>方法 allocates an object with new when the class is defined as an autowireable bean</ShortDescription>
        <LongDescription>方法 {1} allocates an object with new when the class is defined as an autowireable bean</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 allocates an object with new, but the class of the object that is being created is marked with a Spring annotation denoting that this class is to be used through an @Autowire annotation.
            Allocating it with <code>new</code> will likely mean that fields on the class will not be autowired, but instead be null.
            You should just autowire an instance of this class into the class in question, or if need be, use Spring's getBean(name) method to fetch one.</p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="WI_WIRING_OF_STATIC_FIELD">
        <ShortDescription>Static field is autowired</ShortDescription>
        <LongDescription>Static Field {1} is autowired</LongDescription>
        <Details>
            <![CDATA[
            <p>Autowiring of static fields does not work using simple @Autowire annotations, not should you attempt to do so as it's an anti pattern.
            Use PostConstruct methods to initialize static fields if you must do something like this.</p>
            ]]>
        </Details>
    
    </BugPattern>

    <BugPattern type="CCI_CONCURRENT_COLLECTION_ISSUES_USE_PUT_IS_RACY">
        <ShortDescription>方法 gets and sets a value of a ConcurrentHashMap in a racy manner</ShortDescription>
        <LongDescription>方法 {1} gets and sets a value of a ConcurrentHashMap in a racy manner</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 retrieves the value of a key from a ConcurrentHashMap, where the value is itself a collection.
            It checks this value for null, and if it is so, creates a new collection and places it in the map.
            This may cause thread race conditions where two threads overwrite each other's values.
            You should be using
            <code>
                ConcurrentHashMap.putIfAbsent(K, V)
            </code>
            instead.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UTWR_USE_TRY_WITH_RESOURCES">
        <ShortDescription>方法 manually handles closing an auto-closeable resource</ShortDescription>
        <LongDescription>方法 {1} manually handles closing an auto-closeable resource</LongDescription>
        <Details>
            <![CDATA[[
            <p>此方法 allocates and uses an auto closeable resource.
            However, it manually closes the resource in a finally block.
            While this is correct management, it doesn't rely on the idiomatic way available to JDK 7 and above, allows for possible subtle problems, and complicates the reading of code by developers expecting the use of try-with-resources.
            </p>
            <p>Switch to using try with resources, as:
            <pre>
                try (InputStream is = getAStream()) {
                    useTheStream(is);
                }
            </pre>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SSCU_SUSPICIOUS_SHADED_CLASS_USE">
        <ShortDescription>方法 calls a method from a class that has been shaded by a 3rdparty jar</ShortDescription>
        <LongDescription>方法 {1} calls a method from a class that has been shaded by a 3rdparty jar</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 calls a method found in a 3rd-party library, which appears to be shaded from another 3rd-party library.
            This occurs when a jar includes other code that uses tools like the maven shade plugin.
            It is likely you wanted to use the "first-class" class from the original jar, rather than the class with the shaded package structure, but your IDE pulled in the wrong import.</p>
            <p>An example might be, you attempted to use a method from the class:
            <pre><code>
            com.google.common.collect.Sets
            </code></pre>
            But instead, you import:
            <pre><code>
            org.apache.jena.ext.com.google.common.collect.Sets
            </code></pre>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="USFW_UNSYNCHRONIZED_SINGLETON_FIELD_WRITES">
        <ShortDescription>方法 of Singleton class writes to a field in an unsynchronized manner</ShortDescription>
        <LongDescription>方法 {1} of Singleton class writes to a field in an unsynchronized manner</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 writes to a field of this class.
            Since this class is seen as a Singleton this can produce race conditions, or cause non-visible changes to other threads, because the field isn't accessed synchronously.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OI_OPTIONAL_ISSUES_USES_IMMEDIATE_EXECUTION">
        <ShortDescription>方法 uses immediate execution of a block of code that is often not used</ShortDescription>
        <LongDescription>方法 {1} uses immediate execution of a block of code that is often not used</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 uses the Optional.orElse() method passing in some code that will execute immediately, whether or not the else case of the Optional is needed.
            This may cause incorrect side effects to happen, or at the minimum, code to execute for no reason.
            It would be better to use Optional.orElseGet() ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OI_OPTIONAL_ISSUES_USES_DELAYED_EXECUTION">
        <ShortDescription>方法 uses delayed execution of a block of code that is trivial</ShortDescription>
        <LongDescription>方法 {1} uses immediate execution of a block of code that is trivial</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 uses the Optional.orElseGet() method passing in a simple variable or constant value.
            As this value takes no time to execute and causes no side effects, the use of Optional.orElseGet is unnecessary and potentially confusing.
            You can use Optional.orElse() instead.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OI_OPTIONAL_ISSUES_CHECKING_REFERENCE">
        <ShortDescription>方法 checks an Optional reference for null</ShortDescription>
        <LongDescription>方法 {1} checks an Optional reference for null</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 compares an Optional reference variable against null.
            As the whole point of the Optional class is to avoid the null pointer exception, this use pattern is highly suspect.
            The code should always make sure the Optional reference is valid, and should count on the APIs of this class to check for the held reference instead.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OI_OPTIONAL_ISSUES_PRIMITIVE_VARIANT_PREFERRED">
        <ShortDescription>方法 uses a java.util.Optional when use of OptionalInt, OptionalLong, OptionalDouble would be more clear</ShortDescription>
        <LongDescription>方法 {1} uses a java.util.Optional when use of OptionalInt, OptionalLong, OptionalDouble would be more clear</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 creates an Optional object to hold an int, double or long.
            In these cases it is more natural to use the Optional variants OptionalInt, OptionalDouble and OptionalLong.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="OI_OPTIONAL_ISSUES_USES_ORELSEGET_WITH_NULL">
        <ShortDescription>方法 uses Optional.orElseGet(null)</ShortDescription>
        <LongDescription>方法 {1} uses Optional.orElseGet(null)</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 uses Optional.orElseGet(null).
            This method is supposed to to receive a lambda expression for what to execute when the Optional is not there.
            If you want to just return null, use Optional.orElse(null) instead.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UAC_UNNECESSARY_API_CONVERSION_DATE_TO_INSTANT">
        <ShortDescription>方法 constructs a Date object, merely to convert it to an Instant object</ShortDescription>
        <LongDescription>方法 {1} constructs a Date object, merely to convert it to an Instant object</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 creates a java.time.Instant object by first creating a java.util.Date object, and then calling toInstant() on it.
            It is simpler to just construct the Instant object directly, say by using {@code Instant.now()} to get the current time, of by using {@code Instant.parse(CharSequence)} to convert a String.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="UAC_UNNECESSARY_API_CONVERSION_FILE_TO_PATH">
        <ShortDescription>方法 constructs a File object, merely to convert it to a Path object</ShortDescription>
        <LongDescription>方法 {1} constructs a File object, merely to convert it to a Path object</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 creates a java.nio.file.Path object by first creating a java.io.File object, and then calling toPath() on it.
            It is simpler to just construct the Path object directly, say by using {@code Paths.get(String...)}.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="RFI_SET_ACCESSIBLE">
        <ShortDescription>方法 uses AccessibleObject.setAccessible to modify accessibility of classes</ShortDescription>
        <LongDescription>方法 {1} uses AccessibleObject.setAccessible to modify accessibility of classes</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 uses the reflective setAccessible method to alter the behavior of methods and fields in classes in ways that were not expected to be accessed by the author.
            Doing so circumvents the protections that the author provided through the class definition, and may expose your application to unexpected side effects and problems.
            This functionality is deprecated in Java 9, and in Java 10 it is expected that this functionality won't work at all.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="AI_ANNOTATION_ISSUES_NEEDS_NULLABLE">
        <ShortDescription>方法 that can return null, is missing a @Nullable annotation</ShortDescription>
        <LongDescription>方法 {1} that can return null, is missing a @Nullable annotation</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 can return null, but is not annotated with an @Nullable annotation.
            Without this annotation, various IDEs, and static analysis tools may not be able to fully discover possible NullPointerExceptions in your code.
            By adding these annotations, you will discover problems around null-ness, more easily.</p>
            <p>Unfortunately there isn't just one @Nullable annotation, but this detector will recognize:</p>
            <ul>
            <li>org.jetbrains.annotations.Nullable</li>
            <li>javax.annotation.Nullable</li>
            <li>javax.annotation.CheckForNull</li>
            <li>edu.umd.cs.findbugs.annotations.Nullable</li>
            <li>org.springframework.lang.Nullable</li>
            <li>android.support.annotations.Nullable</li>
            </ul>
            <p>
            You can supply a comma separated list of classes that are custom Nullable Annotations if you desire, by using the system property -Dfb-contrib.ai.annotations="com.acme.Foo,com.acme.Boo" when run.
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUI_CALLING_SIZE_ON_SUBCONTAINER">
        <ShortDescription>方法 calls size() on a sub collection of a Map</ShortDescription>
        <LongDescription>方法 {1} calls size() on a sub collection of a Map</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 calls <code>size</code> on the keySet(), entrySet() or values() collections of a Map.
            These sub collections will have the same size as the base Map and so it is just simpler to call size on that Map.
            Calling size() on one of these sub collections will causes unnecessary allocations to occur.
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUI_CONTAINSKEY_BEFORE_GET">
        <ShortDescription>方法 check a map with containsKey(), before using get()</ShortDescription>
        <LongDescription>方法 {1} checks a map with containsKey(), before using get()</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 checks for the presence of a key in a map using containsKey(), before attempting to fetch the value of the key using get().
            This equates to doing two map lookups in a row.
            It is much simpler to just fetch the value with get, and checking for non null instead.</p>
            <p>As an example, instead of using
            <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                if (myMap.containsKey("foo")) {
                    String value = myMap.get("foo");
                    ....
                }
            </pre>
            </code>
            convert this to
            <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                String value = myMap.get("foo");
                if (value != null) {
                    ....
                }
            </pre>
            </code>
            </p>
            <p>The only caveat to this is that if you use a null value in a map to represent a third state for the key, then in this case using containsKey is 'correct'.
            This means an entry found in the map with a null value is taken differently than no entry at all.
            However, this is a very subtle programming paradigm, and likely to cause problems.
            If you wish to mark an entry as not being present, it is better to use a named 'sentinel' value to denote this, so instead of: <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                if (myMap.containsKey("foo")) {
                    String value = myMap.get("foo");
                    ....
                }
            </pre>
            </code>
            convert this to
            <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                String value = myMap.get("foo");
                if (NOT_FOUND.equals(value)) {
                    ....
                }
                where NOT_FOUND is some constant that denotes this special status.
            Of course you will need to find a special sentinel value for each type you are using that isn't possible to have normally.
            </pre>
            </code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="MUI_GET_BEFORE_REMOVE">
        <ShortDescription>方法 gets an item from a map with get(), before using remove()</ShortDescription>
        <LongDescription>方法 {1} gets an item from a map with get(), before using remove()</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法 fetches the value of an entry in a map using get(K k), and then follows it up with a remove(K k).
            Since a remove() also returns the value, there is no point for doing the get, and just causes two map lookups to occur when it can be done with just one.</p>
            <p>As an example, instead of using
            <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                String v = myMap.get("foo")) {
                myMap.remove("foo");
            </pre>
            </code>
            convert this to
            <code>
            <pre>
                Map<String, String> myMap = getSomeMap();
                String v = myMap.remove("foo");
            </pre>
            </code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LUI_USE_SINGLETON_LIST">
        <ShortDescription>方法 builds a list from one element using Arrays.asList</ShortDescription>
        <LongDescription>方法 {1} builds a list from one element using Arrays.asList rather than Collections.singletonList</LongDescription>
        <Details>
        <![CDATA[
        <p>此方法 builds a list using Arrays.asList(foo), passing in a single element.
            Arrays.asList needs to first create an array from this one element, and then build a List that wraps this array.
            It is simpler to use Collections.singletonList(foo), which does not create the array, and produces a far simpler instance of List.
            Since both of these arrays are immutable (from the List's point of view) they are equivalent from a usage standpoint.
        </p>
        <p>There is one difference between Array.asList and Collections.singletonList that you should be mindful of.
            The rarely used set(index, value) method is allowed to be used with a List created by Array.asList, but not with Collections.singletonList.
            So if you do use the set(index, value) method continue using Arrays.asList.
        ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LUI_USE_GET0">
        <ShortDescription>方法 uses collection streaming to get first item in a List</ShortDescription>
        <LongDescription>方法 {1} uses collection streaming to get first item in a List</LongDescription>
        <Details>
        <![CDATA[
        <p>此方法 fetches the first item in a List using collection streaming.
            As a list is already ordered there is no need to do that, just use the regular get(0) interface.<br/>
        Example:
        <code><pre>
        String s = myList.stream().findFirst().get();
        </pre></code>
        Can be more simply done using
        <code><pre>
        String s = myList.get(0);
        </pre></code>
        </p>
        ]]>
        </Details>
    </BugPattern>

    <BugPattern type="LUI_USE_COLLECTION_ADD">
        <ShortDescription>方法 passes a temporary one item list to Collection.addAll()</ShortDescription>
        <LongDescription>方法 {1} passes a temporary one item list to Collection.addAll()</LongDescription>
        <Details>
        <![CDATA[
        <p>此方法 creates a temporary list using Collections.singletonList, or Arrays.asList with one
        element in it, and then turns around and calls the addAll() method on another collection.
            Since you are only adding one element to the collection, it is simpler to just call the add(object) method on the collection you are using and by pass creating the intermediate List.</p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_AVOID_CONTAINS_ON_COLLECTED_STREAM">
        <ShortDescription>方法 calls contains() on a collected lambda expression</ShortDescription>
        <LongDescription>方法 {1} calls contains() on a collected lambda expresssion</LongDescription>
        <Details>
        <![CDATA[
        <p>此方法 builds a collection using lambda expressions with a collect terminal operation.
            It then immediately calls the contains() method on it, to see if an item is present.
            This is sub optimal as the lambda still needs to build the entire collection, iterating the entire source list.
            It is better to use anyMatch() to short circuit the building of the collection.
        </p>
        <p>
        Instead of
        <code><pre>
        baubles.stream().map(Bauble::getName).collect(Collectors.toSet()).contains(name)
        </pre></code>
        do
        <code></pre>
        baubles.stream().anyMatch(b -> name.equals(b.getName()))
        </pre></code>
        </p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_USE_METHOD_REFERENCE">
        <ShortDescription>方法 creates an anonymous lambda expression instead of specifying a method reference</ShortDescription>
        <LongDescription>方法 {1} creates an anonymous lamda expression instead of specifying a method reference</LongDescription>
        <Details>
        <![CDATA[
        <p>此方法 defines an anonymous lambda function to be called to fetch a single value from the passed in value.
            While this will work, it is needlessly complex as this function merely calls a single getter method on the object, and thus the code can be simplied by just passing in a method reference instead.</p>
        <p>
        Instead of
        <code><pre>
        baubles.stream().map(b -> b.getName()).collect(Collectors.toSet())
        </pre></code>
        do
        <code></pre>
        baubles.stream().map(Bauble::getName).collect(Collectors.toSet())
        </pre></code>
        </p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_USE_ANY_MATCH">
        <ShortDescription>方法 suboptimally finds any match in a stream</ShortDescription>
        <LongDescription>方法 {1} suboptimally finds any match in a stream</LongDescription>
        <Details>
        <![CDATA[
        <p>此方法使用filter（）.findFirst.isPresent（）在流中查找一项，使用.anyMatch（）将更简洁地执行相同的操作</p>
        ]]></Details>
    </BugPattern>
    
    <BugPattern type="FII_USE_FIND_FIRST">
        <ShortDescription>方法从stream（）收集List只是为了获得第一个元素</ShortDescription>
        <LongDescription>方法 {1} 从stream（）收集List只是为了获得第一个元素</LongDescription>
        <Details>
        <![CDATA[
        <p>此方法将数据流传输到List中只是为了调用get（0）获得第一项。
        您可以只使用findFirst（）来缩短流的处理。</p>
        <p>
        为代替
        <code><pre>
        baubles.stream().collect(Collectors.toList()).get(0)
        </pre></code>
        做
        <code></pre>
        baubles.stream().findFirst().get())
        </pre></code>
        </p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_COMBINE_FILTERS">
        <ShortDescription>方法使用背对背过滤器实现流</ShortDescription>
        <LongDescription>方法 {1} 使用背对背过滤器实现流</LongDescription>
        <Details>
        <![CDATA[
        <p>此方法使用多个过滤器背对背流数据。
        这些可以组合成一个过滤器</p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_USE_FUNCTION_IDENTITY">
        <ShortDescription>方法声明一个身份lambda函数，而不是使用Function.identity()</ShortDescription>
        <LongDescription>方法 {1} 声明一个身份lambda函数，而不是使用Function.identity()</LongDescription>
        <Details>
        <![CDATA[
            <p>此方法声明一个无操作(标识)lambda方法，而不仅仅是指定Function.identity()</p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="FII_AVOID_SIZE_ON_COLLECTED_STREAM">
        <ShortDescription>方法在lambda表达式的集合结果上调用size()</ShortDescription>
        <LongDescription>方法 {1} 在lambda表达式的集合结果上调用size()</LongDescription>
        <Details>
        <![CDATA[
        <p>此方法使用lambda表达式和collect终端操作来构建集合。
            然后，它立即对其调用size()方法，以获取项目计数。
            这是次优的选择，因为lambda仍需要构建整个集合，从而迭代整个源列表。
            最好使用count()谓词来缩短集合的构建。
            如果使用的是Set，则还要添加distinct()谓词。
        </p>
        <p>
        代替
        <code><pre>
        baubles.stream().filter(b -> b.getName("orb")).collect(Collectors.toList()).size())
        </pre></code>
        只需要
        <code></pre>
        baubles.stream().filter(b -> b.getName("orb")).count()
        </pre></code>
        或在Set上可以用
        <code></pre>
        baubles.stream().filter(b -> b.getName("orb")).distinct().count()
        </pre></code>
        </p>
        ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="SUI_CONTAINS_BEFORE_ADD">
        <ShortDescription>方法在使用add()之前检查包含contains的集合中的项目</ShortDescription>
        <LongDescription>方法 {1} 在使用add()之前检查包含contains的集合中的项目</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在添加元素之前检查它是否在集合中。
            这是不必要的，因为您可以仅添加项目，并且如果该项目存在，则不会添加它，否则它将添加。</p>
            <p>例如，以下代码
            <code>
            <pre>
                Set<String>mySet = getSomeSet();
                if (!mySet.contains("foo")) {
                    mySet.add("foo");
                }
            </pre>
            </code>
            转换成
            <code>
            <pre>
                Set<String>mySet = getSomeSet();
                if (mySet.add("foo")) {
                }
            </pre>
            </code>
            </p>
            ]]>
        </Details>
    </BugPattern>
    
    <BugPattern type="SUI_CONTAINS_BEFORE_REMOVE">
        <ShortDescription>方法在使用remove()之前，检查包含集中的项目</ShortDescription>
        <LongDescription>方法 {1} 在使用remove()之前，检查包含集中的项目</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法在删除元素之前检查它是否在集合中。
            这是不必要的，因为您只需删除该项目，并且如果该项目存在，它将返回true。</p>
            <p>例如，以下代码
            <code>
            <pre>
                Set<String>mySet = getSomeSet();
                if (mySet.contains("foo")) {
                    mySet.remove("foo");
                }
            </pre>
            </code>
            转换成
            <code>
            <pre>
                Set<String>mySet = getSomeSet();
                if (mySet.remove("foo")) {
                }
            </pre>
            </code>
            </p>
            ]]>
        </Details>
    </BugPattern>

    <BugPattern type="SAT_SUSPICIOUS_ARGUMENT_TYPES">
        <ShortDescription>方法用看起来不正确的参数调用方法</ShortDescription>
        <LongDescription>方法 {1} 用看起来不正确的参数调用方法</LongDescription>
        <Details>
            <![CDATA[
            <p>此方法调用一个方法，该方法传递对于该方法的预期目的而言似乎不正确的参数。
            确保参数类型有效</p>
            <ul>
            <li><p>对于Match.hasEntry，您似乎不太可能希望同时传递Matcher和Non-Matcher</p></li>
            </ul>
            ]]>
        </Details>
    </BugPattern>

    <!-- BugCode -->

    <BugCode abbrev="ISB">Inefficient String Buffering</BugCode>
    <BugCode abbrev="SCI">Synchronized Collection Iterators</BugCode>
    <BugCode abbrev="CC">Cyclomatic Complexity</BugCode>
    <BugCode abbrev="OCP">Overly Concrete Parameters</BugCode>
    <BugCode abbrev="LII">List Indexed Iterating</BugCode>
    <BugCode abbrev="UCC">Unrelated Collection Contents</BugCode>
    <BugCode abbrev="DRE">Declared Runtime Exception</BugCode>
    <BugCode abbrev="CE">Class Envy</BugCode>
    <BugCode abbrev="LSC">Literal String Comparison</BugCode>
    <BugCode abbrev="PCOA">Partially Constructed Object Access</BugCode>
    <BugCode abbrev="DLC">Dubious List Collection</BugCode>
    <BugCode abbrev="PL">Parallel Lists</BugCode>
    <BugCode abbrev="FP">Final Parameters</BugCode>
    <BugCode abbrev="ACEM">Abstract Class Empty Methods</BugCode>
    <BugCode abbrev="MAC">Manual Array Copy</BugCode>
    <BugCode abbrev="FPL">Floating Point Loops</BugCode>
    <BugCode abbrev="NCMU">Non Collection Method Use</BugCode>
    <BugCode abbrev="CAO">Confusing Autoboxed Overloading</BugCode>
    <BugCode abbrev="AFBR">Abnormal Finally Block Return</BugCode>
    <BugCode abbrev="SMII">Static Method Instance Invocation</BugCode>
    <BugCode abbrev="STS">Spurious Thread States</BugCode>
    <BugCode abbrev="NAB">Needless Autoboxing</BugCode>
    <BugCode abbrev="USBR">Unnecessary Store Before Return</BugCode>
    <BugCode abbrev="COM">Copied Overridden Method</BugCode>
    <BugCode abbrev="ABC">Array Based Collection</BugCode>
    <BugCode abbrev="ODN">Orphaned DOM Node</BugCode>
    <BugCode abbrev="AOM">Abstract Overridden Method</BugCode>
    <BugCode abbrev="CBX">Custom Built XML</BugCode>
    <BugCode abbrev="BSB">Bloated Synchronized Block</BugCode>
    <BugCode abbrev="CLI">Constant List Index</BugCode>
    <BugCode abbrev="SCR">Sloppy Class Reflection</BugCode>
    <BugCode abbrev="AWCBR">Array Wrapped Call By Reference</BugCode>
    <BugCode abbrev="SG">Sluggish GUI</BugCode>
    <BugCode abbrev="NIR">Needless Instance Retrieval</BugCode>
    <BugCode abbrev="DDC">Double Date comparison</BugCode>
    <BugCode abbrev="SWCO">Suspicious Wait on Concurrent Object</BugCode>
    <BugCode abbrev="JVR">JDBC Vendor Reliance</BugCode>
    <BugCode abbrev="PMB">Possible Memory Bloat</BugCode>
    <BugCode abbrev="LSYC">Local Synchronized Collection</BugCode>
    <BugCode abbrev="FCBL">Field Could Be Local</BugCode>
    <BugCode abbrev="NOS">Non Owned Synchronization</BugCode>
    <BugCode abbrev="NRTL">Non Recycleable Taglib</BugCode>
    <BugCode abbrev="S508C">Section 508 Compliance Violations</BugCode>
    <BugCode abbrev="UEC">Use Enum Collections</BugCode>
    <BugCode abbrev="SIL">SQL In Loop</BugCode>
    <BugCode abbrev="NMCS">Needless Member Collection Synchronization</BugCode>
    <BugCode abbrev="ITC">Inheritance Type Checking</BugCode>
    <BugCode abbrev="SACM">Static Array Created in Method</BugCode>
    <BugCode abbrev="PRMC">Possibly Redundant Method Calls</BugCode>
    <BugCode abbrev="UTA">Use toArray</BugCode>
    <BugCode abbrev="LEST">Lost Exception Stack Trace</BugCode>
    <BugCode abbrev="UCPM">Use Character Parameterized Method</BugCode>
    <BugCode abbrev="TR">Tail Recursion</BugCode>
    <BugCode abbrev="URV">Unrelated Return Values</BugCode>
    <BugCode abbrev="PIS">Possible Incomplete Serialization</BugCode>
    <BugCode abbrev="SCRV">Suspicious Comparator Return Values</BugCode>
    <BugCode abbrev="SPP">Sillyness Pot Pourri</BugCode>
    <BugCode abbrev="BAS">Bloated Assignment Scope</BugCode>
    <BugCode abbrev="SCII">Spoiled Child Interface Implementor</BugCode>
    <BugCode abbrev="DWI">Deleting While Iterating</BugCode>
    <BugCode abbrev="USS">Use String Split</BugCode>
    <BugCode abbrev="SJVU">Suspicious JDK Version Use</BugCode>
    <BugCode abbrev="UAA">Use Add All</BugCode>
    <BugCode abbrev="MRC">Method Returns Constant</BugCode>
    <BugCode abbrev="NCS">Needless Custom Serialization</BugCode>
    <BugCode abbrev="MOM">Misleading Overload Model</BugCode>
    <BugCode abbrev="EXS">Exception Softening</BugCode>
    <BugCode abbrev="CFS">Confusing Function Semantics</BugCode>
    <BugCode abbrev="UTAO">Unit Test Assertion Oddities</BugCode>
    <BugCode abbrev="SCA">Suspicious Clone Algorithm</BugCode>
    <BugCode abbrev="WEM">Weak Exception Messaging</BugCode>
    <BugCode abbrev="SCSS">Suspicious Clustered Session Support</BugCode>
    <BugCode abbrev="LO">Logger Oddities</BugCode>
    <BugCode abbrev="IICU">Incorrect Internal Class use</BugCode>
    <BugCode abbrev="DSOC">Dubious Set of Collections</BugCode>
    <BugCode abbrev="BED">Bogus Exception Declaration</BugCode>
    <BugCode abbrev="UNNC">Unnecessary New Null Check</BugCode>
    <BugCode abbrev="DTEP">Deprecated Typesafe Enum Pattern</BugCode>
    <BugCode abbrev="TBP">Tristate Boolean Pattern</BugCode>
    <BugCode abbrev="SUA">Suspicious Uninitialized Array</BugCode>
    <BugCode abbrev="ITU">Inappropriate toString Use</BugCode>
    <BugCode abbrev="IKNC">Inconsistent Key Name Casing</BugCode>
    <BugCode abbrev="OC">Overzealous Casting</BugCode>
    <BugCode abbrev="PDP">Poorly Defined Parameter</BugCode>
    <BugCode abbrev="NSE">Non Symmetric Equals</BugCode>
    <BugCode abbrev="CVAA">Contravariant Array Assignment</BugCode>
    <BugCode abbrev="NFF">Non Functional Field</BugCode>
    <BugCode abbrev="SNG">Suspicious Null Guard</BugCode>
    <BugCode abbrev="MDM">More Dumb Methods</BugCode>
    <BugCode abbrev="ROOM">Reflection on Object Methods</BugCode>
    <BugCode abbrev="IPU">Improper Properties use</BugCode>
    <BugCode abbrev="PCAIL">Possible Constant Allocation In Loop</BugCode>
    <BugCode abbrev="WOC">Write Only Collection</BugCode>
    <BugCode abbrev="UVA">Use Var Args</BugCode>
    <BugCode abbrev="PUS">Possible Unsuspected Serialization</BugCode>
    <BugCode abbrev="SEC">Side Effect Constructor</BugCode>
    <BugCode abbrev="SGSU">Suspicious Getter Setter Use</BugCode>
    <BugCode abbrev="LGO">Lingering Graphics Object</BugCode>
    <BugCode abbrev="STB">Stacked Try Blocks</BugCode>
    <BugCode abbrev="CEBE">Commons EqualsBuilder To Equals</BugCode>
    <BugCode abbrev="CHTH">Commons HashCodeBuilder To hashCode</BugCode>
    <BugCode abbrev="CSBTS">Commons ToStringBuilder To String</BugCode>
    <BugCode abbrev="CCNE">Compare class name equals</BugCode>
    <BugCode abbrev="BRPI">Backport concurrent reuse of public identifiers</BugCode>
    <BugCode abbrev="CU">Clone Usability</BugCode>
    <BugCode abbrev="CAAL">Confusing Array asList</BugCode>
    <BugCode abbrev="PSC">Presize Collection</BugCode>
    <BugCode abbrev="UMTP">Unbound Method Template Parameter</BugCode>
    <BugCode abbrev="NPMC">Non Productive Method Call</BugCode>
    <BugCode abbrev="AIOB">Array Index Out of Bounds</BugCode>
    <BugCode abbrev="ICA">Invalid Constant Argument</BugCode>
    <BugCode abbrev="CNC">Collection Naming Confusion</BugCode>
    <BugCode abbrev="PME">Poor Mans Enum</BugCode>
    <BugCode abbrev="UP">Unused Parameter</BugCode>
    <BugCode abbrev="FCCD">Find Class Circular Dependencies</BugCode>
    <BugCode abbrev="MUC">Modifying Unmodifiable Collection</BugCode>
    <BugCode abbrev="UJM">Unjitable method</BugCode>
    <BugCode abbrev="HES">Hanging ExecutorService</BugCode>
    <BugCode abbrev="HCP">HttpClient Problems</BugCode>
    <BugCode abbrev="CTU">Conflicting Time Units</BugCode>
    <BugCode abbrev="CSI">Charset Issues</BugCode>
    <BugCode abbrev="CBC">Contains Based Conditional</BugCode>
    <BugCode abbrev="OPM">Overly Permissive Method</BugCode>
    <BugCode abbrev="STT">Stringified Types</BugCode>
    <BugCode abbrev="SLS">Suspicious Loop Search</BugCode>
    <BugCode abbrev="CRF">Conflating Resources And Files</BugCode>
    <BugCode abbrev="IMC">Immature Class</BugCode>
    <BugCode abbrev="JXI">JAX-RS Issues</BugCode>
    <BugCode abbrev="JPAI">JPA Issues</BugCode>
    <BugCode abbrev="SEO">Suboptimal Expression Order</BugCode>
    <BugCode abbrev="IOI">IO Issues</BugCode>
    <BugCode abbrev="DMC">Dubious Map Collection</BugCode>
    <BugCode abbrev="BL">Burying Logic</BugCode>
    <BugCode abbrev="WI">Wiring issues</BugCode>
    <BugCode abbrev="CCI">Concurrent Collection Issues</BugCode>
    <BugCode abbrev="UTWR">Use Try With Resources</BugCode>
    <BugCode abbrev="SSCU">Suspicious Shaded Class Use</BugCode>
    <BugCode abbrev="USFW">Unsynchronized Singleton Field Writes</BugCode>
    <BugCode abbrev="OI">Optional Issues</BugCode>
    <BugCode abbrev="UAC">Unnecessary Api Conversion</BugCode>
    <BugCode abbrev="RFI">Reflection Issues</BugCode>
    <BugCode abbrev="AI">Annotation Issues</BugCode>
    <BugCode abbrev="MUI">Map Usage Issues</BugCode>
    <BugCode abbrev="LUI">List Usage Issues</BugCode>
    <BugCode abbrev="FII">FunctionalInterface Issues</BugCode>
    <BugCode abbrev="SUI">Set Usage Issues</BugCode>
    <BugCode abbrev="SAT">Suspicious Argument Types</BugCode>
</MessageCollection>
